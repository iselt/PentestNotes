<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>其他s on My New Hugo Site</title>
    <link>http://localhost:1313/%E5%85%B6%E4%BB%96/</link>
    <description>Recent content in 其他s on My New Hugo Site</description>
    <generator>Hugo 0.125.1</generator>
    <language>en-us</language>
    <atom:link href="http://localhost:1313/%E5%85%B6%E4%BB%96/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>http://localhost:1313/%E5%85%B6%E4%BB%96/hooking/1.%E7%94%A8%E6%88%B7%E6%80%81hooking%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E5%85%B6%E4%BB%96/hooking/1.%E7%94%A8%E6%88%B7%E6%80%81hooking%E4%BB%8B%E7%BB%8D/</guid>
      <description>1. 用户态Hooking介绍 Hook，即钩子，在网络安全用语中，指的是拦截并且修改特定的 API 执行流程，通常用于 Debugging，逆向工程，游戏作弊，检测恶意软件行为。API Hook 将原有的 API 替换为自定义的以进行额外的检视，如果非恶意，则继而调用原有的 API，否则会被拦截。&#xA;安全产品，例如 EDR，可能会实施 SSDT Hooking，IAT Hooking，内联 Hooking。不过对于 SSDT Hooking，因为是内核层的，虽然安全产品可以实施 SSDT Hooking 从而实现更彻底的检视，但也会被恶意软件用来实现文件、网络连接、注册表键等的隐藏。基于内核层的更改，无论目的是好是坏，都可能影响系统安全性、完整性、以及稳定性，因此微软后来引入了 PatchGuard 来阻止对内核的补丁。作为&amp;quot;补偿&amp;quot;，微软引入了我们之前简述过的内核回调，供安全产品进行内核层面的检视。&#xA;IAT Hooking 我们在 PE 小节介绍过 IAT 表了，IAT 表记录了映像文件所引用的模块以及其中的导出函数。我们在编写恶意软件时，调用 Win32 API 或者 NTAPI 的话，则会使 IAT 表中增加该 API 以及其所在的模块。&#xA;以 calc 为例，我们使用 PE Bear 可以查看其在磁盘时候的 IAT 表，这时候 IAT 与 INT 是一致的，没有函数地址。但当 calc 被载入到内存中时，IAT 中会更新函数的地址。例如，我们在下图可以看到 KERNEL32 模块中第一个导入函数是 GetCurrentThreadId，当前 IAT 条目中的值是 HintName 表的 RVA。&#xA;在 WinDBG 中，我们印证了，并且该条目的值被更新成了函数的地址。&#xA;但如果，IAT 条目中的值被修改成安全产品模块的导出函数，那么是不是就意味着调用该函数的时候，安全产品都在检视了？IAT Hooking，就是这么一个原理。不过，如今安全产品，尤其是 EDR，主要使用下面要讲的内联 Hooking 进行函数调用检视。</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/%E5%85%B6%E4%BB%96/hooking/2.%E7%BB%95%E8%BF%87%E7%94%A8%E6%88%B7%E6%80%81hooking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E5%85%B6%E4%BB%96/hooking/2.%E7%BB%95%E8%BF%87%E7%94%A8%E6%88%B7%E6%80%81hooking/</guid>
      <description>2. 绕过用户态Hooking 在上个小节，我们讨论了 EDR 在用户态设置 Hook 的原理，那么相应地，我们可以根据这原理寻找间隙，实现对用户态 Hook 的绕过。截至目前，已经有多种方法绕过 Hook。不过，Hook 并非 EDR 的全部检测能力的来源，因此绕过 Hook 的这个过程本身可能就会被检测为恶意。不过无论如何，在这个小节，我们会过一下常见的一些用于绕过 Hook 的方法，以及它们的 IOC。在下个小节，我们会继续探讨绕过用户态 Hook 的方法，虽然会更加复杂一些。&#xA;检测内联 Hook 内联 Hook 的实施是在要 Hook 的 NTAPI 的 syscall stub 中的 syscall 指令之前用无条件跳转指令覆盖原有指令。不同的 EDR 可能会覆盖不同的指令，例如 CrowdStrike 覆盖的是 mov eax, SSN 这条指令，有的 EDR 覆盖的是 mov r10, rcx 这条指令。&#xA;因此，代码的逻辑便很直接，逐一检查 syscall stub 的前 4 个字节。在代码里，我们通过 PEB Walking 的方法在不调用 LoadLibray，GetModuleHandle，GetProcAddress 函数的情况下可以获得 ntdll 模块的地址、给定函数的地址。这么做可以避免 LoadLibray，GetModuleHandle，GetProcAddress 这些函数在 IAT 中的显示。&#xA;因为涉及对模块的解析，因此我们也会频繁用到 PE 文件相关的结构体。&#xA;#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;windows.</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/%E5%85%B6%E4%BB%96/hooking/3.%E8%B0%83%E7%94%A8syscall%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%80%81hook%E7%BB%95%E8%BF%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E5%85%B6%E4%BB%96/hooking/3.%E8%B0%83%E7%94%A8syscall%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%80%81hook%E7%BB%95%E8%BF%87/</guid>
      <description>3. 调用syscall实现用户态Hook绕过 在上个小节，我们主要是通过对 ntdll 模块进行覆盖或者补丁来移除 hook 实现用户态 hook 的绕过。但是这些方法涉及到对 ntdll 的纂改，以及对内存权限的修改，具有一定的风险。实际上，我们还有其他途径来实现 hook 的绕过。&#xA;提取 syscall 号码 我们可以在 C 项目里定义汇编函数，来实现 NTAPI。我们知道，只需要最少 4 条指令，我们便能成功执行 syscall。但在执行 syscall 之前，我们需要获得目标函数的 SSN。我们可以从磁盘中读取一份干净的 ntdll 并解析得到 SSN，但从磁盘中读取 ntdll 会显得有些可疑，因此最好是解析载入的 ntdll 并设法获得 SSN。&#xA;Hells Gate Hells Gate 通过 PEB Walking 的方法得到加载的 ntdll 地址以及想要获得 SSN 的函数地址。通过对关键字节的比较来确定这是一个有效的 syscall stub，从而提取出 SSN。其实上个小节我们已经用了这个逻辑了。&#xA;原始代码关键部分如下：&#xA;if (*((PBYTE)pFunctionAddress + cw) == 0x4c &amp;amp;&amp;amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b &amp;amp;&amp;amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1 &amp;amp;&amp;amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8 &amp;amp;&amp;amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00 &amp;amp;&amp;amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) { BYTE high = *((PBYTE)pFunctionAddress + 5 + cw); BYTE low = *((PBYTE)pFunctionAddress + 4 + cw); pVxTableEntry-&amp;gt;wSystemCall = (high &amp;lt;&amp;lt; 8) | low; break; } 但是，如果要搜索的函数被 hook 了，那么 SSN 可能不会存在于 syscall stub 里(取决于是什么 EDR 以及覆盖了哪些指令)，这样的话，就不能成功获得 ssn 了。因此，Halos Gate 对此进行了改善。</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/%E5%85%B6%E4%BB%96/hvv%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E5%85%B6%E4%BB%96/hvv%E9%9D%A2%E8%AF%95/</guid>
      <description>HVV面试 OWASP TOP 10 SQL 注入 失效的身份认证 敏感数据泄露 XML 外部实体（XXE） 失效的访问控制 安全配置错误 跨站脚本（XSS） 不安全的反序列化 使用含有已知漏洞的组件 不足的日志记录和监控&#xA;Linux 提权 内核漏洞 SUID SUDO 计划任务 Capabilities 位提权 PEASS-ng（自动化提权脚本）&#xA;Windows 提权 系统内核溢出漏洞提权 数据库提权 错误的系统配置提权 组策略首选项提权</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/%E5%85%B6%E4%BB%96/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/%E5%85%B6%E4%BB%96/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>解决ubuntu-crontab反弹shell失败的问题 https://m3lon.github.io/2019/03/18/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/#more</description>
    </item>
  </channel>
</rss>
