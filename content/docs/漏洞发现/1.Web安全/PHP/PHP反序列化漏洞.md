# PHP 反序列化漏洞

## 序列化与反序列化

### 序列化

serialize()

- 序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。
- 对象->字符串

#### 序列化格式

- PHP 序列化格式：`O: 类名长度："类名": 属性个数：{s: 属性名长度："属性名"; 数据类型：属性值的长度：属性值；}`

#### 不同类型的变量序列化后的格式

- public 属性：`s: 属性名长度："属性名"; 数据类型：属性值的长度：属性值；`

- private 属性：`s: 属性名长度："\00 类名、00 属性名"; 数据类型：属性值的长度：属性值；`

- protected 属性：`s: 属性名长度："\00*\00 属性名"; 数据类型：属性值的长度：属性值；`

举例

```php
<?php 
class test{ 
 public $name = 'xiaohua'; 
 private $address = 'shanxi'; 
 protected $age = '21'; 
} 
$test1 = new test(); 
$object = serialize($test1); 
print_r($object); 
?>
// output(space=\00): O:4:"test":3:{s:4:"name";s:7:"xiaohua";s:13:" test address";s:6:"shanxi";s:6:" * age";s:2:"21";}
```

#### 数据类型对应字母

|数据类型|字母|
| ----------- | ----------- |
|NULL|N|
|布尔|b|
|整型|i|
|浮点型|d|
|字符串|s|
|数组|a|
|对象|O|
|资源|r|

### 反序列化

unserialize()

- 字符串->对象

- 反序列化将字符串转换为对象时，不会触发该对象的构造函数，但会触发其`__wakeup()`方法。

## 魔术方法

***魔术方法触发前提：魔术方法所在类（或对象）被调用***

|魔术方法 (magic method)|说明|
| ----------- | ----------- |
|`__construct()`|当对象创建（new）时会自动调用。但在 unserialize() 时是不会自动调用的。（构造函数）|
|`__destruct()`|当对象被销毁时会自动调用。（析构函数）|
|`__wakeup()`|使用 unserialize 反序列化时自动调用|
|`__sleep()`|使用 serialize 序列化时自动调用|
|`__set()`|在给未定义的属性赋值时自动调用|
|`__get()`|调用未定义的属性时自动调用|
|`__isset()`|使用 isset() 或 empty() 函数时自动调用|
|`__unset()`|使用 unset() 时自动调用|
|`__call()`|调用一个不存在的方法时自动调用|
|`__callStatic()`|调用一个不存在的静态方法时自动调用|
|`__toString()`|把对象转换成字符串时自动调用|
|`__invoke()`|当尝试把对象当方法调用时自动调用|
|`__set_state()`|当使用 var_export() 函数时自动调用，接受一个数组参数|
|`__clone()`|当使用 clone 复制一个对象时自动调用|
|`__debugInfo()`|使用 var_dump() 打印对象信息时自动调用|

## 什么是反序列化漏洞

- PHP 反序列化漏洞也叫 PHP 对象注入。漏洞的形成的根本原因是程序没有对用户输入的反序列化字符串进行检测，导致反序列化过程可以被恶意控制，进而造成代码执行、getshell 等一系列不可控的后果。反序列化漏洞并不是 PHP 特有，也存在于 Java、Python 等语言之中，但其原理基本相通。
- 一般程序在创建的时候，都会重写析构函数和构造函数，反序列化漏洞就是利用这些重写的函数。

## 反序列化 POP 链

- 在反序列化中，我们所能控制的数据就是对象中的各个属性值，所以在 PHP 的反序列化中有一种漏洞利用方法叫做 “面向属性编程”，**面向对象编程从一定程度上来说，就是完成类与类之间的调用**。**POP 链起于一些小的“组件”，这些小“组件”可以调用其他的“组件”**，在 PHP 中，“组件”就是那些**魔术方法**（如：wakeup() 或 destruct）

## 利用条件

- unserialize() 函数的参数可控
- php 中有可以利用的类并且类中有魔术方法

## 内容可控之后获取 flag

### 函数名和函数内容可控

```php
<?php
$a($b)
?>
```

#### 命令执行函数

见<PHP 命令执行。md>

##### 执行系统命令

- `system("command")`：将字符串作为 OS 命令执行，自带输出功能。
- `passthru("command")`：将字符串作为 OS 命令执行，不需要输出执行结果，且输出全部的内容。
- `exec("command")`：将字符串作为 OS 命令执行，需要输出执行结果，且它只会输出最后一行的内容。
- `shell_exec("command")`：将字符串作为 OS 命令执行，需要输出执行结果，且输出全部的内容。

#### 文件读取函数

- `show_source("/flag")`

### 当遇到创建类可控时，可考虑使用内置类

```php
<?php
echo new $a($b);
?>
```

- `SplFileObject`：可读取文件内容

POST a=SplFileObject&b=php://filter/read=convert.base64-encode/resource=flag.php

## __wakeup() 绕过（CVE-2016-7124）

漏洞产生原因：
如果存在_wakeup 方法，调用 unserilize() 方法前则先调用__wakeup 方法，但是序列化字符串中表示对象属性个数的值大于真实的属性个数时，会跳过__wakeup() 的执行

## 参考文章

- <https://blog.csdn.net/cldimd/article/details/104999404>
- <https://blog.csdn.net/qq_45521281/article/details/105891381>
